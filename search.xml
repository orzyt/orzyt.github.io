<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2019年03月度总结</title>
      <link href="/posts/201903-summary/"/>
      <url>/posts/201903-summary/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中心矩阵</title>
      <link href="/posts/centering-matrix/"/>
      <url>/posts/centering-matrix/</url>
      
        <content type="html"><![CDATA[<p>最近在看迁移学习的早期文章, 在求解优化问题时, 经常会涉及到<strong>中心矩阵</strong>(centering matrix). </p><p>由于之前没怎么遇到过, 故总结于此.</p><a id="more"></a><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先从多维随机变量的协方差矩阵讲起.</p><p>假设我们观察到 $n$ 个样本 $X=[\mathbf{x}_1,\mathbf{x}_2,\cdots,\mathbf{x}_n] \in \mathbb{R}^{p \times n}$，其中每个样本有 $p$ 维特征 (即 $p$ 个随机变量), $\mathbf{x}_i = [x_{i1}, \cdots, x_{ip}]^{\top} \in \mathbb{R}^{p \times 1}$. 我们往往需要计算各维度两两之间的协方差，这样各协方差组成了一个 $p*p$ 维的矩阵，称为协方差矩阵 $\Sigma$. 协方差矩阵是个对称矩阵, 对角线上的元素是各维度上随机变量的方差.</p><script type="math/tex; mode=display">\Sigma = \frac{1}{n} \sum^{n}_{i}(\mathbf{x}_i - \bar{\mathbf{x}})(\mathbf{x}_i - \bar{\mathbf{x}})^{\top}\tag{1}</script><p>其中, $\bar{\mathbf{x}} = \frac{1}{n} \sum^{n}_{i}\mathbf{x}_i \in \mathbb{R}^{p \times 1}$ 为 $p$ 个随机变量的均值.</p><p>更进一步, 我们将公式$(1)$写成矩阵形式</p><script type="math/tex; mode=display">\begin{aligned}\Sigma & = \frac{1}{n} \sum^{n}_{i}(\mathbf{x}_i - \bar{\mathbf{x}})(\mathbf{x}_i - \bar{\mathbf{x}})^{\top} \\&= \frac{1}{n} \sum^{n}_{i} (\mathbf{x}_i \mathbf{x}^{\top}_i - \mathbf{x}_i \bar{\mathbf{x}}^{\top} - \bar{\mathbf{x}} \mathbf{x}^{\top}_i + \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top}) \\&= \frac{1}{n} XX^{\top} - \frac{1}{n} \sum^{n}_{i} \mathbf{x}_i \bar{\mathbf{x}}^{\top} - \frac{1}{n} \sum^{n}_{i} \bar{\mathbf{x}} \mathbf{x}^{\top}_i + \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top} \\&= \frac{1}{n} XX^{\top} - \left( \frac{1}{n} \sum^{n}_{i} \mathbf{x}_i \right) \bar{\mathbf{x}}^{\top} - \bar{\mathbf{x}} \left( \frac{1}{n} \sum^{n}_{i}  \mathbf{x}^{\top}_i \right) + \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top} \\ &= \frac{1}{n} XX^{\top} - \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top} - \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top} + \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top} \\ &= \frac{1}{n} XX^{\top} - \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top}\end{aligned}\tag{2}</script><p>注意到, 随机变量的均值向量 $\bar{\mathbf{x}}$ 也可以用矩阵 $X$ 表示</p><script type="math/tex; mode=display">\bar{\mathbf{x}} = \frac{1}{n}X\mathbf{1}_n\tag{3}</script><p>其中, $\mathbf{1}_n = [1, \cdots, 1]^{\top} \in \mathbb{R}^{n \times 1}$ 为全 $1$ 的列向量.</p><p>因此, 将$(3)$代入公式$(2)$可得协方差矩阵的另一种表示形式</p><script type="math/tex; mode=display">\begin{aligned}\Sigma & = \frac{1}{n} XX^{\top} - \bar{\mathbf{x}} \bar{\mathbf{x}}^{\top} \\&= \frac{1}{n} XX^{\top} - \frac{1}{n^2}X\mathbf{1}_{n}\mathbf{1}^{\top}_{n}X^{\top} \\&= \frac{1}{n} X(I_n - \frac{1}{n}\mathbf{1}_{n}\mathbf{1}^{\top}_{n})X^{\top} \\&=  \frac{1}{n} XHX^{\top}\end{aligned}\tag{4}</script><p>其中, $I_n$ 为 $n$ 阶单位阵, $H = I_n - \frac{1}{n}\mathbf{1}_{n}\mathbf{1}^{\top}_{n}$ 即定义为<strong>中心矩阵</strong>(centering matrix).</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><script type="math/tex; mode=display">\begin{aligned}H^{2} &=\left(I_{n}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}\right)\left(I_{n}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}\right) \\ &=I_{n}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}+\left(\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}\right)\left(\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}\right) \\&=I_{n}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top}+\frac{1}{n^2}n \mathbf{1}_{n} \mathbf{1}_{n}^{\top} \\&=I_{n}-\frac1n \mathbf{1}_{n} \mathbf{1}_{n}^{\top} \\&=H\end{aligned}\tag{5}</script><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他性质详见维基百科: <a href="https://en.wikipedia.org/wiki/Centering_matrix" target="_blank" rel="noopener">Centering Matrix</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中心矩阵 </tag>
            
            <tag> 协方差矩阵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度域混淆</title>
      <link href="/posts/deep-domain-confusion/"/>
      <url>/posts/deep-domain-confusion/</url>
      
        <content type="html"><![CDATA[<p><strong>论文题目</strong>：Deep Domain Confusion: Maximizing for Domain Invariance</p><p><strong>论文作者</strong>：Eric Tzeng, Judy Hoffman, Ning Zhang, Kate Saenko, Trevor Darrell</p><p><strong>会议期刊</strong>：arxiv 2014</p><a id="more"></a><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文提出了一种新的卷积神经网络结构, 引入了<strong>自适应层</strong>(adaptation layer)和<strong>域混淆</strong>(domain confusion)损失函数, 从而可以学习到域不变(domain invariant)的特征表示.</p><p>同时, 本文指出域混淆度量可以用来进行模型的选择, 即确定自适应层的维度及其在CNN中的位置.</p><hr><h2 id="基于CNN的域不变表示"><a href="#基于CNN的域不变表示" class="headerlink" title="基于CNN的域不变表示"></a>基于CNN的域不变表示</h2><div align="center"><img src="https://wx3.sinaimg.cn/large/8662e3cely1g1ikol7jozj20nz0ffgns.jpg" width="50%" height="50%"></div><p>一个直观的想法是: <strong>学习可以最小化源域和目标域之间分布差异的特征表示, 使得可以在带标签的源域数据上训练分类器, 并直接应用在目标域的数据中.</strong></p><p>为此, 作者考虑使用<strong>最大均值差异</strong>(Maximum Mean Discrepancy, MMD)作为分布距离的度量. </p><script type="math/tex; mode=display">MMD(X_S, X_T) = \left\Vert \frac{1}{|X_S|} \sum \limits_{x_s \in X_S} \phi(x_s) - \frac{1}{|X_T|} \sum \limits_{x_t \in X_T} \phi(x_t) \right\Vert\tag{1}</script><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>最终的目标函数为:</p><script type="math/tex; mode=display">\mathcal{L} = \mathcal{L}_{C}(X_L, y) + \lambda MMD^2(X_S, X_T)\tag{2}</script><p>其中, $\mathcal{L}_{C}(X_L, y)$ 为带标签数据的分类损失, $MMD$ 为源域与目标域之间的分布差异, $\lambda$ 为权衡参数.</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><div align="center"><img src="https://wx1.sinaimg.cn/large/8662e3cely1g1im7vuuzaj20g50hbgmj.jpg" alt="网络结构" width="40%" height="“40%”"></div><p>本文所使用的网络基于<code>AlexNet</code>修改而来, 使用两个<strong>共享权重</strong>的CNN, 并在全连接层<code>fc7</code>之后添加了自适应层. 经过<code>fine-tuning</code>后, 作者认为自适应层可以同时学习到<strong>具有判别性</strong>且<strong>具有域不变性</strong>的特征表示.</p><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>本文采用<code>Office</code>数据集, 包含三个域: <code>Amazon</code>,<code>DSLR</code>和<code>Webcam</code>.</p><p>迁移任务: <code>Amazon-&gt;Webcam</code>, <code>DSLR-&gt;Webcam</code>, <code>Webcam-&gt;DSLR</code></p><h3 id="自适应层的位置"><a href="#自适应层的位置" class="headerlink" title="自适应层的位置"></a>自适应层的位置</h3><div align="center"><img src="https://wx3.sinaimg.cn/large/8662e3cely1g1imw2hsyvj20if0emdgw.jpg" width="40%" height="40%"></div><p>作者测试了将自适应层放置在不同的全连接层后面, 根据MMD准则, 发现放置在<code>fc7</code>后效果最好.</p><h3 id="自适应层的维度"><a href="#自适应层的维度" class="headerlink" title="自适应层的维度"></a>自适应层的维度</h3><div align="center"><img src="https://wx1.sinaimg.cn/large/8662e3cely1g1imx3kkifj20io0ekab8.jpg" width="40%" height="40%"></div><p>同时, 作者也测试了不同的自适应层维度, 根据MMD准则, 选择了<code>256</code>维.</p><h3 id="迁移效果"><a href="#迁移效果" class="headerlink" title="迁移效果"></a>迁移效果</h3><div align="center"><img src="https://ws4.sinaimg.cn/large/8662e3cely1g1in4274mpj20dd05imxh.jpg" alt="有监督条件下的多分类精度" width="50%" height="50%"></div><div align="center"><img src="https://ws3.sinaimg.cn/large/8662e3cely1g1in55orc2j20dk05ot91.jpg" alt="无监督条件下的多分类精度" width="50%" height="50%"></div><h3 id="正则化效果"><a href="#正则化效果" class="headerlink" title="正则化效果"></a>正则化效果</h3><div align="center"><img src="https://wx2.sinaimg.cn/large/8662e3cely1g1in768my6j20ii0b53yx.jpg" alt="有无正则化的测试精度" width="50%" height="50%"></div>]]></content>
      
      
      <categories>
          
          <category> 迁移学习 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迁移学习 </tag>
            
            <tag> 领域自适应 </tag>
            
            <tag> 深度域混淆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迁移成分分析</title>
      <link href="/posts/transfer-component-analysis/"/>
      <url>/posts/transfer-component-analysis/</url>
      
        <content type="html"><![CDATA[<p><strong>论文题目</strong>：Domain Adaptation via Transfer Component Analysis</p><p><strong>论文作者</strong>：Sinno Jialin Pan, Ivor W. Tsang, James T. Kwok and Qiang Yang</p><p><strong>会议期刊</strong>：IJCAI 2009</p><a id="more"></a><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>领域自适应(Domain Adaptation)</strong>的一个主要问题是如何减少源域和目标域之间的差异. </p><p>一个好的特征表示应该尽可能地减少域间分布差异, 同时保持原始数据重要的特性(如几何/统计特性等). </p><p>本文提出一个新的特征提取方式, 叫做<code>迁移成分分析</code>(transfer component analysis, TCA). </p><p>TCA学习所有域的公共迁移成分(即<strong>不会引起域间分布变化</strong>及<strong>保持原始数据固有结构</strong>的成分), 使得不同域在投影后的子空间中分布差异减少.</p><hr><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="问题设定"><a href="#问题设定" class="headerlink" title="问题设定"></a>问题设定</h3><p>源域(source domain)中有带标签数据 $\mathcal{D}_{S}$, 目标域(target domain)中只有大量无标签数据 $\mathcal{D}_{T}$. </p><ul><li><p>$\mathcal{D}_{S}=\left\{\left(x_{S_{1}}, y_{S_{1}}\right), \ldots,\left(x_{S_{n}}, y_{S_{n}}\right)\right\}$, $x_{S_{i}} \in \mathcal{X}$ 为输入数据, $y_{S_{i}} \in \mathcal{Y}$为对应的标签. </p></li><li><p>$\mathcal{D}_{T}=\left\{x_{T_{1}}, \ldots, x_{T_{n_{2}}}\right\}$, $x_{T_{i}} \in \mathcal{X}$.</p></li><li><p>$\mathcal{P(X_{S})}$ 和 $\mathcal{Q(X_{T})}$ 分别为 $X_S$ 和 $X_T$ 的边缘分布. </p></li></ul><p><strong>设定:</strong> 边缘分布不同 $\mathcal{P} \ne \mathcal{Q}$, 但类条件概率分布相同 $P(Y_{S} | X_{S}) = P(Y_{T} | X_{T})$.</p><p><strong>任务:</strong> 在目标域中预测输入数据 $x_{T_{i}}$ 对应的标签 $y_{T_{i}}$.</p><h3 id="最大均值差异"><a href="#最大均值差异" class="headerlink" title="最大均值差异"></a>最大均值差异</h3><p>我们知道, 存在很多准则可以度量不同分布之间的差异, 如, <code>KL散度</code>等.</p><p>但这些方法通常都需要对分布的概率密度进行估计, 因而是参数化的方法. 为了避免引入额外的参数, 我们希望寻找一种非参数化的方法来度量分布的差异.</p><p>在2006年, Borgwardt等人<sup><a href="#fn_1" id="reffn_1">1</a></sup>提出了一种基于<em>再生核希尔伯特空间(Reproducing Kernel Hilbert Space, RKHS)</em>的分布度量准则 <strong>最大均值差异(Maximum Mean Discrepancy, MMD)</strong>.</p><p>令 $X = \{ x_1, \cdots, x_{n1}\}$ 和 $Y = \{ y_1, \cdots, y_{n2}\}$ 为两个分布 $\mathcal{P}$ 和 $\mathcal{Q}$ 的随机变量集合, 根据MMD的定义, 两个分布的经验估计距离为:</p><script type="math/tex; mode=display">\operatorname{Dist}(\mathrm{X}, \mathrm{Y})=\left\|\frac{1}{n_{1}} \sum_{i=1}^{n_{1}} \phi\left(x_{i}\right)-\frac{1}{n_{2}} \sum_{i=1}^{n_{2}} \phi\left(y_{i}\right)\right\|_{\mathcal{H}}\tag{1}</script><p>其中, $\mathcal{H}$ 是再生核希尔伯特空间, $\phi : \mathcal{X} \to \mathcal{H}$ 为核函数映射.</p><hr><h2 id="迁移成分分析"><a href="#迁移成分分析" class="headerlink" title="迁移成分分析"></a>迁移成分分析</h2><p>令 $\phi : \mathcal{X} \to \mathcal{H}$ 为非线性映射, $X^{\prime}_{S} = \{ x^{\prime}_{S_{i}} \} = \{ \phi(x_{S_{i}}) \}$, $X^{\prime}_{T} = \{ x^{\prime}_{T_{i}} \} = \{ \phi(x_{T_{i}}) \}$, $X^{\prime} = X^{\prime}_{S} \cup X^{\prime}_{T}$ 分别为源域/目标域/结合域映射后的数据. </p><p>我们希望找到这样一个映射, 使得映射后的数据分布一致, 即 $\mathcal{P^{\prime}}(X^{\prime}_{S}) = \mathcal{Q^{\prime}}(X^{\prime}_{T})$.</p><p>根据MMD的定义, 我们可以通过<strong>度量两个域之间的经验均值的距离平方</strong>作为分布的距离.</p><script type="math/tex; mode=display">\operatorname{Dist}\left(X_{S}^{\prime}, X_{T}^{\prime}\right)=\left\|\frac{1}{n_{1}} \sum_{i=1}^{n_{1}} \phi\left(x_{S_{i}}\right)-\frac{1}{n_{2}} \sum_{i=1}^{n_{2}} \phi\left(x_{T_{i}}\right)\right\|_{\mathcal{H}}^{2}\tag{2}</script><p>通过最小化公式$(2)$, 我们可以找到想要的非线性映射 $\phi$.</p><p>然而, 对公式$(2)$直接优化是十分困难的, 通常会陷入局部极值点. 因此, 必须另辟蹊径.</p><h3 id="核学习"><a href="#核学习" class="headerlink" title="核学习"></a>核学习</h3><p>为了避免显式地直接寻找非线性变换 $\phi$, Pan等人<sup><a href="#fn_2" id="reffn_2">2</a></sup>将该问题转化为<strong>核学习</strong>(kernel learning)问题.</p><p>通过利用核技巧 $k(x_i, x_j) = \phi(x_i)^{\prime}\phi(x_j)$, 公式$(2)$中两个域之间的经验均值距离可以被写为:</p><script type="math/tex; mode=display">\begin{aligned} \operatorname{Dist}\left(X_{S}^{\prime}, X_{T}^{\prime}\right) &= \frac{1}{n^{2}_{1}} \sum_{i=1}^{n_1} \sum_{j=1}^{n_1} k\left(x_{S_i}, x_{S_j}\right)+\frac{1}{n^{2}_{2}} \sum_{i=1}^{n_2} \sum_{j=1}^{n_2} k\left(x_{T_i}, x_{T_j}\right)-\frac{2}{n_1 n_2} \sum_{i=1}^{n_1} \sum_{j=1}^{n_2} k\left(x_{S_i}, x_{T_j}\right) \\&= \operatorname{tr}(K L) \\\end{aligned}\tag{3}</script><p>其中,</p><script type="math/tex; mode=display">K=\left[ \begin{array}{ll}{K_{S, S}} & {K_{S, T}} \\ {K_{T, S}} & {K_{T, T}}\end{array}\right]\tag{4}</script><p>为 $(n_1 + n_2) \times (n_1 + n_2)$ 大小的核矩阵, $K_{S,S}$, $K_{T,T}$, $K_{S,T}$ 分别为由 $k$ 定义在源域/目标域/跨域的核矩阵.</p><p>$L = [ L_{ij} ] \succeq 0$ 为半正定矩阵, 其中</p><script type="math/tex; mode=display">l_{i j}=\left\{\begin{array}{ll}{\frac{1}{n_{1}^{2}}} & {x_{i}, x_{j} \in \mathcal{D}_{s}} \\ {\frac{1}{n_{2}^{2}}} & {x_{i}, x_{j} \in \mathcal{D}_{t}} \\ {-\frac{1}{n_{1} n_{2}}} & {\text { otherwise }}\end{array}\right.\tag{5}</script><p>在直推学习的设置下(直推学习即<strong>假设未标记的数据就是最终要用来测试的数据, 学习的目的即为在这些数据上取得最佳泛化能力</strong>), 核函数 $k(\cdot, \cdot)$ 可以通过求解核矩阵 $K$ 替代. </p><p>Pan等人<sup><a href="#fn_2" id="reffn_2">2</a></sup>将核矩阵学习问题形式化为<strong>半定规划</strong>(semi-definite program, SDP)问题. 然后, 对学习到的核矩阵使用PCA方法得到跨域的低维隐空间.</p><h3 id="参数化核映射"><a href="#参数化核映射" class="headerlink" title="参数化核映射"></a>参数化核映射</h3><p>MMDE<sup><a href="#fn_2" id="reffn_2">2</a></sup>的方法存在如下局限性:</p><ul><li>它是直推式的, 不能泛化到未见的样本中</li><li>公式$(3)$中的$K$需要是半正定的, 且求解SDP问题十分耗时</li><li>为了构造低维表示, 需要对$K$进行PCA处理, 这会损失$K$中的信息</li></ul><p>本文提出一种基于核特征提取来寻找非线性映射 $\phi$ 的高效方法.</p><ul><li>避免求解SDP问题, 减轻计算负担</li><li>学习到的核函数$k$可以泛化到未见的样本</li><li>利用显式的低秩表示得到统一的核学习方法</li></ul><p>首先, 公式$(4)$中的核矩阵 $K$ 可以被分解为 $K = (KK^{-1/2})(K^{-1/2}K)$, 这通常称为<strong>经验核映射</strong>(empirical kernel map)<sup><a href="#fn_3" id="reffn_3">3</a></sup>. </p><blockquote><p><font color="blue">★注:</font> 这个分解可由矩阵的特征分解得到, 即令 $K = Q^{-1}\Lambda Q$ 代入.<br>至于为什么要对核矩阵 $K$ 进行分解, 可以这样理解, 核矩阵给出的是映射后数据的内积, 即 $K_{ij} = k(x_i, x_j)$, 但我们只想知道映射后的数据 $\phi(x)$ 该怎么办? 便可以将矩阵分解成 $K=A^TA$ 的形式, 使得 $A = [ \phi(x_1), \cdots, \phi(x_{n_1 + n_2}) ]$, 即 $A$ 中的每个元素都是映射后的数据.<br>在上述的分解中, $A$ 即为 $K^{-1/2}K$. 注意到 $K$ 为对称半正定矩阵, 因此 $A^T = (K^{-1/2}K)^T = KK^{-1/2}$.</p></blockquote><p>考虑使用 $(n_1 + n_2) \times m$ 维的矩阵 $\widetilde{W}$ 将特征变化到 $m$ 维空间 (通常 $m \ll n_1 + n_2$), 则得到的核矩阵为:</p><script type="math/tex; mode=display">\widetilde{K} = (KK^{-1/2}\widetilde{W})(\widetilde{W}^TK^{-1/2}K) = KWW^TK\tag{6}</script><p>其中, $W = K^{-1/2}\widetilde{W} \in \mathbb{R}^{(n_1 + n_2) \times m}$. 特别地, 任意两个数据 $x_i$ 和 $x_j$ 的核函数为:</p><script type="math/tex; mode=display">\tilde{k}(x_i, x_j) = k^{T}_{x_i}WW^Tk_{x_j}\tag{7}</script><p>其中, $k_x = [ k(x_1, x), \cdots, k(x_{n_1 + n_2}, x)]^T \in \mathbb{R}^{n_1 + n_2}$. 因此, 公式$(7)$中的核函数给出了未见样本的参数化核估计表示.</p><p>此外, 根据公式$(6)$中$\widetilde{K}$的定义, 两个域之间的经验均值距离可重新写为:</p><script type="math/tex; mode=display">\begin{aligned} \operatorname{Dist}\left(X_{S}^{\prime}, X_{T}^{\prime}\right) &=\operatorname{tr}\left(\left(K W W^{\top} K\right) L\right) \\ &=\operatorname{tr}\left(W^{\top} K L K W\right) \\& {\scriptsize //利用迹循环性质:tr(ABC)=tr(BCA)=tr(CAB)}\end{aligned}\tag{8}</script><h3 id="迁移成分提取"><a href="#迁移成分提取" class="headerlink" title="迁移成分提取"></a>迁移成分提取</h3><p>在最小化公式$(8)$的时候, 通常需要加一个正则项 $tr(W^TW)$ (即矩阵二范数 $\Vert W \Vert_{2}$)来控制参数 $W$ 的复杂度.</p><p>从而, 领域自适应的核学习问题可变为:</p><script type="math/tex; mode=display">\begin{array}{cl}{\min \limits_{W}} & {\operatorname{tr}\left(W^{\top} W\right)+\mu \operatorname{tr}\left(W^{\top} K L K W\right)} \\{\text { s.t. }} & {W^{\top} K H K W=I}\end{array}\tag{9}</script><p>其中, $\mu$ 为权衡参数, $I \in \mathbb{R}^{m \times m}$ 为单位阵, $H = I_{n_1 + n_2} - \frac{1}{n_1 + n_2} \mathrm{1}\mathrm{1}^T$ 为<strong>中心矩阵</strong>(centering matrix), $\mathrm{1} \in \mathbb{R}^{n_1 + n_2}$ 为全1列向量, $I_{n_1 + n_2} \in \mathbb{R}^{(n_1 + n_2) \times (n_1 + n_)}$ 为单位阵.</p><blockquote><p><font color="blue">★注:</font> 添加 $W^{\top} K H K W=I$ 限制条件一方面是为了<strong>避免平凡解</strong>(即$W = 0$), 另一方面是为了<strong>保持数据的散度</strong>($W^{\top} K H K W$为投影后数据$W^{\top} K$的散度矩阵), 即前面简介中所说的保持原始数据固有结构.</p></blockquote><p>尽管公式$(9)$为非凸优化问题, 但其可以转化为迹优化问题:</p><script type="math/tex; mode=display">\min _{W} \operatorname{tr}\left(\left(W^{\top} K H K W\right)^{\dagger} W^{\top}(I+\mu K L K) W\right)\tag{10}</script><p>或者</p><script type="math/tex; mode=display">\max _{W} \operatorname{tr}\left(\left(W^{\top}(I+\mu K L K) W\right)^{-1} W^{\top} K H K W\right)\tag{11}</script><p>上述转化可由拉格朗日乘子法得到, 具体证明略…</p><p>类似于核Fisher判别, <strong>公式$(11)$中 $W$ 的解为 $(I + \mu KLK)^{-1}KHK$ 的前 $m$ 个特征值对应的特征向量</strong>. </p><p>因此, 本文提出的方法命名为<strong>迁移成分分析</strong>(Transfer Component Analysis, TCA).</p><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="toy-dataset"><a href="#toy-dataset" class="headerlink" title="toy dataset"></a>toy dataset</h3><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g1hftr8fffj216z0e8dk4.jpg" alt="(左) toy dataset   (中) PCA   (右) TCA" width="100%" height="100%"></p><h3 id="跨域WiFi定位"><a href="#跨域WiFi定位" class="headerlink" title="跨域WiFi定位"></a>跨域WiFi定位</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g1hf7xqzy5j217g0digpo.jpg" width="100%" height="100%"></p><h3 id="跨域文本分类"><a href="#跨域文本分类" class="headerlink" title="跨域文本分类"></a>跨域文本分类</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g1hf9nurmyj216f0kewj1.jpg" width="100%" height="100%"></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>via: <a href="https://github.com/jindongwang/transferlearning/tree/master/code/traditional/TCA" target="_blank" rel="noopener">jindongwang/transferlearning</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    Created on 21:29 2018/11/12 </span></span><br><span class="line"><span class="string">    @author: Jindong Wang</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> scipy.linalg</span><br><span class="line"><span class="keyword">import</span> sklearn.metrics</span><br><span class="line"><span class="keyword">import</span> sklearn.neighbors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernel</span><span class="params">(ker, X, X2, gamma)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ker <span class="keyword">or</span> ker == <span class="string">'primal'</span>:</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    <span class="keyword">elif</span> ker == <span class="string">'linear'</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> X2:</span><br><span class="line">            K = np.dot(X.T, X)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            K = np.dot(X.T, X2)</span><br><span class="line">    <span class="keyword">elif</span> ker == <span class="string">'rbf'</span>:</span><br><span class="line">        n1sq = np.sum(X ** <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line">        n1 = X.shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> X2:</span><br><span class="line">            D = (np.ones((n1, <span class="number">1</span>)) * n1sq).T + \</span><br><span class="line">            np.ones((n1, <span class="number">1</span>)) * n1sq - <span class="number">2</span> * np.dot(X.T, X)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n2sq = np.sum(X2 ** <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line">            n2 = X2.shape[<span class="number">1</span>]</span><br><span class="line">            D = (np.ones((n2, <span class="number">1</span>)) * n1sq).T + \</span><br><span class="line">            np.ones((n1, <span class="number">1</span>)) * n2sq - <span class="number">2</span> * np.dot(X.T, X)</span><br><span class="line">        K = np.exp(-gamma * D)</span><br><span class="line">    <span class="keyword">elif</span> ker == <span class="string">'sam'</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> X2:</span><br><span class="line">            D = np.dot(X.T, X)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            D = np.dot(X.T, X2)</span><br><span class="line">        K = np.exp(-gamma * np.arccos(D) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCA</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kernel_type=<span class="string">'primal'</span>, dim=<span class="number">30</span>, lamb=<span class="number">1</span>, gamma=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Init func</span></span><br><span class="line"><span class="string">        :param kernel_type: kernel, values: 'primal' | 'linear' | 'rbf' | 'sam'</span></span><br><span class="line"><span class="string">        :param dim: dimension after transfer</span></span><br><span class="line"><span class="string">        :param lamb: lambda value in equation</span></span><br><span class="line"><span class="string">        :param gamma: kernel bandwidth for rbf kernel</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.kernel_type = kernel_type</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.lamb = lamb</span><br><span class="line">        self.gamma = gamma</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, Xs, Xt)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Transform Xs and Xt</span></span><br><span class="line"><span class="string">        :param Xs: ns * n_feature, source feature</span></span><br><span class="line"><span class="string">        :param Xt: nt * n_feature, target feature</span></span><br><span class="line"><span class="string">        :return: Xs_new and Xt_new after TCA</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        X = np.hstack((Xs.T, Xt.T))</span><br><span class="line">        X /= np.linalg.norm(X, axis=<span class="number">0</span>)</span><br><span class="line">        m, n = X.shape</span><br><span class="line">        ns, nt = len(Xs), len(Xt)</span><br><span class="line">        e = np.vstack((<span class="number">1</span> / ns * np.ones((ns, <span class="number">1</span>)), <span class="number">-1</span> / nt * np.ones((nt, <span class="number">1</span>))))</span><br><span class="line">        M = e * e.T</span><br><span class="line">        M = M / np.linalg.norm(M, <span class="string">'fro'</span>)</span><br><span class="line">        H = np.eye(n) - <span class="number">1</span> / n * np.ones((n, n))</span><br><span class="line">        K = kernel(self.kernel_type, X, <span class="keyword">None</span>, gamma=self.gamma)</span><br><span class="line">        n_eye = m <span class="keyword">if</span> self.kernel_type == <span class="string">'primal'</span> <span class="keyword">else</span> n</span><br><span class="line">        a, b = np.linalg.multi_dot([K, M, K.T]) + self.lamb * \</span><br><span class="line">               np.eye(n_eye), np.linalg.multi_dot([K, H, K.T])</span><br><span class="line">        w, V = scipy.linalg.eig(a, b)</span><br><span class="line">        ind = np.argsort(w)</span><br><span class="line">        A = V[:, ind[:self.dim]]</span><br><span class="line">        Z = np.dot(A.T, K)</span><br><span class="line">        Z /= np.linalg.norm(Z, axis=<span class="number">0</span>)</span><br><span class="line">        Xs_new, Xt_new = Z[:, :ns].T, Z[:, ns:].T</span><br><span class="line">        <span class="keyword">return</span> Xs_new, Xt_new</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_predict</span><span class="params">(self, Xs, Ys, Xt, Yt)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Transform Xs and Xt, then make predictions on target using 1NN</span></span><br><span class="line"><span class="string">        :param Xs: ns * n_feature, source feature</span></span><br><span class="line"><span class="string">        :param Ys: ns * 1, source label</span></span><br><span class="line"><span class="string">        :param Xt: nt * n_feature, target feature</span></span><br><span class="line"><span class="string">        :param Yt: nt * 1, target label</span></span><br><span class="line"><span class="string">        :return: Accuracy and predicted_labels on the target domain</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        Xs_new, Xt_new = self.fit(Xs, Xt)</span><br><span class="line">        clf = sklearn.neighbors.KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">        clf.fit(Xs_new, Ys.ravel())</span><br><span class="line">        y_pred = clf.predict(Xt_new)</span><br><span class="line">        acc = sklearn.metrics.accuracy_score(Yt, y_pred)</span><br><span class="line">        <span class="keyword">return</span> acc, y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    domains = [<span class="string">'caltech.mat'</span>, <span class="string">'amazon.mat'</span>, <span class="string">'webcam.mat'</span>, <span class="string">'dslr.mat'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                src, tar = <span class="string">'data/'</span> + domains[i], <span class="string">'data/'</span> + domains[j]</span><br><span class="line">                src_domain, tar_domain = scipy.io.loadmat(src), scipy.io.loadmat(tar)</span><br><span class="line">                Xs, Ys, Xt, Yt = src_domain[<span class="string">'feas'</span>], src_domain[<span class="string">'label'</span>], \</span><br><span class="line">                                 tar_domain[<span class="string">'feas'</span>], tar_domain[<span class="string">'label'</span>]</span><br><span class="line">                tca = TCA(kernel_type=<span class="string">'primal'</span>, dim=<span class="number">30</span>, lamb=<span class="number">1</span>, gamma=<span class="number">1</span>)</span><br><span class="line">                acc, ypre = tca.fit_predict(Xs, Ys, Xt, Yt)</span><br><span class="line">                print(acc)</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Karsten M. Borgwardt, Arthur Gretton, Malte J. Rasch, Hans-Peter Kriegel, Bernhard Scholkopf, and Alexander J. Smola. <strong>Integrating structured biological data by kernel maximum mean discrepancy</strong>. In ISMB, pages 49–57, Fortaleza, Brazil, 2006<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. Sinno Jialin Pan, James T. Kwok, and Qiang Yang. <strong>Transfer learning via dimensionality reduction</strong>. In Proceedings of AAAI, pages 677–682, Chicago, Illinois, USA, 2008.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. Bernhard Scholkopf, Alexander Smola, and Klaus-Robert Muller. <strong>Nonlinear component analysis as a kernel eigenvalue problem</strong>. Neural Computation, 10(5):1299–1319,1998.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 迁移学习 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迁移学习 </tag>
            
            <tag> 领域自适应 </tag>
            
            <tag> 迁移成分分析 </tag>
            
            <tag> TCA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迁移自适应学习综述</title>
      <link href="/posts/transfer-adaptation-learning/"/>
      <url>/posts/transfer-adaptation-learning/</url>
      
        <content type="html"><![CDATA[<p><strong>论文题目</strong>：Transfer Adaptation Learning: A Decade Survey</p><p><strong>论文作者</strong>：Lei Zhang</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1903.04687.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1903.04687.pdf</a></p><a id="more"></a><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在很多实际的情况中, <strong>源域(source domain)</strong>和<strong>目标域(target domain)</strong>之间存在：</p><ul><li><strong>分布不匹配(distribution mismatch)</strong></li><li><strong>领域偏移(domain shift)</strong></li></ul><p><strong>独立同分布(independent identical distribution, i.i.d)</strong>的假设不再满足!</p><ul><li><p><strong>迁移学习(transfer learning)</strong>假设源域与目标域拥有不同的<strong>联合概率分布</strong> </p><script type="math/tex; mode=display">P(X_{source}, Y_{source}) \neq P(X_{target}, Y_{target})</script></li><li><p><strong>领域自适应(domain adaptation)</strong>假设源域与目标域拥有不同的<strong>边缘概率分布</strong>, 但拥有相同的<strong>条件概率分布</strong></p><script type="math/tex; mode=display">P(X_{source}) \neq P(X_{target}), P(Y_{source} | X_{source}) = P(Y_{target} | X_{target})</script></li></ul><hr><h2 id="实例权重调整自适应"><a href="#实例权重调整自适应" class="headerlink" title="实例权重调整自适应"></a>实例权重调整自适应</h2><p>当训练集和测试集来自不同分布时, 这通常被称为<strong>采样选择偏差(sample selection bias)</strong>或者<strong>协方差偏移(covariant shift)</strong>. </p><p>实例权重调整方法旨在<strong>通过非参数方式对跨域特征分布匹配直接推断出重采样的权重</strong>. </p><h3 id="基于直觉的权重调整"><a href="#基于直觉的权重调整" class="headerlink" title="基于直觉的权重调整"></a>基于直觉的权重调整</h3><p>直接对原始数据进行权重调整. </p><p>首次提出于NLP领域<sup><a href="#fn_1" id="reffn_1">1</a></sup>, 主要的方法有著名的<code>TrAdaBoost</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>.</p><h3 id="基于核映射的权重调整"><a href="#基于核映射的权重调整" class="headerlink" title="基于核映射的权重调整"></a>基于核映射的权重调整</h3><p>将原始数据映射到高维空间(如,再生核希尔伯特空间RKHS)中进行权重调整.</p><h4 id="分布匹配"><a href="#分布匹配" class="headerlink" title="分布匹配"></a>分布匹配</h4><p>主要思想是<strong>通过重新采样源数据的权重来匹配再生核希尔伯特空间中源数据和目标数据之间的均值</strong>. </p><p>主要有两种非参数统计量来衡量分布差异:</p><ul><li><strong>核均值匹配(kernel mean matching, KMM)</strong></li></ul><script type="math/tex; mode=display">\begin{array}{l}{\min \limits_{\beta}\left\|E_{x^{\prime} \sim P_{r}^{\prime}}\left[\Phi\left(x^{\prime}\right)\right]-E_{x \sim P_{r}}[\beta(x) \Phi(x)]\right\|} \\{\text {s.t.} \quad \beta(x) \geq 0, E_{x \sim P_{r}}[\beta(x)]=1}\end{array}</script><p>Huang等人<sup><a href="#fn_3" id="reffn_3">3</a></sup>首次提出通过调整源样本的$\beta$权重系数, 使得带权源样本和目标样本的KMM最小.</p><ul><li><strong>最大均值差异(maximum mean discrepancy, MMD)</strong><sup><a href="#fn_4" id="reffn_4">4</a></sup><sup><a href="#fn_5" id="reffn_5">5</a></sup></li></ul><script type="math/tex; mode=display">d_{\mathcal{H}}^{2}\left(\mathcal{D}_{s}, \mathcal{D}_{t}\right)=\left\|\frac{1}{M} \sum_{i=1}^{M} \phi\left(x_{i}^{s}\right)-\frac{1}{N} \sum_{j=1}^{N} \phi\left(x_{j}^{t}\right)\right\|_{\mathcal{H}}^{2}</script><p><code>weighted MMD</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>方法考虑了类别权重偏差.</p><h4 id="样本选择"><a href="#样本选择" class="headerlink" title="样本选择"></a>样本选择</h4><p>主要方法有基于k-means聚类的<code>KMapWeighted</code><sup><a href="#fn_7" id="reffn_7">7</a></sup>, 基于MMD和$\ell_{2,1}$-norm的<code>TJM</code><sup><a href="#fn_8" id="reffn_8">8</a></sup>等.</p><h3 id="协同训练"><a href="#协同训练" class="headerlink" title="协同训练"></a>协同训练</h3><p>主要思想是假设数据集被表征为两个不同的视角, 使两个分类器独立地从每个视角中进行学习.</p><p>主要方法有<code>CODA</code><sup><a href="#fn_9" id="reffn_9">9</a></sup>, 以及基于GAN的<code>RANN</code><sup><a href="#fn_10" id="reffn_10">10</a></sup>等.</p><hr><h2 id="特征自适应"><a href="#特征自适应" class="headerlink" title="特征自适应"></a>特征自适应</h2><p>特征自适应方法旨在<strong>寻找多源数据(multiple sources)的共同特征表示</strong>.</p><h3 id="基于特征子空间"><a href="#基于特征子空间" class="headerlink" title="基于特征子空间"></a>基于特征子空间</h3><p>该方法假设<strong>数据可以被低维线性子空间进行表示, 即低维的格拉斯曼流形(Grassmann manifold)被嵌入到高维数据中</strong>. </p><p>通常用PCA方法来构造该流形, 使得源域和目标域可以看成流形上的两个点, 并得到两者的测地线距离(geodesic flow).</p><ul><li><p>基于流形的方法有<code>SGF</code><sup><a href="#fn_11" id="reffn_11">11</a></sup>和<code>GFK</code><sup><a href="#fn_12" id="reffn_12">12</a></sup></p></li><li><p>基于子空间对齐的方法有<code>SA</code><sup><a href="#fn_13" id="reffn_13">13</a></sup>,<code>SDA</code><sup><a href="#fn_14" id="reffn_14">14</a></sup>和<code>GTH</code><sup><a href="#fn_15" id="reffn_15">15</a></sup></p></li></ul><h3 id="基于特征变换"><a href="#基于特征变换" class="headerlink" title="基于特征变换"></a>基于特征变换</h3><p>特征变换方法旨在<strong>学习变换或投影矩阵,使得源域和目标域中的数据在某种分布度量准则下更接近</strong>.</p><h4 id="基于投影"><a href="#基于投影" class="headerlink" title="基于投影"></a>基于投影</h4><p>该方法通过减少不同域之间的边缘分布和条件分布差异, 求解出最优的投影矩阵.</p><p>主要方法有:</p><ul><li><p>基于边缘分布MMD的<code>TCA</code><sup><a href="#fn_16" id="reffn_16">16</a></sup>, 条件分布MMD的<code>JDA</code><sup><a href="#fn_17" id="reffn_17">17</a></sup></p></li><li><p>基于布拉格曼散度(Bregman divergence)的<code>TSL</code><sup><a href="#fn_18" id="reffn_18">18</a></sup></p></li><li><p>基于希尔伯特-施密特独立性(Hilbert-Schmidt Independence Criterion)<sup><a href="#fn_19" id="reffn_19">19</a></sup></p></li></ul><h4 id="基于度量"><a href="#基于度量" class="headerlink" title="基于度量"></a>基于度量</h4><p>该方法通过在带标签的源域中学习一个好的距离度量, 使得其能够应用于相关但不同的目标域中.</p><p>主要方法有:</p><ul><li><p>基于一阶统计量的<code>RTML</code><sup><a href="#fn_20" id="reffn_20">20</a></sup></p></li><li><p>基于二阶统计量的<code>CORAL</code><sup><a href="#fn_21" id="reffn_21">21</a></sup></p></li></ul><h4 id="基于增强"><a href="#基于增强" class="headerlink" title="基于增强"></a>基于增强</h4><p>该方法假设数据的特征被分为三种类型:公共特征/源域特征/目标域特征.</p><p>主要方法有:</p><ul><li>基于零填充(Zero Padding)的<code>EasyAdapt(EA)</code><sup><a href="#fn_22" id="reffn_22">22</a></sup></li><li>基于生成式模型(Generative Model)<sup><a href="#fn_23" id="reffn_23">23</a></sup></li></ul><h3 id="基于特征重构"><a href="#基于特征重构" class="headerlink" title="基于特征重构"></a>基于特征重构</h3><p>主要方法有:</p><ul><li>低秩重构(Low-rank Reconstruction)<sup><a href="#fn_24" id="reffn_24">24</a></sup></li><li>稀疏重构(Sparse Reconstruction)<sup><a href="#fn_25" id="reffn_25">25</a></sup></li></ul><h3 id="基于特征编码"><a href="#基于特征编码" class="headerlink" title="基于特征编码"></a>基于特征编码</h3><p>主要方法有:</p><ul><li>共享域字典(Domain-shared dictionary)<sup><a href="#fn_26" id="reffn_26">26</a></sup></li><li>指定域字典(Domain-specific dictionary)<sup><a href="#fn_27" id="reffn_27">27</a></sup></li></ul><hr><h2 id="分类器自适应"><a href="#分类器自适应" class="headerlink" title="分类器自适应"></a>分类器自适应</h2><p>分类器自适应旨在<strong>利用源域中带标签数据和目标域中少量带标签数据学习一个通用的分类器</strong>.</p><h3 id="基于核分类器"><a href="#基于核分类器" class="headerlink" title="基于核分类器"></a>基于核分类器</h3><p>主要方法有:</p><ul><li><p>自适应支持向量机(adaptive support vector machine, ASVM)<sup><a href="#fn_28" id="reffn_28">28</a></sup></p></li><li><p>基于多核学习(multiple kernel learning, MKL)的域迁移分类器<sup><a href="#fn_29" id="reffn_29">29</a></sup></p></li></ul><h3 id="基于流形正则项"><a href="#基于流形正则项" class="headerlink" title="基于流形正则项"></a>基于流形正则项</h3><p>主要方法有<code>ARTL</code><sup><a href="#fn_30" id="reffn_30">30</a></sup>,<code>DMM</code><sup><a href="#fn_31" id="reffn_31">31</a></sup>,<code>MEDA</code><sup><a href="#fn_32" id="reffn_32">32</a></sup>等.</p><h3 id="基于贝叶斯分类器"><a href="#基于贝叶斯分类器" class="headerlink" title="基于贝叶斯分类器"></a>基于贝叶斯分类器</h3><p>主要方法有核贝叶斯迁移学习<code>KBTL</code><sup><a href="#fn_33" id="reffn_33">33</a></sup>等.</p><hr><h2 id="深度网络自适应"><a href="#深度网络自适应" class="headerlink" title="深度网络自适应"></a>深度网络自适应</h2><p>2014年, Yosinski等人<sup><a href="#fn_34" id="reffn_34">34</a></sup>讨论了深度神经网络中不同层特征的可迁移特性. </p><h3 id="基于边缘分布对齐"><a href="#基于边缘分布对齐" class="headerlink" title="基于边缘分布对齐"></a>基于边缘分布对齐</h3><p>主要方法有:</p><ul><li>深度域混淆<code>DDC</code><sup><a href="#fn_35" id="reffn_35">35</a></sup></li><li>深度自适应网络<code>DAN</code><sup><a href="#fn_36" id="reffn_36">36</a></sup></li><li>联合自适应网络<code>JAN</code><sup><a href="#fn_37" id="reffn_37">37</a></sup>, 同时提出了<code>Joint MMD</code>准则</li></ul><h3 id="基于条件分布对齐"><a href="#基于条件分布对齐" class="headerlink" title="基于条件分布对齐"></a>基于条件分布对齐</h3><p>主要方法有深度迁移网络<code>DTN</code><sup><a href="#fn_38" id="reffn_38">38</a></sup></p><h3 id="基于自动编码器"><a href="#基于自动编码器" class="headerlink" title="基于自动编码器"></a>基于自动编码器</h3><p>主要方法有边缘堆叠式降噪自动编码器<code>mSDA</code><sup><a href="#fn_39" id="reffn_39">39</a></sup></p><hr><h2 id="对抗式自适应"><a href="#对抗式自适应" class="headerlink" title="对抗式自适应"></a>对抗式自适应</h2><p>通过对抗目标(如,域判别器)来减少域间差异.</p><h3 id="基于梯度转换"><a href="#基于梯度转换" class="headerlink" title="基于梯度转换"></a>基于梯度转换</h3><p>Ganin等人<sup><a href="#fn_40" id="reffn_40">40</a></sup>首次提出可以通过添加一个简单的<strong>梯度转换层(gradient reversal layer, GRL)</strong>来实现领域自适应.</p><h3 id="基于Minimax优化"><a href="#基于Minimax优化" class="headerlink" title="基于Minimax优化"></a>基于Minimax优化</h3><p>Ajakan等人<sup><a href="#fn_41" id="reffn_41">41</a></sup>首次结合分类损失和对抗目标, 提出了<code>DANN</code>方法.</p><p>其它方法还有:</p><ul><li><p>对抗判别领域自适应<code>ADDA</code><sup><a href="#fn_42" id="reffn_42">42</a></sup></p></li><li><p>条件领域对抗网络<code>CDAN</code><sup><a href="#fn_43" id="reffn_43">43</a></sup></p></li><li><p>最大分类器差异<code>MCD</code><sup><a href="#fn_44" id="reffn_44">44</a></sup></p></li></ul><h3 id="基于生成对抗网络"><a href="#基于生成对抗网络" class="headerlink" title="基于生成对抗网络"></a>基于生成对抗网络</h3><p>主要方法有:</p><ul><li><p><code>CyCADA</code><sup><a href="#fn_45" id="reffn_45">45</a></sup></p></li><li><p><code>Duplex GAN</code><sup><a href="#fn_46" id="reffn_46">46</a></sup></p></li><li><p>…</p></li></ul><h2 id="基准数据集"><a href="#基准数据集" class="headerlink" title="基准数据集"></a>基准数据集</h2><ul><li>Office-31 (3DA) </li><li>Office+Caltech-10 (4DA)</li><li>MNIST+USPS</li><li>Multi-PIE</li><li>COIL-20</li><li>MSRC+VOC2007</li><li>IVLSC</li><li>Cross-dataset Testbed</li><li>Office Home<sup><font color="red">NEW</font></sup></li><li>ImageCLEF</li><li>P-A-C-S<sup><font color="red">NEW</font></sup></li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. J. Jiang and C. Zhai, <strong>Instance weighting for domain adaptation in nlp</strong>, in ACL, 2007, pp. 264–271.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. W. Dai, Q. Yang, G. R. Xue, and Y. Yu, <strong>Boosting for transfer learning</strong>, in ICML, 2007, pp. 193–200.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. J. Huang, A. Smola, A. Gretton, K. Borgwardt, and B. Scholkopf, <strong>Correcting sample selection bias by unlabeled data</strong>, in NIPS, 2007, pp. 1–8.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. A. Gretton, K. Borgwardt, M. Rasch, B. Schoelkopf, and A. Smola, <strong>A kernel method for the two-sample-problem</strong>, in NIPS, 2006.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. A. Gretton, K. Borgwardt, M. Rasch, B. Scholkopf, and A. Smola, <strong>A kernel two-sample test</strong>, Journal of Machine Learning Research, pp. 723–773, 2012<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. H. Yan, Y. Ding, P. Li, Q. Wang, Y. Xu, and W. Zuo, <strong>Mind the class weight bias: Weighted maximum mean discrepancy for unsupervised domain adaptation</strong>, in CVPR, 2017, pp. 2272–2281<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. E. H. Zhong, W. Fan, J. Peng, K. Zhang, J. Ren, D. S. Turaga, and O. Verscheure, <strong>Cross domain distribution adaptation via kernel mapping</strong>, in ACM SIGKDD, 2009, pp. 1027–1036.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. M. Long, J. Wang, G. Ding, J. Sun, and P. S. Yu, <strong>Transfer joint matching for unsupervised domain adaptation</strong>, in CVPR, 2014, pp. 1410–1417.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. M. Chen, K. Q. Weinberger, and J. C. Blitzer, <strong>Co-training for domain adaptation</strong>, in NIPS, 2011.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. Q. Chen, Y. Liu, Z. Wang, I. Wassell, and K. Chetty, <strong>Re-weighted adversarial adaptation network for unsupervised domain adaptation</strong>, in CVPR, 2018, pp. 7976–7985.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. R. Gopalan, R. Li, and R. Chellappa, <strong>Domain adaptation for object recognition: An unsupervised approach</strong>, in ICCV, 2011, pp. 999–1006<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. B. Gong, Y. Shi, F. Sha, and K. Grauman, <strong>Geodesic flow kernel for unsupervised domain adaptation</strong>, in CVPR, 2012, pp. 2066–2073<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote><blockquote id="fn_13"><sup>13</sup>. B. Fernando, A. Habrard, M. Sebban, and T. Tuytelaars, <strong>Unsupervised visual domain adaptation using subspace alignment</strong>, in ICCV, 2013, pp. 2960–2967.<a href="#reffn_13" title="Jump back to footnote [13] in the text."> &#8617;</a></blockquote><blockquote id="fn_14"><sup>14</sup>. B. Sun and K. Saenko, <strong>Subspace distribution alignment for unsupervised domain adaptation</strong>, in BMVC, 2015, pp. 24.1–24.10.<a href="#reffn_14" title="Jump back to footnote [14] in the text."> &#8617;</a></blockquote><blockquote id="fn_15"><sup>15</sup>. J. Liu and L. Zhang, <strong>Optimal projection guided transfer hashing for image retrieval</strong>, in AAAI, 2018.<a href="#reffn_15" title="Jump back to footnote [15] in the text."> &#8617;</a></blockquote><blockquote id="fn_16"><sup>16</sup>. S. J. Pan, I. W. Tsang, J. T. Kwok, and Q. Yang, <strong>Domain adaptation via transfer component analysis</strong>, IEEE Trans. Neural Networks, vol. 22, no. 2, p. 199, 2011<a href="#reffn_16" title="Jump back to footnote [16] in the text."> &#8617;</a></blockquote><blockquote id="fn_17"><sup>17</sup>.  M. Long, J. Wang, G. Ding, J. Sun, and P. S. Yu, <strong>Transfer feature learning with joint distribution adaptation</strong>, in ICCV, 2014, pp. 2200–2207.<a href="#reffn_17" title="Jump back to footnote [17] in the text."> &#8617;</a></blockquote><blockquote id="fn_18"><sup>18</sup>. S. Si, D. Tao, and B. Geng, <strong>Bregman divergence-based regularization for transfer subspace learning</strong>, IEEE Trans. Knowledge and Data Engineering, vol. 22, no. 7, pp. 929–942, 2010.<a href="#reffn_18" title="Jump back to footnote [18] in the text."> &#8617;</a></blockquote><blockquote id="fn_19"><sup>19</sup>. A. Gretton, O. Bousquet, A. Smola, and B. Scholkopf, <strong>Measuring statistical dependence with hilbert-schmidt norms</strong>, in ALT, 2005.<a href="#reffn_19" title="Jump back to footnote [19] in the text."> &#8617;</a></blockquote><blockquote id="fn_20"><sup>20</sup>. Z. Ding and Y. Fu, <strong>Robust transfer metric learning for image classification</strong>, IEEE Trans. Image Processing, vol. 26, no. 2, p. 660670, 2017.<a href="#reffn_20" title="Jump back to footnote [20] in the text."> &#8617;</a></blockquote><blockquote id="fn_21"><sup>21</sup>. B. Sun, J. Feng, and K. Saenko, <strong>Return of frustratingly easy domain adaptation</strong>, in AAAI, 2016, pp. 153–171.<a href="#reffn_21" title="Jump back to footnote [21] in the text."> &#8617;</a></blockquote><blockquote id="fn_22"><sup>22</sup>. H. Daume III, <strong>Frustratingly easy domain adaptation</strong>, in arXiv,2009.<a href="#reffn_22" title="Jump back to footnote [22] in the text."> &#8617;</a></blockquote><blockquote id="fn_23"><sup>23</sup>. R. Volpi, P. Morerio, S. Savarese, and V. Murino, <strong>Adversarial feature augmentation for unsupervised domain adaptation</strong>, in CVPR, 2018, pp. 5495–5504.<a href="#reffn_23" title="Jump back to footnote [23] in the text."> &#8617;</a></blockquote><blockquote id="fn_24"><sup>24</sup>. I. H. Jhuo, D. Liu, D. T. Lee, and S. F. Chang, <strong>Robust visual domain adaptation with low-rank reconstruction</strong>, in CVPR, 2012, pp. 2168–2175.<a href="#reffn_24" title="Jump back to footnote [24] in the text."> &#8617;</a></blockquote><blockquote id="fn_25"><sup>25</sup>. L. Zhang, W. Zuo, and D. Zhang, <strong>Lsdt: Latent sparse domain transfer learning for visual adaptation</strong>, IEEE Trans. Image Processing, vol. 25, no. 3, pp. 1177–1191, 2016.<a href="#reffn_25" title="Jump back to footnote [25] in the text."> &#8617;</a></blockquote><blockquote id="fn_26"><sup>26</sup>. S. Shekhar, V. Patel, H. Nguyen, and R. Chellappa, <strong>Generalized domain-adaptive dictionaries</strong>, in CVPR, 2013, pp. 361–368.<a href="#reffn_26" title="Jump back to footnote [26] in the text."> &#8617;</a></blockquote><blockquote id="fn_27"><sup>27</sup>. F. Zhu and L. Shao, <strong>Weakly-supervised cross-domain dictionary learning for visual recognition</strong>, International Journal of Computer Vision, vol. 109, no. 1-2, pp. 42–59, 2014.<a href="#reffn_27" title="Jump back to footnote [27] in the text."> &#8617;</a></blockquote><blockquote id="fn_28"><sup>28</sup>. J. Yang, R. Yan, and A. G. Hauptmann, <strong>Cross-domain video concept detection using adaptive svms</strong>, in ACM MM, 2007, pp. 188–197.<a href="#reffn_28" title="Jump back to footnote [28] in the text."> &#8617;</a></blockquote><blockquote id="fn_29"><sup>29</sup>.  L. Duan, I. Tsang, D. Xu, and S. Maybank, <strong>Domain transfer svm for video concept detection</strong>, in CVPR, 2009<a href="#reffn_29" title="Jump back to footnote [29] in the text."> &#8617;</a></blockquote><blockquote id="fn_30"><sup>30</sup>. M. Long, J. Wang, G. Ding, S. Pan, and P. Yu, <strong>Adaptation regularization: a general framework for transfer learning</strong>, IEEE Trans. Knowledge and Data Engineering, vol. 26, no. 5, p. 10761089, 2014.<a href="#reffn_30" title="Jump back to footnote [30] in the text."> &#8617;</a></blockquote><blockquote id="fn_31"><sup>31</sup>. Y. Cao, M. Long, and J. Wang, <strong>Unsupervised domain adaptation with distribution matching machines</strong>, in AAAI, 2018<a href="#reffn_31" title="Jump back to footnote [31] in the text."> &#8617;</a></blockquote><blockquote id="fn_32"><sup>32</sup>. J. Wang, W. Feng, Y. Chen, H. Yu, M. Huang, and P. S. Yu, <strong>Visual domain adaptation with manifold embedded distribution alignment</strong>, 2018.<a href="#reffn_32" title="Jump back to footnote [32] in the text."> &#8617;</a></blockquote><blockquote id="fn_33"><sup>33</sup>. M. Gonen and A. Margolin, <strong>Kernelized bayesian transfer learning</strong>, in AAAI, 2014, pp. 1831–1839.<a href="#reffn_33" title="Jump back to footnote [33] in the text."> &#8617;</a></blockquote><blockquote id="fn_34"><sup>34</sup>.  J. Yosinski, J. Clune, Y. Bengio, and H. Lipson, <strong>How transferable are features in deep neural networks</strong>, in NIPS, 2014.<a href="#reffn_34" title="Jump back to footnote [34] in the text."> &#8617;</a></blockquote><blockquote id="fn_35"><sup>35</sup>. E. Tzeng, J. Hoffman, N. Zhang, K. Saenko, and T. Darrell, <strong>Deep domain confusion: Maximizing for domain invariance</strong>, arXiv, 2014<a href="#reffn_35" title="Jump back to footnote [35] in the text."> &#8617;</a></blockquote><blockquote id="fn_36"><sup>36</sup>.  M. Long, Y. Cao, J. Wang, and M. I. Jordan, <strong>Learning transferable features with deep adaptation networks</strong>, in ICML, 2015, pp. 97–105.<a href="#reffn_36" title="Jump back to footnote [36] in the text."> &#8617;</a></blockquote><blockquote id="fn_37"><sup>37</sup>. M. Long, H. Zhu, J. Wang, and M. Jordan, <strong>Deep transfer learning with joint adaptation networks</strong>, in ICML, 2017.<a href="#reffn_37" title="Jump back to footnote [37] in the text."> &#8617;</a></blockquote><blockquote id="fn_38"><sup>38</sup>. X. Zhang, F. Yu, S. Wang, and S. Chang, <strong>Deep transfer network: Unsupervised domain adaptation</strong>, in arXiv, 2015.<a href="#reffn_38" title="Jump back to footnote [38] in the text."> &#8617;</a></blockquote><blockquote id="fn_39"><sup>39</sup>. M. Chen, Z. Xu, K. Weinberger, and F. Sha, <strong>Marginalized denoising autoencoders for domain adaptation</strong>, in ICML, 2012<a href="#reffn_39" title="Jump back to footnote [39] in the text."> &#8617;</a></blockquote><blockquote id="fn_40"><sup>40</sup>. Y. Ganin and V. Lempitsky, <strong>Unsupervised domain adaptation by backpropagation</strong>, in arXiv, 2015.<a href="#reffn_40" title="Jump back to footnote [40] in the text."> &#8617;</a></blockquote><blockquote id="fn_41"><sup>41</sup>. H. Ajakan, P. Germain, H. Larochelle, F. Laviolette, and M. Marchand, <strong>Domain-adversarial neural network</strong>, in arXiv, 2015<a href="#reffn_41" title="Jump back to footnote [41] in the text."> &#8617;</a></blockquote><blockquote id="fn_42"><sup>42</sup>. E. Tzeng, J. Hoffman, K. Saenko, and T. Darrell, <strong>Adversarial discriminative domain adaptation</strong>, in CVPR, 2017, pp. 7167–7176<a href="#reffn_42" title="Jump back to footnote [42] in the text."> &#8617;</a></blockquote><blockquote id="fn_43"><sup>43</sup>. M. Long, Z. Cao, J. Wang, and M. I. Jordan, <strong>Conditional adversarial domain adaptation</strong>, in NIPS, 2018.<a href="#reffn_43" title="Jump back to footnote [43] in the text."> &#8617;</a></blockquote><blockquote id="fn_44"><sup>44</sup>. K. Saito, K. Watanabe, Y. Ushiku, and T. Harada, <strong>Maximum classifier discrepancy for unsupervised domain adaptation</strong>, in CVPR, 2018, pp. 3723–3732.<a href="#reffn_44" title="Jump back to footnote [44] in the text."> &#8617;</a></blockquote><blockquote id="fn_45"><sup>45</sup>. J. Hoffman, E. Tzeng, T. Park, and J. Zhu, <strong>Cycada: Cycleconsistent adversarial domain adaptation</strong>, in ICML, 2018.<a href="#reffn_45" title="Jump back to footnote [45] in the text."> &#8617;</a></blockquote><blockquote id="fn_46"><sup>46</sup>. L. Hu, M. Kan, S. Shan, and X. Chen, <strong>Duplex generative adversarial network for unsupervised domain adaptation</strong>, in CVPR, 2018, pp. 1498–1507.<a href="#reffn_46" title="Jump back to footnote [46] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 迁移学习 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迁移学习 </tag>
            
            <tag> 领域自适应 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强化学习实践（二）：Gridworld</title>
      <link href="/posts/gridworld/"/>
      <url>/posts/gridworld/</url>
      
        <content type="html"><![CDATA[<p>《Reinforcement Learning: An Introduction》在第三章中给出了一个简单的例子:<code>Gridworld</code>, 以帮助我们理解<code>finite MDPs</code>, 同时也求解了该问题的<strong>贝尔曼期望方程</strong>和<strong>贝尔曼最优方程</strong>. 本文简要说明如何进行编程求解.</p><a id="more"></a><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>下图用一个矩形网格展示了一个简单finite MDP - <code>Gridworld</code>.<br>网格中的每一格对应于environment的一个state.<br>在每一格, 有四种可能的actions：<code>上/下/左/右</code>, 对应于agent往相应的方向移动一个单元格.<br>使agent离开网格的actions会使得agent留在原来的位置, 但是会有一个值为<code>-1</code>的reward.<br>除了那些使得agent离开<code>state A</code>和<code>state B</code>的action, 其他的actions对应的reward都是<code>0</code>.<br>处在<code>state A</code>时, 所有的actions会有值为<code>+10</code>的reward, 并且agent会移动到<code>state A&#39;</code>.<br>处在<code>state B</code>时, 所有的actions会有值为<code>+5</code>的reward, 并且agent会移动到<code>state B&#39;</code>.</p></blockquote><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g11f0p6x8vj20al05yq2y.jpg" alt="Girdworld示意图" width="40%" height="40%"></p><hr><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><ul><li><strong>状态(State)</strong>: 网格的坐标, 共 $5 \times 5 = 25$ 个状态;</li><li><strong>动作(Action)</strong>: <code>上/下/左/右</code>四种动作;</li><li><strong>策略(Policy)</strong>: $\pi(a | s) = \frac14 \; \text{for} \; \forall s \in S, \text{and} \; \forall \; a \in \{↑,↓,←,→\}$;</li><li><strong>奖励(Reward)</strong>: 如题所述;</li><li><strong>折扣因子(Discount rate)</strong>: $\gamma \in [0, 1]$, 本文采用 $\gamma=0.9$.</li></ul><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>使用贝尔曼期望方程, 求解给定随机策略 $\pi(a | s) = \frac14$ 下的状态值函数.</li><li>使用贝尔曼最优方程, 求解最优状态值函数.</li></ul><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><iframe src="../../src/gridworld.html" scrolling="no" width="100%" height="3950px"></iframe>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 贝尔曼方程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强化学习实践（一）：Tic-Tac-Toe</title>
      <link href="/posts/tic-tac-toe/"/>
      <url>/posts/tic-tac-toe/</url>
      
        <content type="html"><![CDATA[<p>为了对强化学习的基本概念有一个直观的认识,《Reinforcement Learning: An Introduction》第一章给出了一个简单的例子：<code>Tic-Tac-Toe</code>游戏.</p><h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><p>游戏的规则很简单, 两位玩家在 <code>3x3</code> 的棋盘上轮流下棋, 一位打 <code>X</code>, 另一位打 <code>O</code>, 若棋盘的任意一行、任意一列、正反对角线上有三个相同的棋, 则执该棋的玩家获胜. 若棋盘下满仍没有决出胜负, 则平局.</p><a id="more"></a><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0vltwtubvj20bb0b574c.jpg" alt="Tic-Tac-Toe示例" width="25%" height="25%"></p><hr><p>我们尝试使用强化学习的方法来训练一个Agent, 使其能够在该游戏上表现出色(即Agent在任何情况下都不会输, 最多平局).</p><p>由于没有外部经验, 因此我们需要同时训练两个Agent进行上万轮的对弈来寻找最优策略.</p><p><strong>注:下面的代码只给出部分关键实现过程, 完整代码见:<a href="https://github.com/orzyt/reinforcement-learning-an-introduction/blob/master/chapter01/tic_tac_toe.py" target="_blank" rel="noopener">tic_tac_toe.py</a>.</strong> </p><p><strong>版权归 <a href="https://github.com/ShangtongZhang" target="_blank" rel="noopener">@Shangtong Zhang</a> 等人所有, 仅添加中文注释便于理解.</strong></p><hr><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>强化学习一个重要的概念就是——<strong>状态(State)</strong>. </p><p>状态是指Agent在一个特定时刻从环境中所感知的信号. </p><p>在<code>Tic-Tac-Toe</code>游戏中, 状态即为 <code>3*3</code> 棋盘的布局. </p><p>定义一个<code>State类</code>用来表示状态.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''状态初始化</span></span><br><span class="line"><span class="string">        棋盘使用 n * n 的数组进行表示</span></span><br><span class="line"><span class="string">        棋盘中的数字: 1代表先手, -1代表后手下, 0代表该位置无棋子</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 该状态的数组表示</span></span><br><span class="line">        self.data = np.zeros((BOARD_ROWS, BOARD_COLS))</span><br><span class="line">        <span class="comment"># 该状态下的胜利者</span></span><br><span class="line">        self.winner = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 该状态的哈希值表示</span></span><br><span class="line">        self.state_hash = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 该状态是否为终结状态</span></span><br><span class="line">        self.end = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''计算状态的哈希值表示</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        int</span></span><br><span class="line"><span class="string">            状态的哈希值表示</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_end</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断当前状态是否为终结状态.</span></span><br><span class="line"><span class="string">        如果为终结状态, 同时判断胜利者是谁</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        bool</span></span><br><span class="line"><span class="string">            当前状态是否为终结状态</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_state</span><span class="params">(self, i, j, symbol)</span>:</span></span><br><span class="line">        <span class="string">'''计算当前状态的后继状态</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        i : int</span></span><br><span class="line"><span class="string">            下一步动作的行坐标</span></span><br><span class="line"><span class="string">        j : int</span></span><br><span class="line"><span class="string">            下一步动作的列坐标</span></span><br><span class="line"><span class="string">        symbol : int</span></span><br><span class="line"><span class="string">            动作的执行者(1代表先手, -1代表后手)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        State</span></span><br><span class="line"><span class="string">            下一步棋盘的状态</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''打印状态信息</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><p>根据游戏规则我们知道, 每个格子仅有三种状态, 即先手(1), 后手(-1), 空(0), 那么该游戏的状态数上限仅有 $3^9=19683$ 个.</p><p>因此, 我们可以预处理出所有合法的棋盘状态, 供后面强化学习算法使用.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_states = get_all_states()</span><br></pre></td></tr></table></figure><hr><h2 id="AgentPlayer相关"><a href="#AgentPlayer相关" class="headerlink" title="AgentPlayer相关"></a>AgentPlayer相关</h2><p>定义一个<code>AgentPlayer类</code>用来表示强化学习中和环境进行交互的智能体.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgentPlayer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, step_size=<span class="number">0.1</span>, epsilon=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''Agent初始化</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        step_size : float, optional</span></span><br><span class="line"><span class="string">            更新步长</span></span><br><span class="line"><span class="string">        epsilon : float, optional</span></span><br><span class="line"><span class="string">            探索概率</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 值函数</span></span><br><span class="line">        self.value = dict()</span><br><span class="line">        <span class="comment"># 值函数更新步长</span></span><br><span class="line">        self.step_size = step_size</span><br><span class="line">        <span class="comment"># Agent探索概率</span></span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        <span class="comment"># Agent在一轮游戏中经历的所有状态</span></span><br><span class="line">        self.states = []</span><br><span class="line">        <span class="comment"># 记录每个状态是否采取贪心策略</span></span><br><span class="line">        self.greedy = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''重置Agent的状态, 开启新一轮游戏</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="string">'''将当前棋盘状态加到Agent的状态列表</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        state : State</span></span><br><span class="line"><span class="string">            当前棋盘的状态</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_symbol</span><span class="params">(self, symbol)</span>:</span></span><br><span class="line">        <span class="string">'''根据先后手, 初始化Agent的值函数</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        symbol : int</span></span><br><span class="line"><span class="string">            先手还是后手</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''值函数迭代</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">act</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''根据状态采取动作</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        list</span></span><br><span class="line"><span class="string">            采取的动作</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_policy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''保存策略</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_policy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''加载策略</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><p>在AgentPlayer类中, 我们重点关注 <code>set_symbol</code>, <code>backup</code>, <code>act</code> 三个函数.</p><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>Agent每次与环境进行交互的时候, 都会得到一个反馈信号称之为<strong>奖励(Reward)</strong>. </p><p>Agent的目标是<strong>最大化游戏过程中的奖励总和</strong>.</p><p>在 <code>Tic-Tac-Toe</code> 游戏中, 由于只有在游戏结束的时候才知道胜负, 故没有给出每一步显式的奖励, 而是直接评估状态的<strong>值函数(Value Function)</strong>.</p><p>根据我们的先验知识, 可以对不同的状态设置不同的初始值函数.</p><p>对于导致游戏结束的终结状态, 可分为胜利/平局/失败三种情况, 相应的值函数为1.0/0.5/0.0.</p><p>而对于非终结状态, 可以简单地将状态的值函数设为0.5, 代表无法判断胜负.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_symbol</span><span class="params">(self, symbol)</span>:</span></span><br><span class="line">    <span class="string">'''根据先后手, 初始化Agent的值函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    symbol : int</span></span><br><span class="line"><span class="string">        先手还是后手</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    self.symbol = symbol</span><br><span class="line">    <span class="keyword">for</span> state_hash <span class="keyword">in</span> all_states.keys():</span><br><span class="line">        (state, is_end) = all_states[state_hash]</span><br><span class="line">        <span class="keyword">if</span> is_end: <span class="comment"># 终结状态</span></span><br><span class="line">            <span class="keyword">if</span> state.winner == self.symbol: <span class="comment"># 获胜</span></span><br><span class="line">                self.value[state_hash] = <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">elif</span> state.winner == <span class="number">0</span>: <span class="comment"># 平局</span></span><br><span class="line">                self.value[state_hash] = <span class="number">0.5</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 失败</span></span><br><span class="line">                self.value[state_hash] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 非终结状态</span></span><br><span class="line">            self.value[state_hash] = <span class="number">0.5</span></span><br></pre></td></tr></table></figure><hr><h3 id="值函数迭代"><a href="#值函数迭代" class="headerlink" title="值函数迭代"></a>值函数迭代</h3><p>使用<strong>时序差分学习(Temporal-Difference Learning)</strong>方法进行值函数的更新:</p><script type="math/tex; mode=display">V \left( S _ { t } \right) \leftarrow V \left( S _ { t } \right) + \alpha \left[ V \left( S _ { t + 1 } \right) - V \left( S _ { t } \right) \right]</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backup</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''值函数迭代</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#　获取状态的哈希值表示</span></span><br><span class="line">    self.states = [state.hash() <span class="keyword">for</span> state <span class="keyword">in</span> self.states]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逆序遍历所有的状态, 并进行值函数的更新</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(self.states) - <span class="number">1</span>)):</span><br><span class="line">        state = self.states[i]  </span><br><span class="line">        <span class="comment"># TD误差 = V(s_&#123;t + 1&#125;) - V(s_&#123;t&#125;)</span></span><br><span class="line">        td_error = self.greedy[i] * (self.value[self.states[i + <span class="number">1</span>]] - self.value[state])</span><br><span class="line">        <span class="comment"># TD-Learning(时序差分学习)更新公式</span></span><br><span class="line">        self.value[state] += self.step_size * td_error</span><br></pre></td></tr></table></figure><hr><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>采用 $\epsilon$-greedy 的贪心策略选择动作, 即有 $1 - \epsilon$ 的概率选择后继状态值函数最大的动作, 有 $\epsilon$ 概率进行随机选择动作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">act</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''根据状态采取动作</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    list</span></span><br><span class="line"><span class="string">        采取的动作</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取当前状态</span></span><br><span class="line">    state = self.states[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 下一步所有可能的状态</span></span><br><span class="line">    next_states = []</span><br><span class="line">    <span class="comment"># 下一步所有可能的位置</span></span><br><span class="line">    next_positions = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(BOARD_ROWS):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(BOARD_COLS):</span><br><span class="line">            <span class="comment"># 当前棋盘位置上无棋子</span></span><br><span class="line">            <span class="keyword">if</span> state.data[i, j] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 可行的位置</span></span><br><span class="line">                next_positions.append([i, j])</span><br><span class="line">                <span class="comment"># 可行的状态</span></span><br><span class="line">                next_states.append(state.next_state(i, j, self.symbol).hash())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 有epsilon概率采取随机动作</span></span><br><span class="line">    <span class="keyword">if</span> np.random.rand() &lt; self.epsilon:</span><br><span class="line">        action = next_positions[np.random.randint(len(next_positions))]</span><br><span class="line">        action.append(self.symbol)</span><br><span class="line">        self.greedy[<span class="number">-1</span>] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    values = []</span><br><span class="line">    <span class="comment"># 遍历下一步所有可能的状态和位置</span></span><br><span class="line">    <span class="keyword">for</span> state_hash, pos <span class="keyword">in</span> zip(next_states, next_positions):</span><br><span class="line">        <span class="comment"># 获取对应状态的值函数</span></span><br><span class="line">        values.append((self.value[state_hash], pos))</span><br><span class="line">    <span class="comment"># 如果有多个状态的值函数相同,且都是最高的,shuffle则起到在这些状态中随机选择的作用</span></span><br><span class="line">    np.random.shuffle(values)</span><br><span class="line">    <span class="comment"># 按值函数从大到小排序</span></span><br><span class="line">    values.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 选取最优动作</span></span><br><span class="line">    action = values[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    action.append(self.symbol)</span><br><span class="line">    <span class="keyword">return</span> action</span><br></pre></td></tr></table></figure><hr><h2 id="HumanPlayer相关"><a href="#HumanPlayer相关" class="headerlink" title="HumanPlayer相关"></a>HumanPlayer相关</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanPlayer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.symbol = <span class="keyword">None</span></span><br><span class="line">        self.keys = [<span class="string">'q'</span>, <span class="string">'w'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'z'</span>, <span class="string">'x'</span>, <span class="string">'c'</span>]</span><br><span class="line">        self.state = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        self.state = state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_symbol</span><span class="params">(self, symbol)</span>:</span></span><br><span class="line">        self.symbol = symbol</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backup</span><span class="params">(self, _)</span>:</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">act</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.state.print_state()</span><br><span class="line">        key = input(<span class="string">"Input your position:"</span>)</span><br><span class="line">        data = self.keys.index(key)</span><br><span class="line">        i = data // int(BOARD_COLS)</span><br><span class="line">        j = data % BOARD_COLS</span><br><span class="line">        <span class="keyword">return</span> [i, j, self.symbol]</span><br></pre></td></tr></table></figure><hr><h2 id="Agent训练"><a href="#Agent训练" class="headerlink" title="Agent训练"></a>Agent训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(epochs, print_every_n=<span class="number">500</span>)</span>:</span></span><br><span class="line">    <span class="string">'''对Agent进行训练</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    epochs : int</span></span><br><span class="line"><span class="string">        训练轮数</span></span><br><span class="line"><span class="string">    print_every_n : int, optional</span></span><br><span class="line"><span class="string">        每多少轮输出训练信息</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义两个Agent</span></span><br><span class="line">    player1 = AgentPlayer(epsilon=<span class="number">0.01</span>)</span><br><span class="line">    player2 = AgentPlayer(epsilon=<span class="number">0.01</span>)</span><br><span class="line">    <span class="comment"># 定义判决器</span></span><br><span class="line">    game = Game(player1, player2)</span><br><span class="line">    <span class="comment"># 先手赢的次数</span></span><br><span class="line">    player1_win = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 后手赢的次数</span></span><br><span class="line">    player2_win = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, epochs + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 新的一轮游戏</span></span><br><span class="line">        game.reset()</span><br><span class="line">        winner = game.play(print_state=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> winner == <span class="number">1</span>:</span><br><span class="line">            player1_win += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> winner == <span class="number">-1</span>:</span><br><span class="line">            player2_win += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 打印各自的胜率</span></span><br><span class="line">        <span class="keyword">if</span> i % print_every_n == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch %d, player 1 winrate: %.02f, player 2 winrate: %.02f'</span> % (i, player1_win / i, player2_win / i))</span><br><span class="line">        <span class="comment"># 在每轮游戏结束后,对Agent进行学习</span></span><br><span class="line">        player1.backup()</span><br><span class="line">        player2.backup()</span><br><span class="line">    <span class="comment"># 保存训练好的策略</span></span><br><span class="line">    player1.save_policy()</span><br><span class="line">    player2.save_policy()</span><br></pre></td></tr></table></figure><hr><h2 id="Agent对弈"><a href="#Agent对弈" class="headerlink" title="Agent对弈"></a>Agent对弈</h2><p>经过充分的训练后, 两个Agent对弈的胜率应该都为0%. 即任何局面都只能打成平手, 没有一方可以胜过另一方.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compete</span><span class="params">(turns)</span>:</span></span><br><span class="line">    <span class="string">'''将训练好的两个Agent进行对弈</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    turns : int</span></span><br><span class="line"><span class="string">        对弈轮数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对弈的时候不进行动作的探索, 故epsilon设为0.</span></span><br><span class="line">    player1 = AgentPlayer(epsilon=<span class="number">0</span>)</span><br><span class="line">    player2 = AgentPlayer(epsilon=<span class="number">0</span>)</span><br><span class="line">    game = Game(player1, player2)</span><br><span class="line">    player1.load_policy()</span><br><span class="line">    player2.load_policy()</span><br><span class="line">    player1_win = <span class="number">0.0</span></span><br><span class="line">    player2_win = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, turns):</span><br><span class="line">        game.reset()</span><br><span class="line">        winner = game.play()</span><br><span class="line">        <span class="keyword">if</span> winner == <span class="number">1</span>:</span><br><span class="line">            player1_win += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> winner == <span class="number">-1</span>:</span><br><span class="line">            player2_win += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'%d turns, player 1 win %.02f, player 2 win %.02f'</span> % (turns, player1_win / turns, player2_win / turns))</span><br></pre></td></tr></table></figure><hr><h2 id="Human-v-s-Agent"><a href="#Human-v-s-Agent" class="headerlink" title="Human v.s. Agent"></a>Human v.s. Agent</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''人类玩家和Agent进行对弈</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        player1 = HumanPlayer()</span><br><span class="line">        player2 = AgentPlayer(epsilon=<span class="number">0</span>)</span><br><span class="line">        game = Game(player1, player2)</span><br><span class="line">        player2.load_policy()</span><br><span class="line">        winner = game.play()</span><br><span class="line">        <span class="keyword">if</span> winner == player2.symbol:</span><br><span class="line">            print(<span class="string">"失败!"</span>)</span><br><span class="line">        <span class="keyword">elif</span> winner == player1.symbol:</span><br><span class="line">            print(<span class="string">"胜利!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"平局!"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强化学习（三）：动态规划</title>
      <link href="/posts/planning-by-dp/"/>
      <url>/posts/planning-by-dp/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章 <a href="https://orzyt.cn/posts/markov-decision-processes/">强化学习（二）：马尔可夫决策过程</a> 中, 我们介绍用来对强化学习问题进行建模的马尔可夫决策过程(Markov Decision Processes, MDPs). </p><p>由于MDPs的贝尔曼最优方程没有封闭解, 因此一般采用迭代的方法对其进行求解. </p><p>本文将介绍使用<strong>动态规划(Dynamic Programming)</strong>算法来求解MDPs.</p><a id="more"></a><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><p><strong>动态(Dynamic)</strong>: 问题中的时序部分</p></li><li><p><strong>规划(Planning)</strong>: 对问题进行优化</p></li></ul><p>动态规划将问题分解为子问题, 从子问题的解中得到原始问题的解.</p><hr><h3 id="动态规划的性质"><a href="#动态规划的性质" class="headerlink" title="动态规划的性质"></a>动态规划的性质</h3><ul><li><p><strong>最优子结构(Optimal substructure)</strong></p><ul><li>应用最优性原则(Principle of optimality)</li><li>最优解可以从子问题的最优解中得到</li></ul></li><li><p><strong>重叠子问题(Overlapping subproblems)</strong></p><ul><li>相同的子问题出现多次</li><li>问题的解可以被缓存和复用</li></ul></li></ul><p>马尔可夫决策过程满足上面两种性质:</p><blockquote><p><em>贝尔曼方程</em> 给出了问题的递归分解表示, <em>值函数</em> 存储和复用了问题的解.</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a|s) (\mathcal{R}_s^a + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s'))</script></blockquote><hr><h3 id="用动态规划进行Planning"><a href="#用动态规划进行Planning" class="headerlink" title="用动态规划进行Planning"></a>用动态规划进行Planning</h3><p>动态规划假设我们知道MDP的所有知识, 包括状态、行为、转移矩阵、奖励甚至策略等.</p><p>对于<strong>预测(Prediction)</strong>问题: </p><ul><li><p>输入: </p><ul><li>MDP $&lt;\mathcal{S}, \mathcal{A}, \mathcal{P}, \mathcal{R}, \gamma&gt;$ 和 策略 $\pi$</li><li>MRP $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$</li></ul></li><li><p>输出: 值函数 $v_{\pi}$</p></li></ul><p>对于<strong>控制(Control)</strong>问题:</p><ul><li><p>输入:</p><ul><li>MDP $&lt;\mathcal{S}, \mathcal{A}, \mathcal{P}, \mathcal{R}, \gamma&gt;$</li></ul></li><li><p>输出:</p><ul><li>最优值函数 $v_{*}$</li><li>最优策略 $\pi_{*}$</li></ul></li></ul><hr><h2 id="策略评估"><a href="#策略评估" class="headerlink" title="策略评估"></a>策略评估</h2><blockquote><p>问题: 评估一个给定的策略 $\pi$<br>求解: 对贝尔曼期望方程进行迭代, $v_1 \to v_2 \to \dots \to v_{\pi}$</p></blockquote><p>通常使用<strong>同步备份(synchronous backups)</strong>方法:</p><p>对于第 $k+1$ 次迭代, 所有状态 $s$ 在第 $k+1$ 时刻的价值 $v_{k+1}(s)$ 用 $v_k(s’)$ 进行更新, 其中 $s’$ 是 $s$ 的后继状态.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0nb9rn3v4j20ar06eq31.jpg" alt="迭代策略评估" width="30%" height="30%"></p><script type="math/tex; mode=display">\begin{aligned} v _ { k + 1 } ( s ) & = \sum _ { a \in \mathcal { A } } \pi ( a | s ) \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { k } \left( s ^ { \prime } \right) \right) \\\mathbf { v } ^ { k + 1 } & = \mathcal { R } ^ { \pi } + \gamma \mathcal { P } ^ { \pi } \mathbf { v } ^ { k } \end{aligned}</script><hr><p><strong>迭代策略评估算法</strong>:</p><p>迭代策略评估算法用来估计 $V \approx v_{\pi}$.</p><p>这里使用<code>in-place</code>版本, 即只保留一份 $v$ 数组, 没有新旧之分. </p><p>通常来说, 该方法也能收敛到 $v_{\pi}$, 而且收敛速度可能更快.</p><p>终止条件: $\max \limits_ { s \in \mathcal{S} } \left| v _ { k + 1 } ( s ) - v _ { k } ( s ) \right|$ 小于给定的误差 $\Delta$</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0nj071hc6j20km08hq3t.jpg" alt="迭代策略评估伪代码" width="60%" height="60%"></p><hr><p>例子: <strong>Small Gridworld</strong> <a href="https://github.com/orzyt/reinforcement-learning-an-introduction/blob/master/chapter04/grid_world.py" target="_blank" rel="noopener">[代码]</a></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0nbvkvvotj20k00dkdgx.jpg" alt="Small Gridworld" width="50%" height="50%"></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0nc5gkmd8j20e30lkwgd.jpg" alt="Small Gridworld Solution" width="50%" height="50%"></p><hr><h2 id="策略改进"><a href="#策略改进" class="headerlink" title="策略改进"></a>策略改进</h2><p>让我们考虑一个<strong>确定性策略</strong>(即对于一个状态来说, 其采取的动作是确定的, 而不是考虑每个动作的概率) $a = \pi(s)$.</p><blockquote><p>我们可以通过贪心选择来改进策略 $\pi$:</p><script type="math/tex; mode=display">\pi ^ { \prime } ( s ) = \underset { a \in \mathcal { A } } { \operatorname { argmax } } q _ { \pi } ( s , a )</script></blockquote><p>即状态 $s$ 的新策略为令动作值函数 $q_{\pi}(s, a)$ 取得最大值的动作.</p><p>相应地, 动作值函数 $q _ { \pi } \left( s , \pi ^ { \prime } ( s ) \right)$ 得到了改进:</p><script type="math/tex; mode=display">q _ { \pi } \left( s , \pi ^ { \prime } ( s ) \right) = \max _ { a \in \mathcal { A } } q _ { \pi } ( s , a ) \geq q _ { \pi } ( s , \pi ( s ) ) = v _ { \pi } ( s ) \\{\scriptsize 由于是确定性策略, 才会有 v_{\pi}(s) = q_{\pi}(s, \pi(s))}\tag{1}</script><p>注: 确定性策略下的动作值函数 $q_{\pi}(s, a)$ 为:</p><script type="math/tex; mode=display">\begin{aligned} q _ { \pi } ( s , a ) & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v _ { \pi } \left( S _ { t + 1 } \right) | S _ { t } = s , A _ { t } = a \right] \\ & = \sum _ { s ^ { \prime } , r } p \left( s ^ { \prime } , r | s , a \right) \left[ r + \gamma v _ { \pi } \left( s ^ { \prime } \right) \right] \end{aligned}\tag{2}</script><p>从而, 值函数 $v _ { \pi ^ { \prime } } ( s )$ 也得到了改进:</p><script type="math/tex; mode=display">\begin{aligned} v_\pi(s) & \le q_\pi(s,\pi^{'}(s)) {\scriptsize //公式(1)} \\ &={\Bbb E}[R_{t+1} + \gamma v_\pi(S_{t+1})|S_t=s, A_t=\pi^{'}(s)] {\scriptsize //公式(2)} \\&={\Bbb E}_{\pi'}[R_{t+1}+\gamma v_\pi(S_{t+1})|S_t=s]\  {\scriptsize //注意外层是在新策略 \pi^{'} 下求期望} \\   & \le {\Bbb E}_{\pi'}[R_{t+1}+\gamma q_\pi(S_{t+1},\pi'(S_{t+1}))|S_t=s] {\scriptsize //对状态S_{t+1}使用公式(1)} \\  &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma {\Bbb E}_{\pi'}\left[ R_{t+2}+\gamma v_{\pi}\left( S_{t+2}\right) | S_{t+1}, A_{t+1}=\pi^{'}(S_{t+1}) \right] | S_t=s]\\ &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 v_{\pi}\left( S_{t+2} \right)|S_t=s] {\scriptsize //去掉括号内的期望} \\ & \le {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma ^2 q_\pi(S_{t+2},\pi'(S_{t+2}))|S_t=s] {\scriptsize //对状态S_{t+2}使用公式(1)} \\  &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 {\Bbb E}_{\pi'}\left( R_{t+3}+\gamma v_{\pi}\left( S_{t+3} \right) \right)|S_t=s]\\  &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\gamma^3 v_{\pi}\left( S_{t+3} \right)|S_t=s]\\  & \vdots \\& \le {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\gamma^3 R_{t+4} + \dots |S_t=s]\\ &=v_{\pi^{'}}(s) \\ \end{aligned}</script><p>当改进停止时, 有如下等式:</p><script type="math/tex; mode=display">q _ { \pi } \left( s , \pi ^ { \prime } ( s ) \right) = \max _ { a \in \mathcal { A } } q _ { \pi } ( s , a ) = q _ { \pi } ( s , \pi ( s ) ) = v _ { \pi } ( s )\tag{3}</script><p>可以说, 此时公式(3)满足了贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \max _ { a \in \mathcal { A } } q _ { \pi } ( s , a )</script><p>从而, 对所有状态 $s$ 来说, 有$v_{\pi}(s) = v_{*}(s)$, 即策略 $\pi$ 改进到了最优策略.</p><hr><h2 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h2><h3 id="策略迭代-1"><a href="#策略迭代-1" class="headerlink" title="策略迭代"></a>策略迭代</h3><p>给定一个策略 $\pi$, 我们可以首先对策略进行评估, 然后根据值函数 $v_{\pi}$ 进行贪心地改进策略.</p><script type="math/tex; mode=display">\pi _ { 0 } \stackrel { \mathrm { E } } { \longrightarrow } v _ { \pi _ { 0 } } \stackrel { \mathrm { I } } { \longrightarrow } \pi _ { 1 } \stackrel { \mathrm { E } } { \longrightarrow } v _ { \pi _ { 1 } } \stackrel { \mathrm { I } } { \longrightarrow } \pi _ { 2 } \stackrel { \mathrm { E } } { \longrightarrow } \cdots \stackrel { \mathrm { I } } { \longrightarrow } \pi _ { * } \stackrel { \mathrm { E } } { \longrightarrow } v _ { * }</script><p>其中, $\stackrel { \mathrm { E } } { \longrightarrow }$ 表示策略评估, $\stackrel { \mathrm { I } } { \longrightarrow }$ 表示策略改进. </p><ul><li><p><strong>评估(Evaluate):</strong></p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots | S _ { t } = s \right]</script></li><li><p><strong>改进(Improve):</strong></p><script type="math/tex; mode=display">\pi^{'} = \text{greedy}(v_{\pi})</script></li></ul><p>由于每个策略都比前一个策略更优, 同时一个有限状态的马尔可夫决策过程(finite MDP)仅有有限个策略, 因此该过程一定能够在有限次的迭代中收敛到最优策略 $\pi_{*}$ 和最优值函数 $v_{*}$.</p><hr><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0ncddk93hj20ni0cc0uq.jpg" alt="策略迭代" width="50%" height="50%"></p><hr><p><strong>策略迭代算法:</strong></p><p>策略迭代算法分为: <strong>初始化</strong>, <strong>策略评估</strong> 以及 <strong>策略改进</strong> 三部分.</p><p>其中, 策略改进部分的终止条件为: <strong>是否所有状态的策略不再发生变化</strong>.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0njmn8jy5j20kq0e3760.jpg" alt="策略迭代算法" width="60%" height="60%"></p><hr><p>例子: <strong>Jack’s Car Rental</strong> <a href="https://github.com/orzyt/reinforcement-learning-an-introduction/blob/master/chapter04/car_rental.py" target="_blank" rel="noopener">[代码]</a>  (<em>先占个坑 , 等有时间把这个例子详细写下</em>)</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0ncjvapk8j20ke0ebn32.jpg" alt="Jack’s Car Rental" width="50%" height="50%"></p><p>策略迭代求解结果:</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0nclbnxl1j20jw0dgtam.jpg" alt="Jack’s Car Rental Solution" width="50%" height="50%"></p><p>图中纵坐标是位置 $1$ 的汽车数量, 横坐标是位置 $2$ 的汽车数量, 该问题共有 $21 \times 21$ 个状态. </p><p>图中的等高线将状态划分为不同的区域, 区域内的数值代表相应的策略(正数代表从位置 $1$ 移往位置 $2$ 的汽车数量, 负数则往反方向移动).</p><hr><h3 id="策略迭代的扩展"><a href="#策略迭代的扩展" class="headerlink" title="策略迭代的扩展"></a>策略迭代的扩展</h3><h4 id="改良策略迭代"><a href="#改良策略迭代" class="headerlink" title="改良策略迭代"></a>改良策略迭代</h4><p>策略评估并不需要真正的收敛到 $v_{\pi}$. (比如在 <code>Small Gridworld</code>例子中, 迭代 $k=3$次 即可以得到最优策略.)</p><p>为此我们可以引进终止条件, 如:</p><ul><li>值函数的 $\epsilon$ -收敛</li><li>简单地迭代 $k$ 次便停止策略评估</li></ul><p>或者每次迭代(即 $k=1$ )都对策略进行更新改进, 这种情况等价于<strong>值迭代(value iteration)</strong>.</p><hr><h4 id="广义策略迭代"><a href="#广义策略迭代" class="headerlink" title="广义策略迭代"></a>广义策略迭代</h4><p><strong>广义策略迭代</strong>(Generalized Policy iteration，GPI)指代让策略评估(policy-evaluation)和策略改进(policyimprovement)过程进行交互的一般概念, 其不依赖于两个过程的粒度(granularity)和其他细节.</p><p>几乎所有强化学习方法都可以很好地被描述为GPI. 也就是说, 它们都具有可辨识的策略与值函数. 其中, 策略 $\pi$ 通过相应的值函数 $v$ 进行改进, 而值函数 $V$ 总是趋向策略 $\pi$ 的值函数 $v^{\pi}$. 如下图所示,</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0nik26512j206y0a5dfz.jpg" alt="广义策略迭代" width="20%" height="20%"></p><hr><h2 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h2><p>策略迭代的一个缺点是它的每次迭代都涉及策略评估, 这本身就是一个需要对状态集进行多次扫描的耗时迭代计算. </p><p>而在值迭代的过程中, 并没有出现显式的策略, 并且中间过程的值函数可能也不和任何策略对应.</p><hr><h3 id="最优性原则"><a href="#最优性原则" class="headerlink" title="最优性原则"></a>最优性原则</h3><p>一个最优策略可以被分解为两部分:</p><ul><li>当前状态的最优动作 $A_{*}$</li><li>后继状态 $S^{\prime}$ 的最优策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0nk02i8apj20mi06v75b.jpg" alt="最优性原则" width="60%" height="60%"></p><p>该原则的意思是说, 一个策略 $\pi(a|s)$ 在状态 $s$ 取到最优值函数 $v_{\pi}(s) = v_{*}(s)$ <strong>当且仅当</strong> 对于所有从状态 $s$ 出发可到达的状态 $s^{\prime}$, 策略 $\pi$ 也能够在状态 $s^{\prime}$ 取到最优值函数.</p><hr><h3 id="确定性值迭代"><a href="#确定性值迭代" class="headerlink" title="确定性值迭代"></a>确定性值迭代</h3><p>如果我们已经知道子问题的最优解 $v_{*}(s^{\prime})$, 那么状态 $s$ 的最优解可以通过向前看(lookahead)一步得到, 这称为<strong>值迭代(Value Iteration)</strong>:</p><script type="math/tex; mode=display">v_{*}(s) \gets \max \limits_{a \in \mathcal{A}} \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{*}(s') \right)</script><hr><p><strong>值迭代算法:</strong></p><p>值迭代算法和策略迭代算法一样, 是用来估计最优策略 $\pi_{*}$ 的, 它将策略评估和策略改进有效地结合在了一起.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0nkt7xfz0j20kn09k0ts.jpg" alt="值迭代算法" width="60%" height="60%"></p><hr><h2 id="同步动态规划算法总结"><a href="#同步动态规划算法总结" class="headerlink" title="同步动态规划算法总结"></a>同步动态规划算法总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">贝尔曼方程</th><th style="text-align:center">算法</th></tr></thead><tbody><tr><td style="text-align:center">预测(Prediction)</td><td style="text-align:center">贝尔曼期望方程</td><td style="text-align:center">迭代策略评估</td></tr><tr><td style="text-align:center">控制(Control)</td><td style="text-align:center">贝尔曼期望方程 + 贪心策略改进</td><td style="text-align:center">策略迭代</td></tr><tr><td style="text-align:center">控制(Control)</td><td style="text-align:center">贝尔曼最优方程</td><td style="text-align:center">值迭代</td></tr></tbody></table></div><p>对于有 $m$ 个动作和 $n$ 个状态 的MDP来说, 每次迭代的时间复杂度如下:</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">复杂度</th></tr></thead><tbody><tr><td style="text-align:center">$v_{\pi}(s)$ or $v_{*}(s)$</td><td style="text-align:center">$\mathcal{O}(mn^2)$</td></tr><tr><td style="text-align:center">$q_{\pi}(s, a)$ or $q_{*}(s, a)$</td><td style="text-align:center">$\mathcal{O}(m^2n^2)$</td></tr></tbody></table></div><hr><h2 id="动态规划的扩展"><a href="#动态规划的扩展" class="headerlink" title="动态规划的扩展"></a>动态规划的扩展</h2><h3 id="异步动态规划"><a href="#异步动态规划" class="headerlink" title="异步动态规划"></a>异步动态规划</h3><p>同步DP算法的主要缺点是每次迭代都需要对整个状态集进行扫描, 这对于状态数非常多的MDP来说耗费巨大. 而异步DP算法则将所有的状态独立地,以任意顺序进行备份, 并且每个状态的更新次数不一, 这可以显著地减少计算量.</p><p>为了保证算法的正确收敛, 异步动态规划算法必须保证<strong>所有状态都能够持续地被更新</strong>(continue to update the values of all the states), 也就是说在任何时刻任何状态都有可能被更新, 而不能忽略某个状态.</p><p>异步DP算法主要有三种简单的思想:</p><ul><li>就地动态规划(<em>In-place</em> dynamic programming)</li><li>优先扫描(<em>Prioritised sweeping</em>)</li><li>实时动态规划(<em>Real-time</em> dynamic programming)</li></ul><hr><h4 id="就地动态规划"><a href="#就地动态规划" class="headerlink" title="就地动态规划"></a>就地动态规划</h4><p>同步DP保留值函数的两个备份, $v_{new}$ 和 $v_{old}$</p><script type="math/tex; mode=display">{\color{red} {v_{new}(s)}} \gets \max \limits_{a \in \mathcal{A}} \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} {\color{red} {v_{old}(s')}} \right)</script><p>就地值迭代只保留值函数的一个备份.</p><script type="math/tex; mode=display">{\color{red} {v(s)}} \gets \max \limits_{a \in \mathcal{A}} \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} {\color{red} {v(s')}} \right)</script><hr><h4 id="优先扫描"><a href="#优先扫描" class="headerlink" title="优先扫描"></a>优先扫描</h4><p>使用贝尔曼误差的大小来进行状态的选择:</p><script type="math/tex; mode=display">\left| \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v \left( s ^ { \prime } \right) \right) - v ( s ) \right|</script><ul><li><p>仅备份有最大贝尔曼误差的状态</p></li><li><p>在每次备份后, 需要更新受到影响的状态(即备份状态的前驱状态)的贝尔曼误差</p></li><li><p>可以使用优先队列进行实现</p></li></ul><hr><h4 id="实时动态规划"><a href="#实时动态规划" class="headerlink" title="实时动态规划"></a>实时动态规划</h4><ul><li>思想: <strong>只使用和Agent相关的状态</strong></li><li>使用Agent的经验来进行状态的选择</li><li>在每个时间步 $S_t, A_t, R_{t+1}$ 对状态 $S_t$ 进行备份</li></ul><script type="math/tex; mode=display">{\color{red} {v \left( S _ { t } \right)}} \gets \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { {\color{red}{S _ { t }}} } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { {\color{red} {S _ { t }}} s ^ { \prime }}  ^ { a } {\color{red} {v \left( s ^ { \prime } \right)}} \right)</script><hr><h3 id="全宽和采样备份"><a href="#全宽和采样备份" class="headerlink" title="全宽和采样备份"></a>全宽和采样备份</h3><h4 id="全宽备份"><a href="#全宽备份" class="headerlink" title="全宽备份"></a>全宽备份</h4><ul><li><p>DP使用<strong>全宽备份</strong>(<em>full-width</em> backups)</p></li><li><p>对于每次备份(不管同步还是异步)</p><ul><li>每个后继状态和动作都会被考虑进去</li><li>需要知道MDP转移矩阵和奖励函数</li></ul></li><li><p>对于大规模DP问题会遇到维数灾难</p></li><li><p>进行一次备份都太奢侈了</p></li></ul><hr><h4 id="采样备份"><a href="#采样备份" class="headerlink" title="采样备份"></a>采样备份</h4><p><strong>采样备份(Sample Backups)</strong>使用采样的奖励和采样的转移 $&lt; S , A , R , S ^ { \prime } &gt;$ 来替代奖励函数 $\mathcal{R}$ 和 转移矩阵 $\mathcal{P}$. </p><p>采样备份的优点:</p><ul><li><strong>Model-free</strong>: 不需要知道MDP的先验知识</li><li>通过采样<strong>缓解维数灾难</strong></li><li><strong>备份代价成为常量</strong>, 独立于状态数 $n = |\mathcal{S}|$</li></ul><hr><h2 id="压缩映射"><a href="#压缩映射" class="headerlink" title="压缩映射"></a>压缩映射</h2><p>关于上面的种种算法, 我们可能会有如下疑问:</p><ul><li>值迭代是否会收敛到 $v_{*}$ ?</li><li>迭代策略评估是否会收敛到 $v_{\pi}$ ?</li><li>策略迭代是否会收敛到 $v_{*}$ ?</li><li>解唯一吗 ?</li><li>算法收敛速度有多快 ?</li></ul><p>为了解决这些问题, 需要引入压缩映射(contraction mapping)理论.<br>可以参考: <a href="https://zhuanlan.zhihu.com/p/39279611" target="_blank" rel="noopener">如何证明迭代式策略评价、值迭代和策略迭代的收敛性？</a></p><hr><p>(关于压缩映射理论有时间再补充, 先到这里吧…)</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement learning: An introduction (second edition)</a> 第四章</li><li>UCL Course on RL <a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/DP.pdf" target="_blank" rel="noopener">Lecture3: Planning by Dynamic Programming</a></li><li><a href="https://zhuanlan.zhihu.com/p/51393982" target="_blank" rel="noopener">David Silver 增强学习——Lecture 3 动态规划</a></li><li><a href="https://www.cnblogs.com/pinard/p/9463815.html" target="_blank" rel="noopener">强化学习（三）用动态规划（DP）求解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强化学习（二）：马尔可夫决策过程</title>
      <link href="/posts/markov-decision-processes/"/>
      <url>/posts/markov-decision-processes/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章 <a href="https://orzyt.cn/posts/introduction-to-rl">强化学习（一）：强化学习简介</a> 中, 我们介绍了强化学习的一些基本概念.</p><p>本文将介绍用来对强化学习问题进行建模的<strong>马尔可夫决策过程(Markov Decision Processes, MDPs)</strong>.</p><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><h3 id="马尔可夫决策过程简介"><a href="#马尔可夫决策过程简介" class="headerlink" title="马尔可夫决策过程简介"></a>马尔可夫决策过程简介</h3><p><strong>马尔可夫决策过程(Markov Decision Processes, MDPs)</strong>形式上用来描述强化学习中的环境.</p><p>其中,环境是<strong>完全可观测的(fully observable)</strong>,即当前状态可以完全表征过程.</p><p>几乎所有的强化学习问题都能用MDPs来描述：</p><ul><li>最优控制问题可以描述成连续MDPs;</li><li>部分观测环境可以转化成MDPs;</li><li>赌博机问题是只有一个状态的MDPs.</li></ul><hr><h3 id="马尔可夫性质"><a href="#马尔可夫性质" class="headerlink" title="马尔可夫性质"></a>马尔可夫性质</h3><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫性质" width="60%" height="60%"></p><p>马尔科夫性质(Markov Property)表明: <strong>未来只与现在有关,而与过去无关.</strong></p><hr><h3 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h3><p>对于一个马尔可夫状态$S$及其后继状态$S’$,其状态转移概率由下式定义:</p><script type="math/tex; mode=display">\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]</script><p><strong>状态转移矩阵(State Transition Matrix)$\mathcal{P}$</strong>定义了从所有状态$S$转移到所有后继状态$S’$的概率.</p><script type="math/tex; mode=display">\mathcal { P } = \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \dots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n 1 } } & { \cdots } & { \mathcal { P } _ { n n } } \end{array} \right]</script><p>其中,$n$为状态个数,且矩阵的每行和为1.</p><hr><h3 id="马尔可夫过程-1"><a href="#马尔可夫过程-1" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p><strong>马尔可夫过程(Markov Process)</strong>是一个无记忆的随机过程(memoryless random process).</p><p>即,随机状态$S_1, S_2, \dots$序列具有马尔可夫性质.</p><blockquote><p>马尔可夫过程(或马尔可夫链)是一个二元组$&lt;\mathcal{S}, \mathcal{P}&gt;$</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li></ul></blockquote><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l1vm9xkzj20c80act96.jpg" alt="Example: Student Markov Chain" width="50%" height="50%"></p><p>圆圈代表状态, 箭头代表状态之间的转移, 数值代表转移概率.</p><p>状态转移矩阵$\mathcal{P}$如下:</p><script type="math/tex; mode=display">{\mathcal P} =\begin{bmatrix}  & C1 & C2 & C3 &  Pass & Pub & FB & Sleep\\  C1 & &0.5 &  &   & & 0.5 & \\ C2  & & &  0.8 & & & &0.2\\ C3  & & &  & 0.6& 0.4& &\\ Pass  & & &  & & & &1.0\\ Pub  &0.2 & 0.4& 0.4 & & & &\\ FB  &0.1 & &  & & & 0.9 &\\ Sleep  & & &  & & & &1.0 \end{bmatrix}</script><hr><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p><strong>马尔可夫奖励过程(Markov Reward Process, MRP)</strong>是<em>带有奖励的马尔可夫链</em>.</p><blockquote><p>马尔可夫奖励过程是一个四元组&lt;$\mathcal{S}$, $\mathcal{P}$, <font color="red">$\mathcal{R}$</font>, <font color="red">$\mathcal{\gamma}$</font>&gt;</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li><li><font color="red"> $\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right]$ </font></li><li><font color="red"> $\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </font></li></ul></blockquote><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0l2klvnixj20cf0aowf0.jpg" alt="Example: Student MRP" width="50%" height="50%"></p><h3 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h3><blockquote><p><strong>回报(Return)</strong> $G_t$ 是从时间 $t$ 开始的总折扣奖励.</p><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } R _ { t + k + 1 }</script></blockquote><ul><li>折扣因子 $\gamma \in [ 0,1 ]$ 表示未来的奖励在当前的价值. 由于未来的奖励充满不确定性, 因此需要乘上折扣因子;</li><li>$\gamma$ 接近 $0$ 表明更注重当前的奖励(myopic);</li><li>$\gamma$ 接近 $1$ 表明更具有远见(far-sighted).</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function) $v(s)$ 表示一个状态 $s$ 的长期价值(long-term value).</p><blockquote><p>一个马尔可夫奖励过程(MRP)的<strong>状态值函数 $v(s)$</strong>是从状态 $s$ 开始的期望回报.</p><script type="math/tex; mode=display">v ( s ) = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right]</script></blockquote><hr><h3 id="MRPs的贝尔曼方程"><a href="#MRPs的贝尔曼方程" class="headerlink" title="MRPs的贝尔曼方程"></a>MRPs的贝尔曼方程</h3><p>值函数可以被分解为两部分:</p><ul><li>立即奖励 $R_{t+1}$</li><li>后继状态的折扣价值 $\gamma v(S_{t+1})$</li></ul><script type="math/tex; mode=display">\begin{aligned} v ( s ) & = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \gamma ^ { 2 } R _ { t + 3 } + \ldots | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma \left( R _ { t + 2 } + \gamma R _ { t + 3 } + \ldots \right) | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma G _ { t + 1 } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \mathbb { E } \left[ \gamma G _ { t + 1 } | S _ { t } = s \right]\\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \gamma v \left( S _ { t + 1 } \right)\\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v \left( S _ { t + 1 } \right) | S _ { t } = s \right] \end{aligned}\tag{1}\label{eq:mrp-bellman-equation}</script><p>上式表明, $t$ 时刻的状态 $S_t$ 和 $t+1$ 时刻的状态 $S_{t+1}$ 的值函数之间满足递推关系. </p><p>该递推式也称为<strong>贝尔曼方程(Bellman Equation)</strong>.</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0l3fh3jb3j207802zglh.jpg" alt="Bellman Equation for MRPs" width="30%" height="30%"></p><p>如果已知概率转移矩阵 $\mathcal{P}$, 则可将公式\eqref{eq:mrp-bellman-equation}变形为:</p><script type="math/tex; mode=display">v ( s ) = \mathcal { R } _ { s } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } v \left( s ^ { \prime } \right)\tag{2}\label{eq:mrp-bellman-equation-2}</script><p>例子:</p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l3pbm9ixj20c30b5mxp.jpg" alt="Example: Bellman Equation for Student MRP" width="40%" height="40%"></p><p><strong>贝尔曼方程的矩阵形式:</strong></p><p>可将公式\eqref{eq:mrp-bellman-equation-2}改写为矩阵形式:</p><script type="math/tex; mode=display">v = \mathcal { R } + \gamma \mathcal { P } v</script><p>其中, $v$ 为一个列向量, 向量的元素为每个状态的值函数.</p><script type="math/tex; mode=display">\left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right] = \left[ \begin{array} { c } { \mathcal { R } _ { 1 } } \\ { \vdots } \\ { \mathcal { R } _ { n } } \end{array} \right] + \gamma \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \ldots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n1 } } & { \ldots } & { \mathcal { P } _ { n n } } \end{array} \right] \left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right]</script><p>观测贝尔曼方程的矩阵形式, 可知其为线性方程, 可直接求解如下.</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\v & = ( I - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R }\end{aligned}</script><p>计算复杂度为: $\mathcal{O}(n^3)$. 因此, 只适合直接求解小规模的MRP问题.</p><p>对于大规模的MRP问题, 通常采取以下的迭代方法:</p><ul><li>动态规划(Dynamic programming)</li><li>蒙特卡洛评估(Monte-Carlo evaluation)</li><li>时序差分学习(Temporal-Difference learning)</li></ul><hr><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p><strong>马尔可夫决策过程(Markov Decision Process, MDP)</strong>是<em>带有决策的马尔可夫奖励过程</em>.</p><blockquote><p>马尔可夫决策过程是一个五元组&lt;$\mathcal{S}$, <font color="red">$\mathcal{A}$</font>, $\mathcal{P}$, $\mathcal{R}$, $\mathcal{\gamma}$&gt;</p><ul><li>$\mathcal{S}$: 有限的状态集</li><li><font color="red"> $\mathcal{A}$: 有限的动作集</font></li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } ^ {a}= \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } ^ {a} = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </li></ul></blockquote><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0l47drh0vj20g30d93zc.jpg" alt="Example: Student MDP" width="45%" height="45%"></p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote><p><strong>策略(Policy) $\pi$</strong> 是给定状态的动作分布.</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script></blockquote><ul><li>策略完全决定智能体的行为;</li><li>MDP策略值依赖于当前状态(无关历史);</li><li>策略是固定的(与时间无关). $A _ { t } \sim \pi ( \cdot | S _ { t } ) , \forall t &gt; 0$</li></ul><p>给定一个马尔可夫决策过程 $M = &lt;\mathcal{S},\mathcal{A}, \mathcal{P}, \mathcal{R}, \mathcal{\gamma}&gt;$ 和 一个策略 $\pi$, 其可以转化为<em>马尔可夫过程</em>和<em>马尔可夫奖励过程</em>.</p><ul><li><p>状态序列 $S_1, S_2, \dots$ 是马尔科夫决策过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}&gt;$.</p></li><li><p>状态和奖励序列 $S_1, R_2, S_2, \dots$ 是马尔科夫奖励过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$.</p></li></ul><p>其中,</p><script type="math/tex; mode=display">\mathcal{P}_{s,s'}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{P}_{ss'}^{a}</script><script type="math/tex; mode=display">\mathcal{R}_{s}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{R}_{s}^{a}</script><hr><h3 id="值函数-1"><a href="#值函数-1" class="headerlink" title="值函数"></a>值函数</h3><p><strong>值函数(Value Function)</strong>可分为<strong>状态值函数(state-value function)</strong>和<strong>动作值函数(action-value function)</strong>.</p><blockquote><p>MDP的<strong>状态值函数 $v_{\pi}(s)$ </strong>是从状态 $s$ 开始, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ G_t | S_t = s \right]</script><p>MDP的<strong>动作值函数 $q_{\pi}(s, a)$ </strong>是从状态 $s$ 开始, 采取动作 $a$, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ G_t | S_t = s, A_t = a \right]</script></blockquote><hr><h3 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h3><p>状态值函数可以被分解为两部分, <strong>立即奖励 + 后继状态的折扣价值</strong>.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t = s \right]</script><p>动作值函数也可以类似地分解.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma q_{\pi}(S_{t+1}, A_{t+1}) | S_t = s, A_t = a \right]</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0ldl141fkj20bb04xq2x.jpg" width="40%" height="40%"></p><p>上图中, 空心圆圈代表状态, 实心圆圈代表动作.</p><p>在已知策略 $\pi$ 的情况下, 状态值函数 $v_{\pi}(s)$ 可以用动作值函数 $q_{\pi}(s, a)$ 进行表示:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a | s) q_{\pi}(s, a) \tag{3}\label{eq:mdp-state-value-function}</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0lds6jc80j20b004rmx6.jpg" width="40%" height="40%"></p><p>同理, 动作值函数 $q_{\pi}(s, a)$ 也可以用状态值函数 $v_{\pi}(s)$ 进行表示:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s') \tag{4}\label{eq:mdp-action-value-function}</script><hr><p><strong>状态值函数的贝尔曼期望方程:</strong></p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0le5yxgeij20b706hdfx.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-action-value-function}代入公式\eqref{eq:mdp-state-value-function}中, 可得状态值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{\pi}(s')  \right)</script><hr><p><strong>动作值函数的贝尔曼期望方程:</strong></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0le9cf2u7j20bd05wwek.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-state-value-function}代入公式\eqref{eq:mdp-action-value-function}中, 可得动作值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} \sum \limits_{a' \in \mathcal{A}} \pi (a' | s') q_{\pi}(s', a')</script><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lecy0oxgj20h90dcwfj.jpg" alt="状态值函数的贝尔曼期望方程示例" width="55%" height="55%"></p><hr><p><strong>贝尔曼期望方程的矩阵形式:</strong></p><script type="math/tex; mode=display">v_{\pi} = \mathcal{R}^{\pi} + \gamma \mathcal{P}^{\pi} v_{\pi}</script><p>可直接求解:</p><script type="math/tex; mode=display">v_{\pi} = (I - \gamma \mathcal{P}^{\pi})^{-1} \mathcal{R}^{\pi}</script><hr><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><blockquote><p><strong>最优状态值函数(optimal state-value function)</strong> $v_{*}(s)$ 是所有策略中最大的值函数.</p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{\pi}v_{\pi}(s)</script><p><strong>最优动作值函数(optimal action-value function)</strong> $q_{*}(s, a)$ 是所有策略中最大的动作值函数.</p><script type="math/tex; mode=display">q_{*}(s, a) = \max \limits_{\pi}q_{\pi}(s, a)</script></blockquote><ul><li>最优值函数代表了MDP的最好性能.</li><li>当得知最优值函数时, MDP可被认为”已解决”.</li></ul><hr><p>例子: </p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leoxfaylj20h70ee75c.jpg" alt="Student MDP中的最优状态值函数" width="50%" height="50%"></p><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leqk38l4j20hh0eg75i.jpg" alt="Student MDP中的最优动作值函数" width="50%" height="50%"></p><p>注: 根据公式\eqref{eq:mdp-state-value-function}, Pub动作的最优值应为 $q_{*} = +1 + (0.2 \times 6 + 0.4 \times 8 + 0.4 \times 10) = 9.4$.</p><hr><h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><p>首先定义策略之间的偏序关系, 使得策略之间可以进行比较:</p><script type="math/tex; mode=display">\pi \geq \pi ' \quad \text{if} \quad  v_{\pi}(s) \geq v_{\pi '}(s) , \forall s</script><p>对于任意的MDP来说:</p><ul><li>存在一个最优策略 $\pi_{*}$, 使得 $\pi_{*} \geq \pi, \forall \pi$</li><li>所有的最优策略都能取得最优值函数 $v_{\pi_{*}}(s) = v_{*}(s)$</li><li>所有的最优策略都能取得最优动作值函数 $q_{\pi_{*}}(s, a) = q_{*}(s, a)$</li></ul><hr><p><strong>寻找最优策略</strong></p><p>一个最优策略可以通过最大化所有的 $q_{*}(s, a)$ 得到:</p><script type="math/tex; mode=display">\pi_{*} \left( a | s \right) = \left \{ \begin{array}{ll}1 \ {\mathbb {if}} \ a = \operatorname*{argmax} \limits_{a \in \mathcal{A}} \ q_{*} \left( s,a \right) \\              0 \ {\mathbb {otherwise}}              \end{array} \right.</script><ul><li>对于任意的MDP, 总存在确定的最优策略</li><li>如果我们知道 $q_{*}(s, a)$, 则可以立即得到最优策略</li></ul><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lfhg0710j20hn0ehjsl.jpg" alt="Student MDP的最优策略" width="50%" height="50%"></p><p>图中红色弧线表示每个状态的最优决策.</p><hr><h3 id="贝尔曼最优方程"><a href="#贝尔曼最优方程" class="headerlink" title="贝尔曼最优方程"></a>贝尔曼最优方程</h3><p>$v_{*}$可以通过贝尔曼最优方程递归得到:</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0lfkujh38j20b804uaa2.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{a} q_{*}(s, a)\tag{5}\label{eq:state-bellman-optimal-equation}</script><p>与公式\eqref{eq:mdp-state-value-function}的贝尔曼期望方程进行比较, 此时不再取均值, 而是取最大值.</p><hr><p>$q_{*}$与公式\eqref{eq:mdp-action-value-function}类似:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m10t6s7vj208003a747.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)\tag{6}\label{eq:action-bellman-optimal-equation}</script><hr><p><strong>状态值函数的贝尔曼最优方程</strong></p><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0m14a2fenj208m04xq2x.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:action-bellman-optimal-equation}代入公式\eqref{eq:state-bellman-optimal-equation}可得 $v_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><hr><p><strong>动作值函数的贝尔曼最优方程</strong></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0m18irqg7j208804bgll.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:state-bellman-optimal-equation}代入公式\eqref{eq:action-bellman-optimal-equation}可得 $q_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><hr><p>例子:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m1ato6q2j20d70atjs3.jpg" alt="Student MDP贝尔曼最优方程" width="50%" height="50%"></p><hr><h3 id="贝尔曼最优方程的求解"><a href="#贝尔曼最优方程的求解" class="headerlink" title="贝尔曼最优方程的求解"></a>贝尔曼最优方程的求解</h3><p>贝尔曼最优方程<strong>不是线性的</strong>(因为有取$max$操作), 因此没有封闭解(Closed-form solution).</p><p>通常采用迭代求解方法:</p><ul><li>值迭代(Value Iteration)</li><li>策略迭代(Policy Iteration)</li><li>Q-Learning</li><li>Sarsa</li></ul><h2 id="MDP的扩展"><a href="#MDP的扩展" class="headerlink" title="MDP的扩展"></a>MDP的扩展</h2><ul><li>无穷和连续的MDPs</li><li>部分可观测的MDPs</li><li>不折扣, 平均奖励MDPs</li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement learning: An introduction (second edition)</a> 第三章</li><li>UCL Course on RL <a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf" target="_blank" rel="noopener">Lecture2: Markov Decision Processes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 马尔可夫决策过程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强化学习（一）：强化学习简介</title>
      <link href="/posts/introduction-to-rl/"/>
      <url>/posts/introduction-to-rl/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍强化学习中的一些基本概念.</p><a id="more"></a><h2 id="强化学习的特征"><a href="#强化学习的特征" class="headerlink" title="强化学习的特征"></a>强化学习的特征</h2><p>作为机器学习的一个分支，强化学习主要的特征为:</p><ul><li><p>无监督,仅有奖励信号；</p></li><li><p>反馈有延迟,不是瞬时的;</p></li><li><p>时间是重要的(由于是时序数据,不是独立同分布的);</p></li><li><p>Agent的动作会影响后续得到的数据;</p></li></ul><hr><h2 id="强化学习的概念"><a href="#强化学习的概念" class="headerlink" title="强化学习的概念"></a>强化学习的概念</h2><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>奖励(Rewards) $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何.</p><p><strong>Agent的目标</strong>: 最大化累积奖励(maximise cumulative reward).</p><p>强化学习基于<strong>奖励假设(reward hypothesis)</strong>.</p><blockquote><p><strong>奖励假设(Reward Hypothesis)</strong>:<br>所有强化学习任务的目标都可以被描述为最大化期望累积奖励.</p></blockquote><hr><h3 id="序贯决策"><a href="#序贯决策" class="headerlink" title="序贯决策"></a>序贯决策</h3><p><strong>序贯决策(Sequential Decision Making)的目标</strong>: 选择合适的动作最大化将来的累积奖励.</p><ul><li>动作可能会产生长期后果；</li><li>奖励会有延迟性;</li><li>牺牲立即回报可能会获得更多的长期回报.</li></ul><hr><h3 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k2ozf0lzj20aq0bxtb1.jpg" alt="Agent和环境" width="35%" height="35%"></p><p>智能体(Agent)在每个时刻$t$会:</p><ul><li>执行动作(Action)$A_t$;</li><li>接收观测(Observation)$O_t$;</li><li>接收标量奖励(Reward)$R_t$.</li></ul><p>而环境(Environment)则会:</p><ul><li>接收动作(Action)$A_t$;</li><li>产生观测(Observation)$O_{t+1}$;</li><li>产生标量奖励(Reward)$R_{t+1}$.</li></ul><hr><h3 id="历史与状态"><a href="#历史与状态" class="headerlink" title="历史与状态"></a>历史与状态</h3><blockquote><p><strong>历史(History):</strong>由一系列观测,动作和奖励构成.</p></blockquote><script type="math/tex; mode=display">H_t = O_1, R_1, A_1, \dots, A_{t-1}, O_t, R_t</script><p>下一步将发生什么取决于历史:</p><ul><li>智能体选择的action;</li><li>环境选择的observations/rewards.</li></ul><blockquote><p><strong>状态(State)</strong>:用来决定接下来会发生什么的信息.</p></blockquote><p><strong>状态是历史的函数:</strong></p><script type="math/tex; mode=display">S_t = f(H_t)</script><hr><h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3akygqpj20b20cptb5.jpg" alt="环境状态" width="35%" height="35%"></p><p>环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见.</p><p>即使$S_{t}^{e}$可见,也可能包含不相关信息.</p><hr><h4 id="智能体状态"><a href="#智能体状态" class="headerlink" title="智能体状态"></a>智能体状态</h4><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k3e8bw4aj20b00cx419.jpg" alt="智能体状态" width="35%" height="35%"></p><p>智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息.</p><p>可以写成历史的函数: $S_{t}^{a} = f(H_t)$</p><hr><h4 id="信息状态"><a href="#信息状态" class="headerlink" title="信息状态"></a>信息状态</h4><p><strong>信息状态(也称为马尔科夫状态)</strong>: 包含历史中所有有用的信息.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫状态定义" width="60%" height="60%"></p><p>马尔科夫状态表明: <strong>未来只与现在有关,而与过去无关.</strong></p><p>其中,<strong>环境状态$S_t^e$</strong>和<strong>历史$H_t$</strong>具有马尔科夫性质.</p><hr><h4 id="Rat-Example"><a href="#Rat-Example" class="headerlink" title="Rat Example"></a>Rat Example</h4><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k3trc5qxj20ny0doq88.jpg" alt="Rat Example" width="60%" height="60%"></p><ul><li><p>假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击)</p></li><li><p>假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪)</p></li><li><p>假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知)</p></li></ul><hr><h4 id="完全可观测环境"><a href="#完全可观测环境" class="headerlink" title="完全可观测环境"></a>完全可观测环境</h4><p><strong>完全可观测性(Full observability):</strong> 智能体可以直接观测到环境状态,即</p><script type="math/tex; mode=display">O_t = S_t^a = S_t^e</script><ul><li>智能体状态 = 环境状态 = 信息状态</li><li>实际上是马尔科夫决策过程(Markov Decision Process, MDP)</li></ul><hr><h4 id="部分可观测环境"><a href="#部分可观测环境" class="headerlink" title="部分可观测环境"></a>部分可观测环境</h4><p><strong>部分可观测性(Partial observability):</strong> 智能体不能够直接观测到环境.</p><p>如,机器人不能通过摄像头得知自身的绝对位置.</p><ul><li>智能体状态 $\neq$ 环境状态</li><li>部分可观测马尔科夫决策过程(POMDP)</li></ul><p>此时,智能体必须构建其自身的状态表示 $S_t^a$,比如:</p><ul><li>完全的历史: $S_t^a = H_t$;</li><li>环境状态的置信度: $S _ { t } ^ { a } = \left( \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { 1 } \right] , \ldots , \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { n } \right] \right)$;</li><li>循环神经网络: $S_t^a = \sigma \left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\right)$</li></ul><hr><h2 id="智能体的构成"><a href="#智能体的构成" class="headerlink" title="智能体的构成"></a>智能体的构成</h2><p>智能体主要包含以下几种成分:</p><ul><li><strong>策略(Policy)</strong>: 智能体的行为函数;</li><li><strong>值函数(Value Function)</strong>: 每个state或action的好坏;</li><li><strong>模型(Model)</strong>: 智能体对环境的表示.</li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>策略(Policy)是智能体的行为;</li><li>是<strong>状态</strong>到<strong>动作</strong>的映射;</li><li>确定性策略: $a = \pi(s)$;</li><li>随机性策略: $\pi(a|s) = \mathbb{P} \left[ A_{t} = a | S_{t} = s\right]$</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function)是对于未来奖励的预测.</p><ul><li>用于评价状态的好坏;</li><li>因此可以用来选择动作.</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots | S_{t} = s \right]</script><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型(Model)用来预测环境接下来会做什么.</p><ul><li>$\mathcal{P}$: 预测下一个状态.<script type="math/tex; mode=display">\mathcal{P}_{ss'}^{a} = \mathbb{P} \left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\right]</script></li><li>$\mathcal{R}$: 预测下一个(立即)奖励.<script type="math/tex; mode=display">\mathcal{R}_{s}^{a} = \mathbb{E} \left[ R_{t+1} | S_{t} = s, A_{t} = a\right]</script></li></ul><hr><h3 id="Maze-Example"><a href="#Maze-Example" class="headerlink" title="Maze Example"></a>Maze Example</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k4norup9j20mj092dg5.jpg" alt="Maze Example" width="60%" height="60%"></p><hr><p><strong>策略表示:</strong></p><p>箭头表示每个状态的策略 $\pi(s)$.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k4u9pdcdj20f10c5q38.jpg" alt="Maze Example: Policy" width="40%" height="40%"></p><hr><p><strong>值函数表示:</strong></p><p>数值表示每个状态的值 $v_{\pi}(s)$.</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k4w9vn7wj20f60cct8y.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><p><strong>模型表示:</strong></p><p>智能体可能对环境建立内部模型</p><ul><li>网格布局表示转移模型 $\mathcal{P}_{ss’}^{a}$;</li><li>数值表示每个状态的立即奖励 $\mathcal{R}_{s}^{a}$.</li></ul><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k51h023dj20c109kt8o.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><h3 id="智能体的分类"><a href="#智能体的分类" class="headerlink" title="智能体的分类"></a>智能体的分类</h3><p>按智能体的成分分类:</p><ul><li>基于值函数(Value Based)</li><li>基于策略(Policy Based)</li><li>演员-评论家(Actor Critic)</li></ul><p>或者按有无模型分类:</p><ul><li>无模型(Model Free)</li><li>基于模型(Model Based)</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k55tidg0j20f30eaab9.jpg" alt="智能体分类" width="40%" height="40%"></p><hr><h2 id="强化学习的问题"><a href="#强化学习的问题" class="headerlink" title="强化学习的问题"></a>强化学习的问题</h2><h3 id="学习与规划"><a href="#学习与规划" class="headerlink" title="学习与规划"></a>学习与规划</h3><p><strong>强化学习</strong></p><ul><li>环境的初始状态未知;</li><li>智能体与环境进行交互;</li><li>智能体提升其策略.</li></ul><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0k5dprnn4j20p80ejn0q.jpg" alt="学习" width="60%" height="60%"></p><p><strong>规划</strong></p><ul><li>环境的模型已知;</li><li>智能体通过模型进行计算,无须与外部进行交互;</li><li>智能体提升其策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k5eleerwj20ok0df0u3.jpg" alt="规划" width="60%" height="60%"></p><hr><h3 id="探索和利用"><a href="#探索和利用" class="headerlink" title="探索和利用"></a>探索和利用</h3><p>强化学习是一种试错(trial-and-error)学习.</p><p>智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励.</p><ul><li><strong>探索(Exploration):</strong> 从环境中寻找更多信息;</li><li><strong>利用(Exploitation):</strong> 利用已知信息使奖励最大化.</li></ul><p>探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果.</p><hr><h3 id="预测和控制"><a href="#预测和控制" class="headerlink" title="预测和控制"></a>预测和控制</h3><ul><li><strong>预测(Prediction):</strong> 对未来进行评估.</li></ul><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k5ryo676j20nz0ds0tn.jpg" alt="Gridworld Example: Prediction" width="60%" height="60%"></p><hr><ul><li><strong>控制(Control):</strong> 最优化未来的结果.</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k5r6vdmgj20nv0eot9w.jpg" alt="Gridworld Example: Control" width="60%" height="60%"></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement learning: An introduction (second edition)</a> 第一章</li><li>UCL Course on RL <a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf" target="_blank" rel="noopener">Lecture1: Introduction to Reinforcement Learning</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode637 Average of Levels in Binary Tree</title>
      <link href="/posts/leetcode637-average-of-levels-in-binary-tree/"/>
      <url>/posts/leetcode637-average-of-levels-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode654 Maximum Binary Tree</title>
      <link href="/posts/leetcode654-maximum-binary-tree/"/>
      <url>/posts/leetcode654-maximum-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode657 Robot Return to Origin</title>
      <link href="/posts/leetcode657-robot-return-to-origin/"/>
      <url>/posts/leetcode657-robot-return-to-origin/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode661 Image Smoother</title>
      <link href="/posts/leetcode661-image-smoother/"/>
      <url>/posts/leetcode661-image-smoother/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode665 Non-decreasing Array</title>
      <link href="/posts/leetcode665-non-decreasing-array/"/>
      <url>/posts/leetcode665-non-decreasing-array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode617 Merge Two Binary Trees</title>
      <link href="/posts/leetcode617-merge-two-binary-trees/"/>
      <url>/posts/leetcode617-merge-two-binary-trees/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode606 Construct String from Binary Tree</title>
      <link href="/posts/leetcode606-construct-string-from-binary-tree/"/>
      <url>/posts/leetcode606-construct-string-from-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode599 Minimum Index Sum of Two Lists</title>
      <link href="/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
      <url>/posts/leetcode599-minimum-index-sum-of-two-lists/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode38 Count and Say</title>
      <link href="/posts/leetcode38-count-and-say/"/>
      <url>/posts/leetcode38-count-and-say/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度人脸识别综述</title>
      <link href="/posts/deep-face-recognition/"/>
      <url>/posts/deep-face-recognition/</url>
      
        <content type="html"><![CDATA[<p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><a id="more"></a><hr><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1j4up5oj21cb0ik489.jpg" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jnv2szj210109oacr.jpg" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jytblsj20of0kgwhp.jpg" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1kfbt7kj217u0e8dlk.jpg" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k1kr4sx8j215r0k9wlm.jpg" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1l9pm84j20x007ht9n.jpg" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lnsllgj20tr0m1qdq.jpg" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lvxp55j20zt0i4n3g.jpg" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1m4b63ij20fv0ib40x.jpg" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k1mg2yrlj20hk0ca0v4.jpg" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mmsrz1j20n808dwfx.jpg" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k1mtlmpmj20ck04sq3j.jpg" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mz40h8j21640ad0wf.jpg" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="https://ws1.sinaimg.cn/large/8662e3cegy1g0k1n6hmq9j20lo09g0wz.jpg" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018-2019学年研一上学期总结</title>
      <link href="/posts/2018-2019-fall-semester-summary/"/>
      <url>/posts/2018-2019-fall-semester-summary/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈支持向量机的推导</title>
      <link href="/posts/svm/"/>
      <url>/posts/svm/</url>
      
        <content type="html"><![CDATA[<iframe src="../../src/svm.html" scrolling="no" width="100%" height="11100px"></iframe>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 支持向量机 </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode575 Distribute Candies</title>
      <link href="/posts/leetcode575-distribute-candies/"/>
      <url>/posts/leetcode575-distribute-candies/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode566 Reshape the Matrix</title>
      <link href="/posts/leetcode566-reshape-the-matrix/"/>
      <url>/posts/leetcode566-reshape-the-matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode563 Binary Tree Tilt</title>
      <link href="/posts/leetcode563-binary-tree-tilt/"/>
      <url>/posts/leetcode563-binary-tree-tilt/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode561 Array Partition I</title>
      <link href="/posts/leetcode561-array-partition-i/"/>
      <url>/posts/leetcode561-array-partition-i/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode557 Reverse Words in a String III</title>
      <link href="/posts/leetcode557-reverse-words-in-a-string-iii/"/>
      <url>/posts/leetcode557-reverse-words-in-a-string-iii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh本地端口转发的应用</title>
      <link href="/posts/ssh-port-forwarding/"/>
      <url>/posts/ssh-port-forwarding/</url>
      
        <content type="html"><![CDATA[<p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><a id="more"></a><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 端口转发 </tag>
            
            <tag> jupyter notebook </tag>
            
            <tag> tensorboard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简化ssh连接服务器流程</title>
      <link href="/posts/ssh-login/"/>
      <url>/posts/ssh-login/</url>
      
        <content type="html"><![CDATA[<p>登录远程服务器一般采用<code>ssh</code>（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。</p><a id="more"></a><h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h2><p>在本机的终端中执行命令 <code>ssh-keygen</code> ，然后根据提示操作即可在目录（默认为<code>~/.ssh</code>）中生成<code>id_rsa</code>（私钥） 和 <code>id_rsa.pub</code>（公钥）文件。</p><h2 id="添加-ssh-config-文件"><a href="#添加-ssh-config-文件" class="headerlink" title="添加 ssh config 文件"></a>添加 ssh config 文件</h2><p>根据下列内容，修改（或新建）本机中的<code>~/.ssh/config</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host fastlogin                 # 随便取个名字，用于登录</span><br><span class="line">    HostName xxx.xxx.xxx.xxx   # 主机地址 </span><br><span class="line">    User username              # 用户名</span><br><span class="line">    Port 1234                  # 端口号</span><br></pre></td></tr></table></figure><h2 id="向服务器中添加公钥"><a href="#向服务器中添加公钥" class="headerlink" title="向服务器中添加公钥"></a>向服务器中添加公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在本机中执行]：将公钥文件上传到服务器的用户目录</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表</span></span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p>配置好之后，只需执行下列命令即可快速登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastlogin 为之前在ssh config中定义的名字</span></span><br><span class="line">ssh fastlogin</span><br></pre></td></tr></table></figure><h2 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h2><p>现在，如果想要复制本机的文件到服务器上，可以更加简便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本机源地址 fastlogin:服务器目标地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用软件更换国内镜像源</title>
      <link href="/posts/change-mirrors/"/>
      <url>/posts/change-mirrors/</url>
      
        <content type="html"><![CDATA[<p>由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。</p><p>以下基于<code>Ubuntu</code>系统介绍相应的换源方式。</p><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>修改（或新建）文件：<code>~/.pip/pip.conf</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
            <tag> npm </tag>
            
            <tag> anaconda </tag>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode543 Diameter of Binary Tree</title>
      <link href="/posts/leetcode543-diameter-of-binary-tree/"/>
      <url>/posts/leetcode543-diameter-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">      </span><br><span class="line">Output:</span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的直径</p><p>普通树的直径需要<a href="https://www.cnblogs.com/wuyiqi/archive/2012/04/08/2437424.html" target="_blank" rel="noopener">两遍DFS</a>，而二叉树因为结构特殊只需一次DFS即可</p><p>假设二叉树中共有$n$个节点，第$i$个节点的左子树树高为$l_i$，右子树树高为$r_i$，则以第$i$个节点为子树的直径$d_i = l_i + r_i  $，最终整棵二叉树的直径$D = max\{d_i | i=1..n\}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> dep - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归求解左子树深度及右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> l = dfs(u-&gt;left, dep + <span class="number">1</span>), r = dfs(u-&gt;right, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 因为当前深度是相对于root来说的，如果相对于u来说，其左右子树树高需要减去u的深度</span></span><br><span class="line">        <span class="comment">// 即 d = l - dep + r - dep = l + r - 2 * dep</span></span><br><span class="line">        ans = max(ans, l + r - <span class="number">2</span> * dep);</span><br><span class="line">        <span class="keyword">return</span> max(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode541 Reverse String II</title>
      <link href="/posts/leetcode541-reverse-string-ii/"/>
      <url>/posts/leetcode541-reverse-string-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><p><strong>Restrictions:</strong></p><ol><li>The string consists of lower English letters only.</li><li>Length of the given string and k will in the range [1, 10000]</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个字符串和一个整数$k$，需要每$2k$个字符就把前$k$个字符翻转，如果少于$k$个字符就都翻转，如果多等于$k$个而于少于$2k$个字符，就翻转前$k$个而剩下的不变。</p><p>按题意模拟一下即可…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; i += <span class="number">2</span>*k) rev(s, i, min(i + k - <span class="number">1</span>, siz - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode530 Minimum Absolute Difference in BST</title>
      <link href="/posts/leetcode530-minimum-absolute-difference-in-bst/"/>
      <url>/posts/leetcode530-minimum-absolute-difference-in-bst/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary search tree with non-negative values, find the minimum <a href="https://en.wikipedia.org/wiki/Absolute_difference" target="_blank" rel="noopener">absolute difference</a> between values of any two nodes.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求节点为非负整数的二叉搜索树中，任意两个节点绝对差值的最小值。</p><p>根据二叉搜索树的性质，对其进行中序遍历即可得到一个有序（从小到大）的结果。由于结果是有序的，因此只需要考虑相邻两个元素之间的差值来获得最小值。</p><p>比如对如下的二叉搜索树进行中序遍历，得到 <code>[3, 5, 7, 8, 10]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> /   \</span><br><span class="line">3     8</span><br><span class="line">     / \</span><br><span class="line">    7  10</span><br></pre></td></tr></table></figure><p>然后答案即为相邻元素的最小差值，ans = min {<code>5-3</code>, <code>7-5</code>, <code>8-7</code>, <code>10-8</code>} = 1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans, pre;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        ans = min(ans, root-&gt;val - pre);</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = INT_MAX; </span><br><span class="line">        pre = <span class="number">-0x3f3f3f3f</span>; <span class="comment">// 记录中序遍历时当前节点的前驱</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> BST </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode155 Min Stack</title>
      <link href="/posts/leetcode155-min-stack/"/>
      <url>/posts/leetcode155-min-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>模拟一个栈，在<strong>常数时间</strong>内支持<code>进栈push</code>、<code>出栈pop</code>、<code>输出栈顶元素top</code>、<code>输出栈内最小元素getMin</code>四种操作</p><p>我们知道，普通的栈对于前三种操作已经是常数时间了，但是如何实现常数时间内找到栈内最小元素呢？</p><p>可能一开始会想，不是可以$\mathcal{O}(1)$维护一个栈内最小元素的下标吗？<code>getMin</code>的时候直接根据下标输出不就好了</p><p>emm…是这样的没错。但是，一旦最小元素出栈后，我们就得找出栈内第二小元素来更新下标 </p><p>这个该怎么处理呢，肯定不能把栈遍历一遍啊（时间复杂度不满足要求…</p><hr><p>其实，只要维护一个<strong>单调栈</strong>即可（非严格单调递减），单调栈的栈顶就是<strong>原栈中最小的元素</strong></p><p>其中stack A为原栈，stack B为辅助栈，# 表示栈底方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">stack A: # | 10 |               // 元素10进栈</span><br><span class="line">stack B: # | 10 |               // 当前最小元素为10</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 |          // 元素12进栈</span><br><span class="line">stack B: # | 10 |               // 由于维护的是单调递减栈，当前最小元素仍然为10</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 | 9 |      // 元素9进栈</span><br><span class="line">stack B: # | 10 | 9 |           // 满足单调栈，当前最小元素更新为9</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 | 9 | 14 | // 元素14进栈</span><br><span class="line">stack B: # | 10 | 9 |           // 不满足单调栈，当前最小元素仍为9</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 | 9 |      // 元素14出栈</span><br><span class="line">stack B: # | 10 | 9 |           // 不影响辅助栈，当前最小元素仍为9</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 |          // 元素9出栈</span><br><span class="line">stack B: # | 10 |               // 辅助栈栈顶的9同时出栈，当前最小元素更新为10</span><br><span class="line"></span><br><span class="line">stack A: # | 10 |               // 元素12出栈</span><br><span class="line">stack B: # | 10 |               // 不影响辅助栈，当前最小元素仍为10</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 原栈进栈的同时，看满不满足辅助栈的单调性质</span></span><br><span class="line">        <span class="keyword">if</span> (b.empty() || x &lt;= getMin()) b.push(x);</span><br><span class="line">        a.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原栈出栈的同时，看影不影响辅助栈的栈顶</span></span><br><span class="line">        <span class="keyword">if</span> (a.top() == getMin()) b.pop();</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出原栈的栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> a.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出辅助栈栈顶元素，即为原栈中的最小元素</span></span><br><span class="line">        <span class="keyword">return</span> b.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode Algorithms&#39; Solutions</title>
      <link href="/posts/leetcode-algorithms-solutions/"/>
      <url>/posts/leetcode-algorithms-solutions/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“ <strong>Talk is cheap, show me the code!</strong> ”<br>— <em>Linus Torvalds</em></p></blockquote><ul><li>如果题解中有谬误或疑问的地方，欢迎大家留言交流！<a id="more"></a> </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>Title</th><th style="text-align:center">Acceptance</th><th style="text-align:center">Difficulty</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><a href="/posts/leetcode1-two-sum">Two Sum</a></td><td style="text-align:center">40.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">2</td><td><a href="/posts/leetcode2-add-two-numbers">Add Two Numbers</a></td><td style="text-align:center">30.4%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">7</td><td><a href="/posts/leetcode7-reverse-integer">Reverse Integer</a></td><td style="text-align:center">25.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">8</td><td><a href="/posts/leetcode8-string-to-integer-atoi">String to Integer (atoi)</a></td><td style="text-align:center">14.4%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">9</td><td><a href="/posts/leetcode9-palindrome-number">Palindrome Number</a></td><td style="text-align:center">41.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">13</td><td><a href="/posts/leetcode13-roman-to-integer">Roman to Integer</a></td><td style="text-align:center">51.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">20</td><td><a href="/posts/leetcode20-valid-parentheses">Valid Parentheses</a></td><td style="text-align:center">35.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">21</td><td><a href="/posts/leetcode21-merge-two-sorted-lists">Merge Two Sorted Lists</a></td><td style="text-align:center">45.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">27</td><td><a href="/posts/leetcode27-remove-element">Remove Element</a></td><td style="text-align:center">43.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">28</td><td><a href="/posts/leetcode28-implement-strstr">Implement strStr()</a></td><td style="text-align:center">31.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">35</td><td><a href="/posts/leetcode35-search-insert-position">Search Insert Position</a></td><td style="text-align:center">40.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">38</td><td><a href="/posts/leetcode38-count-and-say">Count and Say</a></td><td style="text-align:center">39.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">50</td><td><a href="/posts/leetcode50-powx-n">Pow(x, n)</a></td><td style="text-align:center">27.4%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">53</td><td><a href="/posts/leetcode53-maximum-subarray">Maximum Subarray</a></td><td style="text-align:center">42.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">69</td><td><a href="/posts/leetcode69-sqrtx">Sqrt(x)</a></td><td style="text-align:center">30.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">70</td><td><a href="/posts/leetcode70-climbing-stairs">Climbing Stairs</a></td><td style="text-align:center">43.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">83</td><td><a href="/posts/leetcode83-remove-duplicates-from-sorted-list">Remove Duplicates from Sorted List</a></td><td style="text-align:center">41.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">84</td><td><a href="/posts/leetcode84-largest-rectangle-in-histogram">Largest Rectangle in Histogram</a></td><td style="text-align:center">30.0%</td><td style="text-align:center"><span class="label label-danger round"><p style="display: none;">3</p>Hard</span></td></tr><tr><td style="text-align:center">100</td><td><a href="/posts/leetcode100-same-tree">Same Tree</a></td><td style="text-align:center">49.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">101</td><td><a href="/posts/leetcode101-symmetric-tree">Symmetric Tree</a></td><td style="text-align:center">42.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">102</td><td><a href="/posts/leetcode102-binary-tree-level-order-traversal">Binary Tree Level Order Traversal</a></td><td style="text-align:center">46.6%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">104</td><td><a href="/posts/leetcode104-maximum-depth-of-binary-tree">Maximum Depth of Binary Tree</a></td><td style="text-align:center">58.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">107</td><td><a href="/posts/leetcode107-binary-tree-level-order-traversal-ii">Binary Tree Level Order Traversal II</a></td><td style="text-align:center">45.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">108</td><td><a href="/posts/leetcode108-convert-sorted-array-to-binary-search-tree">Convert Sorted Array to Binary Search Tree</a></td><td style="text-align:center">48.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">112</td><td><a href="/posts/leetcode112-path-sum">Path Sum</a></td><td style="text-align:center">36.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">118</td><td><a href="/posts/leetcode118-pascals-triangle">Pascal’s Triangle</a></td><td style="text-align:center">44.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">119</td><td><a href="/posts/leetcode119-pascals-triangle-ii">Pascal’s Triangle II</a></td><td style="text-align:center">41.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">121</td><td><a href="/posts/leetcode121-best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</a></td><td style="text-align:center">45.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">122</td><td><a href="/posts/leetcode122-best-time-to-buy-and-sell-stock-ii">Best Time to Buy and Sell Stock II</a></td><td style="text-align:center">50.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">125</td><td><a href="/posts/leetcode125-valid-palindrome">Valid Palindrome</a></td><td style="text-align:center">29.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">136</td><td><a href="/posts/leetcode136-single-number">Single Number</a></td><td style="text-align:center">58.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">153</td><td><a href="/posts/leetcode153-find-minimum-in-rotated-sorted-array">Find Minimum in Rotated Sorted Array</a></td><td style="text-align:center">42.3%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">154</td><td><a href="/posts/leetcode154-find-minimum-in-rotated-sorted-array-ii">Find Minimum in Rotated Sorted Array II</a></td><td style="text-align:center">38.8%</td><td style="text-align:center"><span class="label label-danger round"><p style="display: none;">3</p>Hard</span></td></tr><tr><td style="text-align:center">155</td><td><a href="/posts/leetcode155-min-stack">Min Stack</a></td><td style="text-align:center">35.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">167</td><td><a href="/posts/leetcode167-two-sum-ii-input-array-is-sorted">Two Sum II - Input array is sorted</a></td><td style="text-align:center">48.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">168</td><td><a href="/posts/leetcode168-excel-sheet-column-title">Excel Sheet Column Title</a></td><td style="text-align:center">28.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">169</td><td><a href="/posts/leetcode169-majority-element">Majority Element</a></td><td style="text-align:center">51.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">171</td><td><a href="/posts/leetcode171-excel-sheet-column-number">Excel Sheet Column Number</a></td><td style="text-align:center">50.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">172</td><td><a href="/posts/leetcode172-factorial-trailing-zeroes">Factorial Trailing Zeroes</a></td><td style="text-align:center">37.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">189</td><td><a href="/posts/leetcode189-rotate-array">Rotate Array</a></td><td style="text-align:center">28.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">190</td><td><a href="/posts/leetcode190-reverse-bits">Reverse Bits</a></td><td style="text-align:center">29.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">191</td><td><a href="/posts/leetcode191-number-of-1-bits">Number of 1 Bits</a></td><td style="text-align:center">41.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">202</td><td><a href="/posts/leetcode202-happy-number">Happy Number</a></td><td style="text-align:center">44.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">204</td><td><a href="/posts/leetcode204-count-primes">Count Primes</a></td><td style="text-align:center">28.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">206</td><td><a href="/posts/leetcode206-reverse-linked-list">Reverse Linked List</a></td><td style="text-align:center">52.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">217</td><td><a href="/posts/leetcode217-contains-duplicate">Contains Duplicate</a></td><td style="text-align:center">50.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">226</td><td><a href="/posts/leetcode226-invert-binary-tree">Invert Binary Tree</a></td><td style="text-align:center">56.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">231</td><td><a href="/posts/leetcode231-power-of-two">Power of Two</a></td><td style="text-align:center">41.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">237</td><td><a href="/posts/leetcode237-delete-node-in-a-linked-list">Delete Node in a Linked List</a></td><td style="text-align:center">51.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">242</td><td><a href="/posts/leetcode242-valid-anagram">Valid Anagram</a></td><td style="text-align:center">50.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">258</td><td><a href="/posts/leetcode258-add-digits">Add Digits</a></td><td style="text-align:center">53.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">263</td><td><a href="/posts/leetcode263-ugly-number">Ugly Number</a></td><td style="text-align:center">40.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">264</td><td><a href="/posts/leetcode264-ugly-number-ii">Ugly Number II</a></td><td style="text-align:center">35.4%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">268</td><td><a href="/posts/leetcode268-missing-number">Missing Number</a></td><td style="text-align:center">47.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">278</td><td><a href="/posts/leetcode278-first-bad-version">First Bad Version</a></td><td style="text-align:center">28.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">283</td><td><a href="/posts/leetcode283-move-zeroes">Move Zeroes</a></td><td style="text-align:center">53.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">292</td><td><a href="/posts/leetcode292-nim-game">Nim Game</a></td><td style="text-align:center">55.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">303</td><td><a href="/posts/leetcode303-range-sum-query-immutable">Range Sum Query - Immutable</a></td><td style="text-align:center">36.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">307</td><td><a href="/posts/leetcode307-range-sum-query-mutable">Range Sum Query - Mutable</a></td><td style="text-align:center">27.1%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">326</td><td><a href="/posts/leetcode326-power-of-three">Power of Three</a></td><td style="text-align:center">41.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">338</td><td><a href="/posts/leetcode338-counting-bits">Counting Bits</a></td><td style="text-align:center">63.8%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">342</td><td><a href="/posts/leetcode342-power-of-four">Power of Four</a></td><td style="text-align:center">39.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">344</td><td><a href="/posts/leetcode344-reverse-string">Reverse String</a></td><td style="text-align:center">62.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">345</td><td><a href="/posts/leetcode345-reverse-vowels-of-a-string">Reverse Vowels of a String</a></td><td style="text-align:center">40.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">349</td><td><a href="/posts/leetcode349-intersection-of-two-arrays">Intersection of Two Arrays</a></td><td style="text-align:center">52.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">350</td><td><a href="/posts/leetcode350-intersection-of-two-arrays-ii">Intersection of Two Arrays II</a></td><td style="text-align:center">46.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">367</td><td><a href="/posts/leetcode367-valid-perfect-square">Valid Perfect Square</a></td><td style="text-align:center">39.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">371</td><td><a href="/posts/leetcode371-sum-of-two-integers">Sum of Two Integers</a></td><td style="text-align:center">51.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">383</td><td><a href="/posts/leetcode383-ransom-note">Ransom Note</a></td><td style="text-align:center">49.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">387</td><td><a href="/posts/leetcode387-first-unique-character-in-a-string">First Unique Character in a String</a></td><td style="text-align:center">48.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">389</td><td><a href="/posts/leetcode389-find-the-difference">Find the Difference</a></td><td style="text-align:center">52.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">401</td><td><a href="/posts/leetcode401-binary-watch">Binary Watch</a></td><td style="text-align:center">45.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">404</td><td><a href="/posts/leetcode404-sum-of-left-leaves">Sum of Left Leaves</a></td><td style="text-align:center">48.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">405</td><td><a href="/posts/leetcode405-convert-a-number-to-hexadecimal">Convert a Number to Hexadecimal</a></td><td style="text-align:center">41.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">409</td><td><a href="/posts/leetcode409-longest-palindrome">Longest Palindrome</a></td><td style="text-align:center">47.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">412</td><td><a href="/posts/leetcode412-fizz-buzz">Fizz Buzz</a></td><td style="text-align:center">58.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">413</td><td><a href="/posts/leetcode413-arithmetic-slices">Arithmetic Slices</a></td><td style="text-align:center">55.1%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">414</td><td><a href="/posts/leetcode414-third-maximum-number">Third Maximum Number</a></td><td style="text-align:center">28.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">415</td><td><a href="/posts/leetcode415-add-strings">Add Strings</a></td><td style="text-align:center">42.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">419</td><td><a href="/posts/leetcode419-battleships-in-a-board">Battleships in a Board</a></td><td style="text-align:center">65.0%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">437</td><td><a href="/posts/leetcode437-path-sum-iii">Path Sum III</a></td><td style="text-align:center">41.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">442</td><td><a href="/posts/leetcode442-find-all-duplicates-in-an-array">Find All Duplicates in an Array</a></td><td style="text-align:center">59.6%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">447</td><td><a href="/posts/leetcode447-number-of-boomerangs">Number of Boomerangs</a></td><td style="text-align:center">48.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">448</td><td><a href="/posts/leetcode448-find-all-numbers-disappeared-in-an-array">Find All Numbers Disappeared in an Array</a></td><td style="text-align:center">52.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">451</td><td><a href="/posts/leetcode451-sort-characters-by-frequency">Sort Characters By Frequency</a></td><td style="text-align:center">54.6%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">453</td><td><a href="/posts/leetcode453-minimum-moves-to-equal-array-elements">Minimum Moves to Equal Array Elements</a></td><td style="text-align:center">48.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">455</td><td><a href="/posts/leetcode455-assign-cookies">Assign Cookies</a></td><td style="text-align:center">48.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">459</td><td><a href="/posts/leetcode459-repeated-substring-pattern">Repeated Substring Pattern</a></td><td style="text-align:center">39.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">461</td><td><a href="/posts/leetcode461-hamming-distance">Hamming Distance</a></td><td style="text-align:center">69.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">463</td><td><a href="/posts/leetcode463-island-perimeter">Island Perimeter</a></td><td style="text-align:center">60.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">476</td><td><a href="/posts/leetcode476-number-complement">Number Complement</a></td><td style="text-align:center">62.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">479</td><td><a href="/posts/leetcode479-largest-palindrome-product">Largest Palindrome Product</a></td><td style="text-align:center">27.0%</td><td style="text-align:center"><span class="label label-danger round"><p style="display: none;">3</p>Hard</span></td></tr><tr><td style="text-align:center">485</td><td><a href="/posts/leetcode485-max-consecutive-ones">Max Consecutive Ones</a></td><td style="text-align:center">54.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">492</td><td><a href="/posts/leetcode492-construct-the-rectangle">Construct the Rectangle</a></td><td style="text-align:center">48.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">496</td><td><a href="/posts/leetcode496-next-greater-element-i">Next Greater Element I</a></td><td style="text-align:center">58.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">500</td><td><a href="/posts/leetcode500-keyboard-row">Keyboard Row</a></td><td style="text-align:center">61.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">501</td><td><a href="/posts/leetcode501-find-mode-in-binary-search-tree">Find Mode in Binary Search Tree</a></td><td style="text-align:center">38.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">504</td><td><a href="/posts/leetcode504-base-7">Base 7</a></td><td style="text-align:center">44.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">506</td><td><a href="/posts/leetcode506-relative-ranks">Relative Ranks</a></td><td style="text-align:center">47.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">513</td><td><a href="/posts/leetcode513-find-bottom-left-tree-value">Find Bottom Left Tree Value</a></td><td style="text-align:center">57.8%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">520</td><td><a href="/posts/leetcode520-detect-capital">Detect Capital</a></td><td style="text-align:center">52.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">530</td><td><a href="/posts/leetcode530-minimum-absolute-difference-in-bst">Minimum Absolute Difference in BST</a></td><td style="text-align:center">49.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">541</td><td><a href="/posts/leetcode541-reverse-string-ii">Reverse String II</a></td><td style="text-align:center">44.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">543</td><td><a href="/posts/leetcode543-diameter-of-binary-tree">Diameter of Binary Tree</a></td><td style="text-align:center">46.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">557</td><td><a href="/posts/leetcode557-reverse-words-in-a-string-iii">Reverse Words in a String III</a></td><td style="text-align:center">62.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">561</td><td><a href="/posts/leetcode561-array-partition-i">Array Partition I</a></td><td style="text-align:center">68.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">563</td><td><a href="/posts/leetcode563-binary-tree-tilt">Binary Tree Tilt</a></td><td style="text-align:center">46.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">566</td><td><a href="/posts/leetcode566-reshape-the-matrix">Reshape the Matrix</a></td><td style="text-align:center">58.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">575</td><td><a href="/posts/leetcode575-distribute-candies">Distribute Candies</a></td><td style="text-align:center">59.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">599</td><td><a href="/posts/leetcode599-minimum-index-sum-of-two-lists">Minimum Index Sum of Two Lists</a></td><td style="text-align:center">47.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">606</td><td><a href="/posts/leetcode606-construct-string-from-binary-tree">Construct String from Binary Tree</a></td><td style="text-align:center">50.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">617</td><td><a href="/posts/leetcode617-merge-two-binary-trees">Merge Two Binary Trees</a></td><td style="text-align:center">68.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">637</td><td><a href="/posts/leetcode637-average-of-levels-in-binary-tree">Average of Levels in Binary Tree</a></td><td style="text-align:center">57.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">654</td><td><a href="/posts/leetcode654-maximum-binary-tree">Maximum Binary Tree</a></td><td style="text-align:center">71.7%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">657</td><td><a href="/posts/leetcode657-robot-return-to-origin">Robot Return to Origin</a></td><td style="text-align:center">70.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">661</td><td><a href="/posts/leetcode661-image-smoother">Image Smoother</a></td><td style="text-align:center">47.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">665</td><td><a href="/posts/leetcode665-non-decreasing-array">Non-decreasing Array</a></td><td style="text-align:center">19.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">669</td><td><a href="/posts/leetcode669-trim-a-binary-search-tree">Trim a Binary Search Tree</a></td><td style="text-align:center">59.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">671</td><td><a href="/posts/leetcode671-second-minimum-node-in-a-binary-tree">Second Minimum Node In a Binary Tree</a></td><td style="text-align:center">43.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条件生成对抗网络</title>
      <link href="/posts/conditional-gan/"/>
      <url>/posts/conditional-gan/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在原始的生成对抗网络论文中，作者指出了一个可能的拓展:</p><blockquote><p>A conditional generative model $p(x|c)$ can be obtained by adding $c$ as input to both $G$ and $D$</p></blockquote><p>于是同年11月，Mirza等人便提出了<a href="https://arxiv.org/abs/1411.1784" target="_blank" rel="noopener">Conditional Generative Adversarial Networks</a>，这是一种带条件约束的生成模型。</p><a id="more"></a><p>它在生成器 $G$ 和 判别器 $D$ 中均引入了条件变量 $y$，这里 $y$ 可以是任何的辅助信息（比如说，类别标签、其它模态的数据等等）。使用这个额外的条件变量，对生成器数据的生成具有指导作用。因此，该项工作可以看成是把无监督的GAN变成有监督模型的一种改进。</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p><img src="https://tuchuang001.com/images/2017/12/27/cgan.png" alt="Conditional GANs的基本框架" width="60%" height="60%"></p><p><code>Conditional GANs</code>的基本框架非常地简单，只需在原始GAN的生成器和判别器的输入中，加入额外的条件信息即可。</p><p>显然地，目标函数改为：</p><script type="math/tex; mode=display">\mathop{\min}_{G}\mathop{\max}_{D}V(D,G)=\mathbb{E}_{\boldsymbol{x}\sim p_{\text{data}}}\left[\log D(\boldsymbol{x}|\boldsymbol{y})\right]+\mathbb{E}_{\boldsymbol{z}\sim p_z(\boldsymbol{z})}\left[\log(1-D(G(\boldsymbol{z}|\boldsymbol{y})|\boldsymbol{y}))\right]</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在论文中，作者做了两个实验，一个是单模态的<code>MNIST</code>手写数字生成，另一个是基于多模态的图像自动标注。</p><p><img src="https://tuchuang001.com/images/2017/12/27/mnist.png" alt="mnist手写数字生成(论文原图)" width="70%" height="70%"></p><p>在<code>MNIST</code>数据集的实验中，生成器 $G$ 的输入分为两部分：</p><ul><li>噪声 $z$：<code>100维</code> 服从均匀分布的向量</li><li>条件 $y$：类别标签的<code>one hot编码</code></li></ul><p>然后将噪声 $z$ 和 标签 $y$ 分别映射到隐层(<strong>200</strong>和<strong>1000units</strong>)，在映射到第二层前，连接所有<strong>1200units</strong>。最终，用一个<code>sigmoid</code>层输出<strong>784</strong>维(<strong>28*28</strong>)的单通道图像。</p><p>判别器 $D$ 把输入图像 $x$ 映射到一个有<strong>240units</strong>和<strong>5pieces</strong>的<code>maxout layer</code>，把标签 $y$ 映射到有<strong>50units</strong>和<strong>5pieces</strong>的<code>maxout layer</code>。同时，把所有隐层连接成为一个有<strong>240units</strong>和<strong>4pieces</strong>的<code>maxout layer</code>。最后送入<code>sigmoid</code>层，该层的输出即为在条件 $y$ 下，输入图像 $x$ 为真实样本的概率。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Github地址：<a href="https://github.com/orzyt/Generative-Adversarial-Nets/tree/master/conditional-gan" target="_blank" rel="noopener">(orzyt/Generative-Adversarial-Nets/conditional-gan)</a></p><p>具体实现细节与论文有所不同，网络架构使用的是<a href="https://arxiv.org/abs/1511.06434" target="_blank" rel="noopener">DCGAN</a>，效果会比论文中的好（毕竟DCGAN是在CGAN之后才提出的…</p><p>让我们看下代码跑出来的效果</p><p><img src="https://tuchuang001.com/images/2017/12/27/mnist.gif" alt="mnist手写数字生成(实测效果)" width="60%" height="60%"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cgan </tag>
            
            <tag> conditional gan </tag>
            
            <tag> 条件生成对抗网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生成对抗网络</title>
      <link href="/posts/generative-adversarial-nets/"/>
      <url>/posts/generative-adversarial-nets/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>生成对抗网络</strong>（Generative Adversarial Nets, GANs）是由 Ian Goodfellow 等人于2014年6月提出的一种生成模型，至今仍是非常热门的研究方向。深度学习领域泰斗级人物 Yann LeCun 曾如此评价道：<em>“GANs and the variations that are now being proposed is the most interesting idea in the last 10 years in ML, in my opinion.”</em>，从中可见GAN的强大之处！</p><a id="more"></a><hr><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>生成对抗网络的主要框架基于博弈论中的<a href="https://en.wikipedia.org/wiki/Zero-sum_game" target="_blank" rel="noopener">二人零和博弈游戏</a>（zero-sum game）</p><p>在该游戏中，两位博弈方的利益之和为零或一个常数，即一方有所得，另一方必有所失。而在生成对抗网络中，这两个博弈的角色分别为：<strong>生成器</strong>（generator）和<strong>判别器</strong>（discriminator），作用如下：</p><p>生成器 $G$：接受随机噪声（noise）输入，生成尽可能真实的样本<br>判别器 $D$：接受任意样本 $x$，输出 $D(x)$ 代表 $x$ 为真实样本的概率</p><p>在训练过程中，生成器 $G$ 的目标就是<strong>尽量生成真实的样本去欺骗判别器$D$</strong>，而判别器 $D$ 的目标就是<strong>尽量把生成器$G$生成的假样本和真实的样本区分开来</strong>。如此一来，生成器 $G$ 和判别器 $D$ 就构成了一个动态的“博弈过程”</p><p>在理想的情况下，博弈的结果是：<strong>生成器 $G$ 所拟合的分布 $p_\it{g}$ 可以无限接近于真实样本中的分布 $p_\it{data}$</strong> ，足以生成以假乱真的样本。而判别器 $D$ 无法再区分出样本的真假，因此对任意样本 $x$ ，都有 $D(x)=\frac{1}{2}$</p><p>最终，我们得到了一个生成模型 $G$！</p><p><img src="https://tuchuang001.com/images/2017/12/19/2.png" alt="GAN的基本框架"></p><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>GAN的优化目标函数如下：</p><script type="math/tex; mode=display">\min_G \max_D V(D, G) = \mathbb{E}_{x \sim p_{data}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D(G(z)))] \tag{1}</script><p>其中，</p><ul><li>$x$：真实样本</li><li>$p_{data}(x)$：真实样本的分布</li><li>$z$：随机噪声</li><li>$p_{z}(z)$：随机噪声的分布，一般采用<em>高斯分布</em></li><li>$G(z)$：生成器根据随机噪声 $z$ 生成的假样本</li><li>$D(x)$：样本 $x$ 为真实样本的概率</li></ul><p>上述目标函数是一个<strong>极小化极大</strong>的过程。对于判别器 $D$ 来说，它的目标是极大化 $V(D, G)$，那么必然导致 $D(x) \to 1$ 且 $D(G(z)) \to 0$，也就是前面提到的尽可能把生成的假样本和真样本正确地区分开来。而对于生成器 $G$ 来说，它的目标是极小化最优的判别器，同样地，有 $D(G(z)) \to 1$，即生成器尽量生成真实的样本去欺骗判别器</p><hr><p>那么，对于固定的生成器 $G$，最优的判别器 $D^*$ 是多少呢？</p><script type="math/tex; mode=display">\begin{align}D^* &= \max_D V(D, G) \nonumber \\&= \max_D \mathbb{E}_{x \sim p_{data}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D(G(z))] \nonumber \\&= \max_D \mathbb{E}_{x \sim p_{data}(x)}[\log D(x)] + \mathbb{E}_{x \sim p_{G}(x)}[\log (1 - D(x))] \nonumber \\ &= \max_D \int_x P_{data}(x) \log D(x)dx + \int_x P_{G}(x) \log (1-D(x))dx \nonumber \\ &= \max_D \int_x \left[ P_{data}(x) \log D(x)+ P_{G}(x) \log (1-D(x)) \right]dx \nonumber \\\end{align}</script><p>想要极大化 $V(D, G)$，那么对每一个样本 $x$，都令 $P_{data}(x) \log D(x)+ P_{G}(x) \log (1-D(x))$ 取到极大值即可。</p><p>由于给定了 $x$, 那么 $P_{data}(x)$ 和 $P_{G}(x)$ 都为定值，分别记作 $a$ 和 $b$<br>对于函数 $f(D)=a\log D + b\log (1-D)$，令 $\frac{df(D)}{dD} = a \cdot \frac{1}{D}-b \cdot \frac{1}{1-D} = 0 $，解得 $D^* = \frac{a}{a + b} = \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}$</p><p>即对于固定的生成器 $G$，最优的判别器为</p><script type="math/tex; mode=display">D^*  = \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)} \tag{2}</script><hr><p>现在，考虑生成器 $G$ 的目标，极小化最优的判别器，得到最优生成器 $G^*$</p><script type="math/tex; mode=display">\begin{align}G^* &= \min_G V(D^*, G) \nonumber \\&= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log D^*(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D^*(G(z))] \nonumber \\&= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log D^*(x)] + \mathbb{E}_{x \sim p_{G}(x)}[\log (1 - D^*(x))] \nonumber \\ &= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}] + \mathbb{E}_{x \sim p_{G}(x)}[\log (1 - \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)})] \nonumber \\ &= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}] + \mathbb{E}_{x \sim p_{G}(x)}[\log ( \frac{P_{G}(x)}{P_{data}(x) + P_{G}(x)})] \nonumber \\ &= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log \frac{P_{data}(x)}{\frac{P_{data}(x) + P_{G}(x)}{2}}] + \mathbb{E}_{x \sim p_{G}(x)}[\log ( \frac{P_{G}(x)}{\frac{P_{data}(x) + P_{G}(x)}{2}})] -2\log2 \nonumber \\ &= \min_G KL(P_{data}||\frac{P_{data}(x) + P_{G}(x)}{2}) + KL(P_{G}||\frac{P_{data}(x) + P_{G}(x)}{2}) - 2\log2 \nonumber \\&= \min_G 2JS(P_{data}||P_{G}) - 2\log 2 \tag{3} \end{align}</script><p>其中，$KL$表示<a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence" target="_blank" rel="noopener">Kullback–Leibler divergence</a>，$JS$表示<a href="https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence" target="_blank" rel="noopener">Jensen–Shannon divergence</a>，都是用来度量两个分布的相似性<br>对于$JS$散度来说，其取值范围为$[0, \log2]$，当且仅当两个分布相等时取到最小值0</p><p>因此，最优生成器 $G^* = \min_G 2JS(P_{data}||P_{G}) - 2\log 2$ ，当且仅当 $P_{data} = P_{G}$ 时，取到最小值 $-2\log2$</p><hr><p>由上述分析可知，该极小化极大的博弈对抗过程确实可以让生成器学习到真实的数据分布！</p><hr><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>根据前面 $V(D,G)$ 的定义，我们需要求两个数学期望，即 $\mathbb{E}_{x \sim p_{data}(x)}[\log D(x)]$ 和 $\mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D(G(z)))]$。但在实践中，我们是没办法利用积分来求这两个数学期望的，所以一般只能从数据集中做采样以逼近真实的数学期望</p><script type="math/tex; mode=display">\tilde{V}(D, G) = \frac{1}{m} \sum_{i=1}^{m} \log D(\boldsymbol{x}^i) + \frac{1}{m} \sum_{i=1}^{m} \log (1 - D(G(\boldsymbol{z}^i))</script><p><img src="https://tuchuang001.com/images/2017/12/19/3.png" alt="GAN的算法流程"></p><hr><p><strong>训练判别器</strong> $D$ （训练 $k$ 次）：<br>每次采样一组噪声变量 $\{z^1,z^2, \dots,z^m\}$ 和 一组真实数据 $\{x^1,x^2, \dots,x^m\}$，计算 $\theta_d$ 的梯度：</p><script type="math/tex; mode=display">\nabla_{\boldsymbol{\theta}_d} \frac{1}{m} \sum_{i=1}^{m} \left[ \log(D(\boldsymbol{x}^i)) + \log(1 - D(G(\boldsymbol{z}^i))) \right]</script><p>然后使用<strong>梯度上升</strong>算法更新$\theta_d$</p><p><strong>训练生成器</strong> $G$ （训练 $1$ 次）：<br>每次采样一组噪声变量 $\{z^1,z^2, \dots,z^m\}$，计算 $\theta_g$ 的梯度：</p><script type="math/tex; mode=display">\nabla_{\boldsymbol{\theta}_g} \frac{1}{m} \sum_{i=1}^{m} \log(1 - D(G(\boldsymbol{z}^i)))</script><p>然后使用<strong>梯度下降</strong>算法更新$\theta_g$</p><hr><blockquote><p>Q：<em>为什么判别器要训练k次，而生成器才训练1次？</em><br>A：因为优化生成器D的前提是判别器G要达到最优的状态。如果判别器比较弱的话，那么它将给生成器错误的引导，使得生成器的优化方向不对</p><p>Q：<em>为什么生成器的梯度只有后一项？</em><br>A：因为 $\tilde{V}$ 的前一项与参数 $\theta_g$ 无关</p></blockquote><hr><p>此外在论文中，作者针对生成器的训练提出了一个 “<strong>$-\log(D)$ trick</strong>“：<br><em>将最小化 $\log (1-D(G(z)))$ 改为 最小化 $-\log D(G(z))$</em></p><p>我们先来观察一下二者的函数图像</p><p><img src="https://tuchuang001.com/images/2017/12/19/5.jpg" alt="log(1-D(x))和-log(x)函数图像"></p><p>作者指出，在训练的早期，判别器 $G$ 可以轻易地区分出假样本，使得$D(G(z)) \to 0$。观察图像发现，$\log (1-D(x))$这个函数在 $x \to 0$ 时比较平滑，梯度也比较小，这就会导致生成器 $G$ 的训练变得十分地缓慢。而改为优化 $-\log(D(x))$ 后，在训练的早期能提供比较高的梯度，从而提高了训练速度。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> 生成对抗网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用TensorFlow实现逻辑回归</title>
      <link href="/posts/use-tensorflow-to-implement-logistic-regression/"/>
      <url>/posts/use-tensorflow-to-implement-logistic-regression/</url>
      
        <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><blockquote><p>使用TensorFlow实现小批量梯度下降的逻辑回归。<br>数据集：<a href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html" target="_blank" rel="noopener"><code>moons dataset</code></a><br><em>— From《Hands-on Machine Learning with Scikit-Learn and TensorFlow》Chapter9 Exercise12</em></p></blockquote><a id="more"></a><hr><p><strong>*附加功能：</strong></p><blockquote><p>• 在<code>logistic_regression()</code>函数中定义计算图，以便复用<br>• 在训练的时候定期保存检查点，并在训练结束的时候保存最终的模型<br>• 若训练中断，则从检查点中恢复<br>• 使用命名域来定义图<br>• 增加summaries日志记录，在TensorBoard中可视化学习曲线<br>•  调参（如，学习率、批数据大小等）并观察学习曲线</p></blockquote><hr><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>首先载入数据集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons</span><br><span class="line">m = <span class="number">1000</span>  <span class="comment"># 样本数量</span></span><br><span class="line"><span class="comment"># 载入数据集</span></span><br><span class="line">X_moons, y_moons = make_moons(m, noise=<span class="number">0.1</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure></p><p>接着将数据集可视化，以便有一个直观的感受<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># y_moons == 1提取正样本的索引</span></span><br><span class="line">plt.plot(X_moons[y_moons == <span class="number">1</span>, <span class="number">0</span>], X_moons[y_moons == <span class="number">1</span>, <span class="number">1</span>], <span class="string">'go'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">plt.plot(X_moons[y_moons == <span class="number">0</span>, <span class="number">0</span>], X_moons[y_moons == <span class="number">0</span>, <span class="number">1</span>], <span class="string">'r^'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/12/02/moons_dataset.png" alt="moons dataset"></p><p>为每个样本在第0维上添加<code>bias</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加bias</span></span><br><span class="line">X_moons_with_bias = np.c_[np.ones((m, <span class="number">1</span>)), X_moons]</span><br></pre></td></tr></table></figure></p><p>标签形状需要从<code>(m, )</code>reshape为<code>(m, 1)</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据标签从 1-D reshape成 2-D</span></span><br><span class="line">y_moons_column_vector = y_moons.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>从整个数据集中以<code>8:2</code>的比例，划分出训练集和测试集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试集占整个数据集的比例</span></span><br><span class="line">test_ratio = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试样本数量</span></span><br><span class="line">test_size = int(m * test_ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集</span></span><br><span class="line">X_train = X_moons_with_bias[:-test_size]</span><br><span class="line">y_train = y_moons_column_vector[:-test_size]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分测试集</span></span><br><span class="line">X_test = X_moons_with_bias[-test_size:]</span><br><span class="line">y_test = y_moons_column_vector[-test_size:]</span><br></pre></td></tr></table></figure></p><p>定义一个随机划分批数据函数，方便后续训练<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_batch</span><span class="params">(X_train, y_train, batch_size)</span>:</span></span><br><span class="line">    <span class="string">''' # 随机划分批数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X_train: 整个训练集样本</span></span><br><span class="line"><span class="string">    :param y_train: 整个训练集标签</span></span><br><span class="line"><span class="string">    :param batch_size: 每个batch的大小</span></span><br><span class="line"><span class="string">    :return: 样本和标签的批数据</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    rnd_indices = np.random.randint(<span class="number">0</span>, len(X_train), size=batch_size)</span><br><span class="line">    X_batch = X_train[rnd_indices]</span><br><span class="line">    y_batch = y_train[rnd_indices]</span><br><span class="line">    <span class="keyword">return</span> X_batch, y_batch</span><br></pre></td></tr></table></figure></p><hr><h2 id="构造计算图阶段"><a href="#构造计算图阶段" class="headerlink" title="构造计算图阶段"></a>构造计算图阶段</h2><p>moons dataset的特征只有2个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特征数量</span></span><br><span class="line">n_inputs = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>构造计算图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入数据</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_inputs + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权值初始化</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n_inputs + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>, seed=<span class="number">42</span>), name=<span class="string">'theta'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算logits</span></span><br><span class="line">logits = tf.matmul(X, theta, name=<span class="string">'logits'</span>)</span><br></pre></td></tr></table></figure></p><p>sigmod函数的计算方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一（根据定义）</span></span><br><span class="line">y_proba = <span class="number">1</span> / (<span class="number">1</span> + tf.exp(-logits))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二（内建函数）</span></span><br><span class="line">y_proba = tf.sigmoid(logits)</span><br></pre></td></tr></table></figure></p><p>计算逻辑回归的损失函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一（根据定义）</span></span><br><span class="line">epsilon = <span class="number">1e-7</span> <span class="comment"># 避免运算溢出</span></span><br><span class="line">loss = -tf.reduce_mean(y * tf.log(y_proba + epsilon) + (<span class="number">1</span> - y) * tf.log(<span class="number">1</span> - y_proba + epsilon), name = <span class="string">'loss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二（内建函数）</span></span><br><span class="line">loss = tf.losses.log_loss(y, y_proba, epsilon=epsilon)</span><br></pre></td></tr></table></figure></p><p>定义学习率、梯度下降优化器及变量初始化节点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降优化器</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line"><span class="comment"># 训练节点</span></span><br><span class="line">training_op = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure></p><p>训练相关的参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练的epoch次数（即遍历epoch次整个数据集）</span></span><br><span class="line">n_epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次批训练的样本数量</span></span><br><span class="line">batch_size = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成一次epoch所需要的批训练次数</span></span><br><span class="line">n_batches = int(np.ceil(m / batch_size))</span><br></pre></td></tr></table></figure></p><hr><h2 id="运行计算图阶段"><a href="#运行计算图阶段" class="headerlink" title="运行计算图阶段"></a>运行计算图阶段</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">            <span class="comment"># 获取批数据</span></span><br><span class="line">            X_batch, y_batch = random_batch(X_train, y_train, batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        loss_val = loss.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br><span class="line">        <span class="comment"># 每训练100个epoch打印当前的loss值</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch:'</span>, epoch, <span class="string">'\tLoss:'</span>, loss_val)</span><br><span class="line">    <span class="comment"># 在测试集上预测</span></span><br><span class="line">    y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br></pre></td></tr></table></figure><p>将概率大等于0.5的样本预测为正类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_pred = (y_proba_val &gt;= <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></p><hr><h2 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h2><p>使用准确率（precision）和召回率（recall）来评价模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准确率</span></span><br><span class="line">p_score = precision_score(y_test, y_pred)</span><br><span class="line"><span class="comment"># 召回率</span></span><br><span class="line">r_score = recall_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Precision score:'</span>, p_score)</span><br><span class="line">print(<span class="string">'Recall score:'</span>, r_score)</span><br></pre></td></tr></table></figure></p><hr><h2 id="可视化预测结果"><a href="#可视化预测结果" class="headerlink" title="可视化预测结果"></a>可视化预测结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_pred_idx = y_pred.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X_test[y_pred_idx, <span class="number">1</span>], X_test[y_pred_idx, <span class="number">2</span>], <span class="string">'go'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">plt.plot(X_test[~y_pred_idx, <span class="number">1</span>], X_test[~y_pred_idx, <span class="number">2</span>], <span class="string">'r^'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/result1.png" alt="预测结果可视化"></p><hr><h2 id="实现附加功能"><a href="#实现附加功能" class="headerlink" title="实现附加功能"></a>实现附加功能</h2><p>由于逻辑回归是一个线性分类器（从上面可视化的预测结果也可看出），效果不是特别好。<br>因此，我们使用多项式回归，即额外增加4个特征($x_{1}^2$、$x_{2}^2$、$x_{1}^3$、$x_{2}^3$)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加4个特征</span></span><br><span class="line">X_train_enhanced = np.c_[X_train, X_train[:, <span class="number">1</span>] ** <span class="number">2</span>,</span><br><span class="line">                         X_train[:, <span class="number">2</span>] ** <span class="number">2</span>,</span><br><span class="line">                         X_train[:, <span class="number">1</span>] ** <span class="number">3</span>,</span><br><span class="line">                         X_train[:, <span class="number">2</span>] ** <span class="number">3</span>,]</span><br><span class="line">X_test_enhanced = np.c_[X_test,</span><br><span class="line">                        X_test[:, <span class="number">1</span>] ** <span class="number">2</span>,</span><br><span class="line">                        X_test[:, <span class="number">2</span>] ** <span class="number">2</span>,</span><br><span class="line">                        X_test[:, <span class="number">1</span>] ** <span class="number">3</span>,</span><br><span class="line">                        X_test[:, <span class="number">2</span>] ** <span class="number">3</span>,]</span><br></pre></td></tr></table></figure><p>将逻辑回归封装成一个函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression</span><span class="params">(X, y, initializer=None, seed=<span class="number">42</span>, learning_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    <span class="string">''' 逻辑回归</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X: 样本</span></span><br><span class="line"><span class="string">    :param y: 标签</span></span><br><span class="line"><span class="string">    :param initializer: 权值初始化器</span></span><br><span class="line"><span class="string">    :param seed: 随机数种子</span></span><br><span class="line"><span class="string">    :param learning_rate: 学习率</span></span><br><span class="line"><span class="string">    :return: sigmod概率, 损失函数, 训练节点, loss日志记录, 保存器</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    n_inputs_with_bias = int(X.get_shape()[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'logistic_regression'</span>): <span class="comment"># 使用命名域</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'model'</span>):</span><br><span class="line">            <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                initializer = tf.random_uniform([n_inputs_with_bias, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>, seed=seed)</span><br><span class="line">            theta = tf.Variable(initializer, name=<span class="string">'theta'</span>)</span><br><span class="line">            logits = tf.matmul(X, theta)</span><br><span class="line">            y_proba = tf.sigmoid(logits)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">            loss = tf.losses.log_loss(y, y_proba, scope=<span class="string">'loss'</span>)</span><br><span class="line">            optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">            training_op = optimizer.minimize(loss)</span><br><span class="line">            loss_summary = tf.summary.scalar(<span class="string">'log_loss'</span>, loss)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'init'</span>):</span><br><span class="line">            init = tf.global_variables_initializer()</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'save'</span>):</span><br><span class="line">            saver = tf.train.Saver()</span><br><span class="line">    <span class="keyword">return</span> y_proba, loss, training_op, loss_summary, init, saver</span><br></pre></td></tr></table></figure></p><p>构造日志文件目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_dir</span><span class="params">(prefix=<span class="string">''</span>)</span>:</span></span><br><span class="line">    now = datetime.utcnow().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line">    root_logdir = <span class="string">'tf_logs'</span></span><br><span class="line">    <span class="keyword">if</span> prefix:</span><br><span class="line">        prefix += <span class="string">'-'</span></span><br><span class="line">    name = prefix + <span class="string">'run-'</span> + now</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;/&#123;&#125;/'</span>.format(root_logdir, name)</span><br></pre></td></tr></table></figure></p><p>构造计算图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特征数量，注意额外增加了4个特征</span></span><br><span class="line">n_inputs = <span class="number">2</span> + <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件目录</span></span><br><span class="line">logdir = log_dir(<span class="string">'logreg'</span>)</span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_inputs + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装好logistic_regression，直接调用</span></span><br><span class="line">y_proba, loss, training_op, loss_summary, init, saver = logistic_regression(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存计算图结构</span></span><br><span class="line">file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph())</span><br></pre></td></tr></table></figure></p><p>运行计算图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">n_epochs = <span class="number">10001</span></span><br><span class="line">batch_size = <span class="number">50</span></span><br><span class="line">n_batches = int(np.ceil(m / batch_size))</span><br><span class="line"></span><br><span class="line">checkpoint_path = <span class="string">'./tmp/my_logreg_model.ckpt'</span></span><br><span class="line">checkpoint_epoch_path = checkpoint_path + <span class="string">'.epoch'</span></span><br><span class="line">final_model_path = <span class="string">'./my_logreg_model'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 判断checkpoint_epoch_path文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(checkpoint_epoch_path):</span><br><span class="line">        <span class="keyword">with</span> open(checkpoint_epoch_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 文件记录了最后一次保存的epoch编号</span></span><br><span class="line">            start_epoch = int(f.read())</span><br><span class="line">        print(<span class="string">'Training was interrupted. Continuing at epoch'</span>, start_epoch)</span><br><span class="line">        <span class="comment"># 恢复会话</span></span><br><span class="line">        saver.restore(sess, checkpoint_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 重新开始</span></span><br><span class="line">        start_epoch = <span class="number">0</span></span><br><span class="line">        sess.run(init)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(start_epoch, n_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">            X_batch, y_batch = random_batch(X_train_enhanced, y_train, batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 计算每个epoch的loss值及其日志记录</span></span><br><span class="line">        loss_val, summary_str = sess.run([loss, loss_summary], feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)</span><br><span class="line">        <span class="comment"># 追加loss日志记录,注意当前epoch的编号也要记录</span></span><br><span class="line">        file_writer.add_summary(summary_str, epoch)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每500个epoch保存checkpoint</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch:'</span>, epoch, <span class="string">'\tLoss:'</span>, loss_val)</span><br><span class="line">            saver.save(sess, checkpoint_path)</span><br><span class="line">            <span class="comment"># 每次覆盖写入新的epoch编号</span></span><br><span class="line">            <span class="keyword">with</span> open(checkpoint_epoch_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">b'%d'</span> % (epoch + <span class="number">1</span>))</span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 保存最终模型            </span></span><br><span class="line">    saver.save(sess, final_model_path)</span><br><span class="line">    <span class="comment"># 在测试集上进行预测</span></span><br><span class="line">    y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)</span><br><span class="line">    <span class="comment"># 若训练未中断,则删除checkpoint_epoch_path文件</span></span><br><span class="line">    os.remove(checkpoint_epoch_path)</span><br></pre></td></tr></table></figure></p><p>预测结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_pred = (y_proba_val &gt;= <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></p><p>输出准确率和召回率<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Precision score:'</span>, precision_score(y_test, y_pred))</span><br><span class="line">print(<span class="string">'Recall score:'</span>, recall_score(y_test, y_pred))</span><br></pre></td></tr></table></figure></p><p>可视化预测结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_pred_idx = y_pred.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X_test[y_pred_idx, <span class="number">1</span>], X_test[y_pred_idx, <span class="number">2</span>], <span class="string">'go'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">plt.plot(X_test[~y_pred_idx, <span class="number">1</span>], X_test[~y_pred_idx, <span class="number">2</span>], <span class="string">'r^'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/12/02/result2.png" alt="可视化预测结果"></p><p>可以看出，增加额外4个特征，能够显著提高预测结果</p><hr><p>开始对<code>learning rate</code>和<code>batch size</code>进行玄学调参…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> reciprocal</span><br><span class="line"></span><br><span class="line">n_search_iterations = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> search_iteration <span class="keyword">in</span> range(n_search_iterations):</span><br><span class="line">    batch_size = np.random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># reciprocal为倒数分布</span></span><br><span class="line">    <span class="comment"># 详见https://en.wikipedia.org/wiki/Reciprocal_distribution</span></span><br><span class="line">    <span class="comment"># 一般来说，如果对超参数的最优量级没把握的话，可以使用该分布进行调参</span></span><br><span class="line">    learning_rate = reciprocal.rvs(<span class="number">0.0001</span>, <span class="number">0.1</span>, random_state=search_iteration)</span><br><span class="line">    </span><br><span class="line">    n_inputs = <span class="number">2</span> + <span class="number">4</span></span><br><span class="line">    logdir = log_dir(<span class="string">'logdir'</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'Iteration'</span>, search_iteration)</span><br><span class="line">    print(<span class="string">'  logdir:'</span>, logdir)</span><br><span class="line">    print(<span class="string">'  batch size:'</span>, batch_size)</span><br><span class="line">    print(<span class="string">'  learning rate:'</span>, learning_rate)</span><br><span class="line">    print(<span class="string">'  training: '</span>, end=<span class="string">''</span>)</span><br><span class="line">    </span><br><span class="line">    X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_inputs + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">    y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line">    </span><br><span class="line">    y_proba, loss, training_op, loss_summary, init, saver = logistic_regression(X, y, learning_rate=learning_rate)</span><br><span class="line">    </span><br><span class="line">    file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph())</span><br><span class="line">    </span><br><span class="line">    n_epochs = <span class="number">10001</span></span><br><span class="line">    n_batches = int(np.ceil(m / batch_size))</span><br><span class="line">    </span><br><span class="line">    final_model_path = <span class="string">'./model/my_logreg_model_%d'</span> % search_iteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(init)</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">            <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">                X_batch, y_batch = random_batch(X_train_enhanced, y_train, batch_size)</span><br><span class="line">                sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">            loss_val, summary_str = sess.run([loss, loss_summary], feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)    </span><br><span class="line">            file_writer.add_summary(summary_str, epoch)</span><br><span class="line">            <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'.'</span>, end=<span class="string">''</span>)</span><br><span class="line">        print()</span><br><span class="line">        </span><br><span class="line">        saver.save(sess, final_model_path)</span><br><span class="line">        </span><br><span class="line">        y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)</span><br><span class="line">        y_pred = (y_proba_val &gt;= <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">'  Precision:'</span>, precision_score(y_test, y_pred))</span><br><span class="line">        print(<span class="string">'  Recall:'</span>, recall_score(y_test, y_pred))</span><br></pre></td></tr></table></figure><p>打印训练信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Iteration 0</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202101244/</span><br><span class="line">  batch size: 54</span><br><span class="line">  learning rate: 0.00443037524522</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.979797979798</span><br><span class="line">  Recall: 0.979797979798</span><br><span class="line">Iteration 1</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202101623/</span><br><span class="line">  batch size: 22</span><br><span class="line">  learning rate: 0.00178264971514</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.979797979798</span><br><span class="line">  Recall: 0.979797979798</span><br><span class="line">Iteration 2</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202102501/</span><br><span class="line">  batch size: 74</span><br><span class="line">  learning rate: 0.00203228544324</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.969696969697</span><br><span class="line">  Recall: 0.969696969697</span><br><span class="line">Iteration 3</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202102742/</span><br><span class="line">  batch size: 58</span><br><span class="line">  learning rate: 0.00449152382514</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.979797979798</span><br><span class="line">  Recall: 0.979797979798</span><br><span class="line">Iteration 4</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103106/</span><br><span class="line">  batch size: 61</span><br><span class="line">  learning rate: 0.0796323472178</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.980198019802</span><br><span class="line">  Recall: 1.0</span><br><span class="line">Iteration 5</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103417/</span><br><span class="line">  batch size: 92</span><br><span class="line">  learning rate: 0.000463425058329</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.912621359223</span><br><span class="line">  Recall: 0.949494949495</span><br><span class="line">Iteration 6</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103630/</span><br><span class="line">  batch size: 74</span><br><span class="line">  learning rate: 0.0477068184194</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.98</span><br><span class="line">  Recall: 0.989898989899</span><br><span class="line">Iteration 7</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103916/</span><br><span class="line">  batch size: 58</span><br><span class="line">  learning rate: 0.000169404470952</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.9</span><br><span class="line">  Recall: 0.909090909091</span><br><span class="line">Iteration 8</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202104242/</span><br><span class="line">  batch size: 61</span><br><span class="line">  learning rate: 0.0417146119941</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.980198019802</span><br><span class="line">  Recall: 1.0</span><br><span class="line">Iteration 9</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202104602/</span><br><span class="line">  batch size: 92</span><br><span class="line">  learning rate: 0.000107429229684</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.882352941176</span><br><span class="line">  Recall: 0.757575757576</span><br></pre></td></tr></table></figure></p><p>  让我们打开<code>TensorBoard</code>观察10次训练的学习曲线</p><p>  <img src="https://tuchuang001.com/images/2017/12/02/result3.png" alt="10次训练的学习曲线"></p><p>  可以看出，第4次（从0开始）的<code>loss</code>值最小<br>  最终，找到的超参数为</p><div class="table-container"><table><thead><tr><th style="text-align:center">超参数</th><th style="text-align:center">取值</th></tr></thead><tbody><tr><td style="text-align:center">learning rate</td><td style="text-align:center">0.0796323472178</td></tr><tr><td style="text-align:center">batch size</td><td style="text-align:center">61</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> hands-on ML </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hands-on Machine learning 之 TensorFLow入门</title>
      <link href="/posts/hands-on-ml-up-and-running-tensorflow/"/>
      <url>/posts/hands-on-ml-up-and-running-tensorflow/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://blog.rescale.com/wp-content/uploads/2017/02/markblogtensorflow.png" alt=""></p><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener"><strong>TensorFlow</strong></a>是Google在2015年11月份开源的人工智能系统，是之前所开发的深度学习基础架构<code>DistBelief</code>的改进版本，该系统可以被用于语音识别、图像识别等多个领域。本文将介绍<code>TensorFlow</code>的基本概念和常见用法。</p><a id="more"></a><hr><h2 id="创建图并在会话中运行"><a href="#创建图并在会话中运行" class="headerlink" title="创建图并在会话中运行"></a>创建图并在会话中运行</h2><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_036.png" alt="一个简单的数据流图"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入tensorflow</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量x，y及计算节点f</span></span><br><span class="line">x = tf.Variable(<span class="number">3</span>, name=<span class="string">'x'</span>)</span><br><span class="line">y = tf.Variable(<span class="number">4</span>, name=<span class="string">'y'</span>)</span><br><span class="line">f = x * x * y + y + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>值得注意的是，上述代码并没有进行任何的运算，仅仅是创建了一个<code>计算图</code>（computation graph）而已。实际上，连变量都还没有被初始化。</p><p>为了对该计算图进行运算，我们必须创建一个<code>会话</code>（session）。然后在会话中初始化变量，以及计算<code>f</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.Session() <span class="comment"># 创建会话</span></span><br><span class="line">sess.run(x.initializer) <span class="comment"># 初始化变量x</span></span><br><span class="line">sess.run(y.initializer) <span class="comment"># 初始化变量y</span></span><br><span class="line">result = sess.run(f) <span class="comment"># 计算f</span></span><br><span class="line">print(result) <span class="comment"># 打印结果</span></span><br><span class="line">&gt;&gt; <span class="number">42</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sess.close() <span class="comment"># 关闭会话</span></span><br></pre></td></tr></table></figure><p>重复使用<code>sess.run(...)</code>可能有点繁琐，有一个更好的方式是使用python的<a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" target="_blank" rel="noopener"><code>with</code></a>语句。</p><p>在<code>with</code>语句块开始时，创建的会话会成为计算图的默认会话。在语句块结束时，创建的会话也会自动结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个会话并命名为sess</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    x.initializer.run() <span class="comment"># 等同于 sess.run(x.initializer)</span></span><br><span class="line">    y.initializer.run() <span class="comment"># 等同于 sess.run(y.initializer)</span></span><br><span class="line">    result = f.eval() <span class="comment"># result = sess.run(f)</span></span><br></pre></td></tr></table></figure><p>除了手动初始化每个变量，也可以使用<code>global_variables_initializer()</code>函数初始化所有变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，并没有立即将变量初始化，而是创建一个初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run() <span class="comment"># 在这里才真正初始化</span></span><br><span class="line">    result = f.eval()</span><br></pre></td></tr></table></figure><hr><h2 id="管理计算图"><a href="#管理计算图" class="headerlink" title="管理计算图"></a>管理计算图</h2><p>所有创建的<code>节点</code>（node）都会自动添加进默认图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 = tf.Variable(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 判断变量x1所在的图是否是默认图</span></span><br><span class="line">x1.graph <span class="keyword">is</span> tf.get_default_graph()</span><br><span class="line">&gt;&gt; <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>但是，有的时候需要管理多个独立的图。我们便可以创建一个临时的图，并在<code>with</code>语句块内将其设置为默认图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph = tf.Graph() <span class="comment"># 创建图</span></span><br><span class="line"><span class="comment"># 在with内将graph设置为默认图</span></span><br><span class="line"><span class="keyword">with</span> graph.as_default(): </span><br><span class="line">    <span class="comment"># 此时创建的变量应该在图graph里</span></span><br><span class="line">    x2 = tf.Variable(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断x2所在的图，是不是真的在graph里</span></span><br><span class="line">x2.graph <span class="keyword">is</span> graph</span><br><span class="line">&gt;&gt; <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样，判断x2是不是在全局的默认图里(显然不是的)</span></span><br><span class="line">x2.graph <span class="keyword">is</span> tf.get_default_graph()</span><br><span class="line">&gt;&gt; <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>若想要将默认图重置（删除图中所有的节点），可以使用<code>tf.reset_default_graph()</code>函数。</p><hr><h2 id="节点的生命周期"><a href="#节点的生命周期" class="headerlink" title="节点的生命周期"></a>节点的生命周期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的图</span></span><br><span class="line">w = tf.constant(<span class="number">3</span>)</span><br><span class="line">x = w + <span class="number">2</span></span><br><span class="line">y = x + <span class="number">5</span></span><br><span class="line">z = x * <span class="number">3</span></span><br><span class="line"><span class="comment"># 在会话中计算图</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(y.eval()) <span class="comment"># 10</span></span><br><span class="line">    print(z.eval()) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><p>在会话中，为了计算<code>y</code>，会自动检测出<code>y</code>依赖于<code>x</code>，而<code>x</code>又依赖于<code>w</code>。那么，将会依次计算<code>w</code>和<code>x</code>，最后再计算<code>y</code>。而为了计算<code>z</code>，也同样会依次计算<code>w</code>和<code>x</code>。</p><p>注意在此过程中，<code>w</code>和<code>x</code>的值<strong>并不会被重复使用</strong>！也就是说，上述代码总共对<code>w</code>和<code>x</code>计算了两次(即使两次的结果都是一样的)。</p><p>因此，对于同一张图的多次运算，除了<code>tf.Variable()</code>变量外，其他节点的值在一次运行结束后都会被丢弃，不会被重复使用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点类型</th><th style="text-align:center">生命周期</th></tr></thead><tbody><tr><td style="text-align:center"><code>tf.Variable()</code></td><td style="text-align:center">整个会话</td></tr><tr><td style="text-align:center"><code>others</code></td><td style="text-align:center">会话的某次运行</td></tr></tbody></table></div><p>为了高效地求得<code>y</code>和<code>z</code>的值，可以在会话的一次运行内同时计算它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 同时计算y和z，此时w和x只计算一次</span></span><br><span class="line">    y_val, z_val = sess.run([y, z])</span><br><span class="line">    print(y_val) <span class="comment"># 10</span></span><br><span class="line">    print(z_val) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><hr><h2 id="使用TensorFlow进行线性回归"><a href="#使用TensorFlow进行线性回归" class="headerlink" title="使用TensorFlow进行线性回归"></a>使用TensorFlow进行线性回归</h2><p>TensorFlow的操作（operations，记作ops）可以接收任意多个输入，可以产生任意多个输出。</p><p>比如<code>addition</code>和<code>multiplication</code>可以接受2个输入，产生1个输出。<br>而被成为<strong>源操作</strong>（source ops）的<code>Constants</code>和<code>variables</code>，则没有输入。</p><p>其中，输入和输出都是多维数组，称之为<strong>张量</strong>（tensor）。</p><hr><p>接下来，将使用<a href="http://scikit-learn.org/stable/index.html" target="_blank" rel="noopener">sklearn</a>的<a href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.fetch_california_housing.html" target="_blank" rel="noopener">加利福尼亚房屋数据</a>来进行线性回归。</p><p>对于线性回归参数<code>theta</code>的拟合，将使用正规方程（Normal Equation）计算：$\theta = (X^T X)^{-1}X^T y$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_california_housing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入sklearn自带的加利福尼亚房屋数据</span></span><br><span class="line">housing = fetch_california_housing()</span><br><span class="line"><span class="comment"># 样本数及特征数</span></span><br><span class="line">m, n = housing.data.shape</span><br><span class="line"><span class="comment"># 添加bias</span></span><br><span class="line">housing_data_plus_bias = np.c_[np.ones((m, <span class="number">1</span>)), housing.data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的常量节点X和y，分别用来存放样本和标签</span></span><br><span class="line">X = tf.constant(housing_data_plus_bias, dtype=tf.float32, name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.constant(housing.target.reshape(<span class="number">-1</span>, <span class="number">1</span>), dtype=tf.float32, name=<span class="string">'y'</span>)</span><br><span class="line"><span class="comment"># 计算X的转置</span></span><br><span class="line">XT = tf.transpose(X)</span><br><span class="line"><span class="comment"># 使用正规方程计算theta</span></span><br><span class="line">theta = tf.matmul(tf.matmul(tf.matrix_inverse(tf.matmul(XT, X)), XT), y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次注意，上述代码并没有进行实际的运算，只是在构建计算图而已</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 在会话中计算theta的值</span></span><br><span class="line">    theta_value = theta.eval()</span><br></pre></td></tr></table></figure><hr><h2 id="实现梯度下降"><a href="#实现梯度下降" class="headerlink" title="实现梯度下降"></a>实现梯度下降</h2><p>接下来将使用<strong>批梯度下降</strong>（Batch Gradient Descent）方法来进行线性回归参数的拟合。</p><p>使用梯度下降方法一般要先对特征进行<strong>标准化</strong>（normalize，即减均值，除方差）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaled_housing_data = scaler.fit_transform(housing.data)</span><br><span class="line">scaled_housing_data_plus_bias = np.c_[np.ones((m, <span class="number">1</span>)), scaled_housing_data]</span><br></pre></td></tr></table></figure><hr><h3 id="手动计算梯度"><a href="#手动计算梯度" class="headerlink" title="手动计算梯度"></a>手动计算梯度</h3><p>$\theta := \theta - \frac{\alpha}{m} X^{T} (X\theta - \vec{y})$<br>其中，$\alpha$是学习率，$m$是批样本数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">n_epochs = <span class="number">1000</span> <span class="comment"># 遍历1000次数据集</span></span><br><span class="line">learning_rate = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的常量节点X和y，分别用来存放样本和标签</span></span><br><span class="line"><span class="comment"># 特征已经过normalize，并加上了bias</span></span><br><span class="line">X = tf.constant(scaled_housing_data_plus_bias, dtype=tf.float32, name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.constant(housing.target.reshape(<span class="number">-1</span>, <span class="number">1</span>), dtype=tf.float32, name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的变量节点theta，用来存放待求解的参数（使用均匀分布初始化节点）</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>), name=<span class="string">'theta'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建预测节点</span></span><br><span class="line">y_pred = tf.matmul(X, theta, name=<span class="string">'predictions'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建误差节点</span></span><br><span class="line">error = y_pred - y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建损失函数节点，使用均方根误差（mean square error）</span></span><br><span class="line">mse = tf.reduce_mean(tf.square(error), name=<span class="string">'mse'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建梯度计算节点</span></span><br><span class="line">gradients = <span class="number">1</span> / m * tf.matmul(tf.transpose(X), error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建赋值节点，即 theta = theta - learning_rate * gradients</span></span><br><span class="line">training_op = tf.assign(theta, theta - learning_rate * gradients)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建变量初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="comment"># 每100个epoch打印当前的loss值</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch'</span>, epoch, <span class="string">'MSE='</span>, mse.eval())</span><br><span class="line">        <span class="comment"># 进行梯度下降更新参数theta</span></span><br><span class="line">        sess.run(training_op)</span><br><span class="line">    <span class="comment"># 训练完成后，计算最终的theta参数值</span></span><br><span class="line">    best_theta = theta.eval()</span><br></pre></td></tr></table></figure><hr><h3 id="使用autodiff"><a href="#使用autodiff" class="headerlink" title="使用autodiff"></a>使用autodiff</h3><p>在前面的代码中，需要我们事先手动计算好loss function（MSE）的梯度才能进行训练。<br>虽然在线性回归里面求解梯度还不算复杂，但是对于深度神经网络来说，梯度的求解将会让人十分头疼。</p><p>在TensorFlow中，提供了<code>autodiff</code>能够帮助我们自动计算梯度。</p><p>只需将之前的梯度计算替换为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradients = tf.gradients(mse, [theta])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p><code>gradients()</code>函数接受一个操作节点（如，<code>mse</code>损失函数计算节点），以及一系列需要求解梯度的变量（如，<code>theta</code>），最终返回对应的梯度列表。</p><hr><h3 id="使用优化器"><a href="#使用优化器" class="headerlink" title="使用优化器"></a>使用优化器</h3><p>TensorFlow能够自动计算梯度已经很方便了，但是可以将事情变得更加简单——使用优化器。</p><p>比如，使用<strong>梯度下降优化器</strong>（Gardient Descent optimizer）。</p><p>便可以简单地将之前<code>gradients = ...</code>和<code>training_op = ...</code>直接替换成下列方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(mse)</span><br></pre></td></tr></table></figure><hr><h2 id="为训练算法提供数据"><a href="#为训练算法提供数据" class="headerlink" title="为训练算法提供数据"></a>为训练算法提供数据</h2><p>首先，我们将之前的批梯度下降算法改为<strong>小批量梯度下降算法</strong>（Mini-batch Gradient Descent）。<br>那么对于每个batch，我们都需要不断地替换<code>X</code>和<code>y</code>常量节点，来向训练算法提供数据。</p><p>在TensorFlow中，一个典型的做法是使用<code>placeholder</code><strong>占位符节点</strong>。</p><p>占位符节点在创建的时候，只需指定其存放的数据类型（如，floa32等），以及存放的数据维度大小即可。<br>然后，等到训练运行时才真正往占位符里放数据（使用<code>feed_dict</code>参数放数据）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># None 意味着在该维度不限制大小</span></span><br><span class="line">A = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">3</span>))</span><br><span class="line">B = A + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 由于B依赖于A，因此在对B求值的时候，必须先用feed_dict向占位符A提供数据</span></span><br><span class="line">    B_val_1 = B.eval(feed_dict=&#123;A: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]&#125;)</span><br><span class="line">    <span class="comment"># 占位符A的第0维度可以是任意大小</span></span><br><span class="line">    B_val_2 = B.eval(feed_dict=&#123;A: [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(B_val_1)</span><br><span class="line">&gt;&gt; [[ <span class="number">6.</span>  <span class="number">7.</span>  <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">print(B_val_2)</span><br><span class="line">&gt;&gt; [[  <span class="number">9.</span>  <span class="number">10.</span>  <span class="number">11.</span>]</span><br><span class="line">    [ <span class="number">12.</span>  <span class="number">13.</span>  <span class="number">14.</span>]]</span><br></pre></td></tr></table></figure><hr><p>使用<code>placeholder</code>实现小批量梯度下降算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_epochs = <span class="number">10</span> <span class="comment"># 遍历10次数据集</span></span><br><span class="line">learning_rate = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line">batch_size = <span class="number">100</span> <span class="comment"># 批数据大小</span></span><br><span class="line">n_batches = int(np.ceil(m / batch_size)) <span class="comment"># 完成一次epoch所需要的批次数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_batch</span><span class="params">(epoch, batch_index, batch_size)</span>:</span></span><br><span class="line">    <span class="string">''' 获取批数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param epoch: 当前epoch的次数</span></span><br><span class="line"><span class="string">    :param batch_index: 当前batch的序号</span></span><br><span class="line"><span class="string">    :param batch_size: 每个batch的大小</span></span><br><span class="line"><span class="string">    :return: 样本和标签的批数据</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># seed的种子设为：当前batch的总序号</span></span><br><span class="line">    <span class="comment"># 比如，完成一个epoch需要5个batch</span></span><br><span class="line">    <span class="comment"># 当前是第3个epoch的第2个batch</span></span><br><span class="line">    <span class="comment"># 那么这个batch总序号就是3 × 5 + 2 = 17</span></span><br><span class="line">    np.random.seed(epoch * n_batches + batch_index)</span><br><span class="line">    <span class="comment"># 在[0, m)范围内，产生batch_size个索引</span></span><br><span class="line">    indices = np.random.randint(m, size=batch_size)</span><br><span class="line">    <span class="comment"># 根据索引，获取样本的批数据</span></span><br><span class="line">    X_batch = scaled_housing_data_plus_bias[indices]</span><br><span class="line">    <span class="comment"># 根据索引，获取标签的批数据</span></span><br><span class="line">    y_batch = housing.target.reshape(<span class="number">-1</span>, <span class="number">1</span>)[indices]</span><br><span class="line">    <span class="keyword">return</span> X_batch, y_batch</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建TensorFlow的占位符节点X和y，分别用来存放样本和标签</span></span><br><span class="line"><span class="comment"># 第0维度为None则不指定大小，因为样本数需要在运行时确定</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的变量节点theta，用来存放待求解的参数（使用均匀分布初始化节点）</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>, seed=<span class="number">42</span>), name=<span class="string">'thete'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建预测节点</span></span><br><span class="line">y_pred = tf.matmul(X, theta, name=<span class="string">'predictions'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建误差节点</span></span><br><span class="line">error = y_pred - y</span><br><span class="line"></span><br><span class="line">＃ 创建损失函数节点，使用均方根误差（mean square error）</span><br><span class="line">mse = tf.reduce_mean(tf.square(error), name=<span class="string">'mse'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建梯度下降优化器节点 及 对应的训练节点</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建变量初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init) </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">            <span class="comment"># 获取批数据</span></span><br><span class="line">            X_batch, y_batch = fetch_batch(epoch, batch_index, batch_size)</span><br><span class="line">            <span class="comment"># 由于训练节点依赖于X和y，因此使用feed_dict参数传送一个字典，分别为X和y提供数据</span></span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">    best_theta = theta.eval()</span><br></pre></td></tr></table></figure><hr><h2 id="模型的存储及读取"><a href="#模型的存储及读取" class="headerlink" title="模型的存储及读取"></a>模型的存储及读取</h2><p>模型一旦训练好，那么应该将相关的信息（如，参数、计算图等）存储在硬盘里，方便以后的使用。<br>同样，在模型的训练过程中，应该定时地保存检查点（checkpoint）。这使得模型训练中断之后，可以直接从最后一次检查点开始训练而不是重头开始。</p><hr><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p>只需在计算图<strong>构造阶段</strong>（construction phase）的最后新建一个<code>Saver</code>保存节点即可。<br>然后在<strong>执行阶段</strong>（execution phase），调用其<code>save(sess, path)</code>方法即可将模型保存到<code>path</code>路径下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>), name=<span class="string">"theta"</span>)</span><br><span class="line">[...]</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"><span class="comment"># 在construction phase之后创建Saver node即可</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>: <span class="comment"># 每100个epoch保存checkpoint</span></span><br><span class="line">            save_path = saver.save(sess, <span class="string">'tmp/my_model.ckpt'</span>)</span><br><span class="line">        sess.run(training_op)</span><br><span class="line">    best_theta = theta.eval()</span><br><span class="line">    <span class="comment"># 训练完毕，保存最终模型</span></span><br><span class="line">    save_path = saver.save(sess, <span class="string">'tmp/my_model_final.ckpt'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="读取模型"><a href="#读取模型" class="headerlink" title="读取模型"></a>读取模型</h3><p>首先，还是在构造阶段的最后新建一个<code>Saver</code>保存节点。<br>然后，在执行阶段的开始，调用其<code>restore(sess, path)</code>方法即可将path路径下的模型读取到当前的会话中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">'tmp/my_model_final.ckpt'</span>)</span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><hr><p><code>Saver</code>默认情况下，会存储和读取模型的所有参数。<br>不过，我们也可以指定只保存哪些变量，以及使用什么名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保存theta变量，命名为weights</span></span><br><span class="line">saver = tf.train.Saver(&#123;<span class="string">"weights"</span>: theta&#125;)</span><br></pre></td></tr></table></figure><p><code>Saver</code>默认情况下，也会存储计算图的结构，保存在路径的<code>*.meta</code>文件中。<br>如果需要读取模型的计算图，可以调用<code>tf.train.import_meta_graph()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取模型的计算图</span></span><br><span class="line"><span class="comment"># 这样可以完整地恢复模型，不仅包括模型的参数，还包括模型的计算图结构</span></span><br><span class="line">saver = tf.train.import_meta_graph(<span class="string">"/tmp/my_model_final.ckpt.meta"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"/tmp/my_model_final.ckpt"</span>)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><hr><h2 id="使用TensorBoard进行可视化"><a href="#使用TensorBoard进行可视化" class="headerlink" title="使用TensorBoard进行可视化"></a>使用TensorBoard进行可视化</h2><p>在此之前，我们都是用<code>print</code>函数打印出训练过程。然而，有一个更好的选择是：使用<code>TensorBoard</code>！</p><p>接下来，我们将对线性回归的loss值进行可视化。</p><hr><p>首先，新建一个存放数据的日志目录（使用时间戳作为目录名）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以指定格式获取当前时间</span></span><br><span class="line">now = datetime.utcnow().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line"><span class="comment"># 根目录</span></span><br><span class="line">root_logdir = <span class="string">'tf_logs'</span></span><br><span class="line"><span class="comment"># 日志文件目录</span></span><br><span class="line">logdir = <span class="string">'&#123;&#125;/run-&#123;&#125;/'</span>.format(root_logdir, now)</span><br></pre></td></tr></table></figure><p>其次，在构造阶段的末尾添加以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># summary是TensorBoard的一种二进制日志字符串</span></span><br><span class="line"><span class="comment"># 我们使用它的scalar标量类型（还有其他类型，如tf.summary.image可以可视化图像）</span></span><br><span class="line"><span class="comment"># 参数'MSE'：可视化时变量的名称</span></span><br><span class="line"><span class="comment"># 参数mse：loss function节点</span></span><br><span class="line">mse_summary = tf.summary.scalar(<span class="string">'MSE'</span>, mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FileWriter可以将summaries写进指定的日志文件中</span></span><br><span class="line"><span class="comment"># 参数logdir：指定的日志文件路径</span></span><br><span class="line"><span class="comment"># 参数tf.get_default_graph()：需要可视化的计算图结构</span></span><br><span class="line">file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph())</span><br></pre></td></tr></table></figure><p>最后，在执行阶段添加以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">    X_batch, y_batch = fetch_batch(epoch, batch_index, batch_size)</span><br><span class="line">    <span class="keyword">if</span> batch_index % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 计算mse_summary的值</span></span><br><span class="line">        summary_str = mse_summary.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        step = epoch * n_batches + batch_index</span><br><span class="line">        <span class="comment"># 将summary添加到日志文件中，同时需要指定当前的step（也就是可视化时的横轴坐标）</span></span><br><span class="line">        file_writer.add_summary(summary_str, step)</span><br><span class="line">    sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># 关闭FileWriter</span></span><br><span class="line">file_writer.close()</span><br></pre></td></tr></table></figure><p>现在，让我们启动<code>TensorBoard</code>！</p><p>首先，在终端中输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tensorboard --logdir tf_logs/</span><br><span class="line">&gt;&gt; Starting TensorBoard on port 6006</span><br><span class="line">   (You can navigate to http://0.0.0.0:6006)</span><br></pre></td></tr></table></figure></p><p>然后，在浏览器中打开<code>http://0.0.0.0:6006/</code> (或<code>http://localhost:6006/</code>)，即可访问TensorBoard！</p><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_037.png" alt="可视化loss值"></p><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_038.png" alt="可视化计算图"></p><hr><h2 id="命名域"><a href="#命名域" class="headerlink" title="命名域"></a>命名域</h2><p>当处理复杂模型的时候，图中可能有成千上万个节点。因此，非常有必要将相关的节点组织起来放到一起。<br>这就需要TensorFlow中的<strong>命名域</strong>（Name Scopes）来管理节点！</p><p>比如，我们可以将之前代码里的<code>error</code>和<code>mse</code>操作节点放在一个名叫<code>loss</code>的命名域里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'loss'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    error = y_pred - y</span><br><span class="line">    mse = tf.reduce_mean(tf.square(error), name=<span class="string">'mse'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(error.op.name)</span><br><span class="line">&gt;&gt; loss/sub</span><br><span class="line">print(mse.op.name)</span><br><span class="line">&gt;&gt; loss/mse</span><br></pre></td></tr></table></figure><p>在TensorBoard中，error和mse将出现在loss命名域内。</p><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_039.png" alt="TensorBoard中的命名域"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a1 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line">a2 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"param"</span>): </span><br><span class="line">    a3 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"param"</span>):     </span><br><span class="line">    a4 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> (a1, a2, a3, a4):</span><br><span class="line">    print(node.op.name)</span><br><span class="line">    </span><br><span class="line">&gt;&gt; a</span><br><span class="line">   a_1</span><br><span class="line">   param/a</span><br><span class="line">   param_1/a</span><br></pre></td></tr></table></figure><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>假设现在要对多个<code>ReLU</code>（rectified linear units，修正线性单元）输出进行累加。</p><script type="math/tex; mode=display">ReLU_{x,b}(X) = max(X \cdot w + b, 0 )</script><p>由于要计算多次ReLU，所以基于模块化的思想，我们可以将实现ReLU功能的语句单独封装成一个函数以供调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">''' 实现ReLU</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X: 输入样本</span></span><br><span class="line"><span class="string">    :return: 经过ReLU修正后的输出</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    w_shape = (int(X.get_shape()[<span class="number">1</span>]), <span class="number">1</span>)</span><br><span class="line">    w = tf.Variable(tf.random_normal(w_shape), name=<span class="string">'weights'</span>)</span><br><span class="line">    b = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'bias'</span>)</span><br><span class="line">    z = tf.add(tf.matmul(X, w), b, name=<span class="string">'z'</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.maximum(z, <span class="number">0.0</span>, name=<span class="string">'relu'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n_features = <span class="number">3</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_features), name=<span class="string">'X'</span>)</span><br><span class="line"><span class="comment"># 调用5次relu函数</span></span><br><span class="line">relus = [relu(X) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 将5次的结果累加</span></span><br><span class="line">output = tf.add_n(relus, name=<span class="string">'output'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_040.png" alt="ReLU的计算图(good)"></p><hr><p>还可以做得更好…</p><p>我们将之前讲过的命名域加进来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">''' 实现ReLU</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X: 输入样本</span></span><br><span class="line"><span class="string">    :return: 经过ReLU修正后的输出</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'relu'</span>):</span><br><span class="line">        [...]</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_041.png" alt="ReLU的计算图(better)"></p><hr><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>如果你想让计算图中不同的部分共享一个变量（比如CNN中卷积核的权值），一个可能的操作是将变量作为参数传递过去。但是，当计算图中需要共享的变量非常多时，将变得十分麻烦。</p><p>TensorFlow有一个更好的解决方案是，使用<code>get_variable()</code>函数来创建（或复用）共享变量。<br>而选择创建还是选择复用则是由当前的变量域<code>variable_scope()</code>决定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在relu变量域内创建threshold变量</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>):</span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>, shape=(), initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复用，设置reuse=True</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一种复用方式</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    scope.reuse_variables() <span class="comment"># 调用scope的reuse_variables方法</span></span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="复用ReLU的阈值"><a href="#复用ReLU的阈值" class="headerlink" title="复用ReLU的阈值"></a>复用ReLU的阈值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="comment"># 存在则复用，不存在则创建</span></span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>, shape=(), initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">    [...]                   </span><br><span class="line">    <span class="keyword">return</span> tf.maximum(z, threshold, name=<span class="string">"max"</span>)</span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_features), name=<span class="string">'X'</span>)</span><br><span class="line">relus = []</span><br><span class="line"><span class="keyword">for</span> relu_index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 第一次调用relu时reuse为0，则不复用选择创建变量</span></span><br><span class="line">    <span class="comment"># 后续调用relu则会选择复用变量</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>, reuse=(relu_index &gt;= <span class="number">1</span>)) <span class="keyword">as</span> scope:</span><br><span class="line">        relus.append(relu(X))</span><br><span class="line">output = tf.add_n(relus, name=<span class="string">'output'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_042.png" alt="5个ReLUs共享threshold变量"></p><hr><h3 id="复用CNN卷积层参数"><a href="#复用CNN卷积层参数" class="headerlink" title="复用CNN卷积层参数"></a>复用CNN卷积层参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">input_images = tf.placeholder(tf.float32, shape = (<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了一层卷积神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu</span><span class="params">(input, kernel_shape, bias_shape)</span>:</span></span><br><span class="line">    <span class="comment"># 创建名为weights的变量</span></span><br><span class="line">    weights = tf.get_variable(<span class="string">"weights"</span>, kernel_shape, initializer=tf.random_normal_initializer())</span><br><span class="line">    <span class="comment"># 创建名为biases的变量</span></span><br><span class="line">    biases = tf.get_variable(<span class="string">"biases"</span>, bias_shape, initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">    conv = tf.nn.conv2d(input, weights, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(conv + biases)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_image_filter</span><span class="params">(input_images)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"conv1"</span>):</span><br><span class="line">        <span class="comment"># 在名为conv1的variable scope下调用一层神经网络，对应的参数名为</span></span><br><span class="line">        <span class="comment"># "conv1/weights", "conv1/biases"</span></span><br><span class="line">        relu1 = conv_relu(input_images, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"conv2"</span>):</span><br><span class="line">        <span class="comment"># 在名为conv2的variable scope下调用一层神经网络，对应的参数名为</span></span><br><span class="line">        <span class="comment"># "conv2/weights", "conv2/biases"</span></span><br><span class="line">        <span class="keyword">return</span> conv_relu(relu1, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"image_filter"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    result1 = my_image_filter(input_images)</span><br><span class="line">    scope.reuse_variables() <span class="comment"># 复用变量</span></span><br><span class="line">    result2 = my_image_filter(input_images)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    image = np.random.rand(<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line">    result1 = sess.run(result1, feed_dict=&#123;input_images: image&#125;)</span><br><span class="line">    result2 = sess.run(result2, feed_dict=&#123;input_images: image&#125;)</span><br><span class="line">    print(result2.all() == result1.all())</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">True</span> </span><br><span class="line"><span class="comment"># 说明第二次的参数没有重新初始化，而是复用了第一次的参数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> hands-on ML </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用WebIDE搭建Hexo云端写作环境</title>
      <link href="/posts/use-hexo-on-coding-webIDE/"/>
      <url>/posts/use-hexo-on-coding-webIDE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于学习的需要，现在日常使用Ubuntu系统。但是，之前hexo的写作环境是搭建在Win10系统里的，如果想在Ubuntu系统里写博客的话，又得重新搭建环境，耗时耗力！</p><p>本着<code>Setup Once, Write Anywhere</code>的原则，便开始寻找一劳永逸的方法。</p><p>因为本博客是托管在<a href="https://pages.coding.net/" target="_blank" rel="noopener">Coding Pages</a>上的，所以首先看看Coding有没有解决方案。幸运的是，Coding有一款产品叫<a href="https://ide.coding.net/index" target="_blank" rel="noopener">Coding webIDE</a>满足我们的需求！</p><a id="more"></a><blockquote><p>Coding WebIDE 是 Coding 自主研发的在线集成开发环境 (IDE)。用户可以通过 WebIDE 创建项目的工作空间, 进行在线开发, 调试等操作。同时 WebIDE 集成了 Git 代码版本控制, 用户可以选择 Coding、GitHub、BitBucket、Git@OSC 等任意的代码仓库。 WebIDE 还提供了分享开发环境的功能, 用户可以保存当前的开发环境, 分享给团队的其他成员。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>最好有hexo、git、ubuntu等的使用经验</li><li>若没有coding.net的账号，可以<a href="https://coding.net" target="_blank" rel="noopener">点此注册</a></li><li>完善个人资料，即可免费成为<code>银牌会员</code><br>注：银牌会员可以使用一个webIDE工作空间，配置：CPU×1，内存256M，磁盘空间2G</li></ul><h2 id="新建工作空间"><a href="#新建工作空间" class="headerlink" title="新建工作空间"></a>新建工作空间</h2><h3 id="新建工作空间-1"><a href="#新建工作空间-1" class="headerlink" title="新建工作空间"></a>新建工作空间</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_024.png" alt="新建工作空间"></p><h3 id="选择空项目"><a href="#选择空项目" class="headerlink" title="选择空项目"></a>选择空项目</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_025.png" alt="选择空项目"></p><h3 id="填写项目信息并选择配置"><a href="#填写项目信息并选择配置" class="headerlink" title="填写项目信息并选择配置"></a>填写项目信息并选择配置</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_026.png" alt="填写项目信息并选择配置"></p><h3 id="运行工作空间"><a href="#运行工作空间" class="headerlink" title="运行工作空间"></a>运行工作空间</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_028.png" alt="运行工作空间"></p><h2 id="配置工作空间"><a href="#配置工作空间" class="headerlink" title="配置工作空间"></a>配置工作空间</h2><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>点击右侧边栏的<code>Environments</code>选项卡，然后选择使用<code>ide-ttf-hexo</code>环境。</p><p><img src="https://tuchuang001.com/images/2017/11/23/Screenshotfrom2017-11-2317-14-27a3c0a.png" alt="配置hexo环境"></p><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;Your Email&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure><h3 id="配置npm"><a href="#配置npm" class="headerlink" title="配置npm"></a>配置npm</h3><p>hexo的插件需要通过npm安装，换国内的源比较快<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><p>在<code>workspace</code>（即<code>hexo-cloud</code>）目录下，执行下列命令初始化hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>至此，hexo环境已经搭好，并成功初始化！</p><h2 id="预览博客"><a href="#预览博客" class="headerlink" title="预览博客"></a>预览博客</h2><p>写好文章之后，通常需要使用命令<code>hexo s</code>预览博客效果。<br>在本地的话，直接在地址栏输入<code>http://localhost:4000</code>即可预览。<br>但是在云端要怎么访问呢？</p><p>方法是，点击右侧边栏的<code>Access URL</code>选项卡，然后在<code>Port</code>选择使用<code>4000</code>端口。<br>然后点击添加<code>+</code>，会生成一个临时链接（有效期为1个小时），访问该链接即可预览博客。<br><img src="https://tuchuang001.com/images/2017/11/23/Selection_030.png" alt="预览博客"></p><h2 id="（可选）导入原有博客"><a href="#（可选）导入原有博客" class="headerlink" title="（可选）导入原有博客"></a>（可选）导入原有博客</h2><p>上述操作是在webIDE里新建一个hexo博客，但是如何导入已有的博客呢？</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>右键点击文件树空白处，可以选择上传文件。（但是好像不能上传整个目录）</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>由于每次更新博客之后，我都会把博客文件备份在coding的仓库里。所以，现在只需把该仓库clone到webIDE中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 复制原有的博客文件到文件夹 hexo_cloud/blog_backup 下</span><br><span class="line">git clone https://git.coding.net/orzyt/blog_backup.git</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 删除之前初始化的博客文件</span><br><span class="line">sudo rm -rf blog/*</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将blog_backup中的所有文件移到blog中</span><br><span class="line">sudo mv blog_backup/* blog_backup/.[^.]* blog/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装原有博客所依赖的插件</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webIDE </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hands-on Machine learning 之 机器学习概览</title>
      <link href="/posts/hands-on-ml-the-machine-learning-landscape/"/>
      <url>/posts/hands-on-ml-the-machine-learning-landscape/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h2><p>在1959年， <a href="http://en.wikipedia.org/wiki/Arthur_Samuel" target="_blank" rel="noopener">Arthur Samuel</a> 给机器学习定义如下：</p><blockquote><p> [Machine Learning is the] field of study that gives computers the ability to learn without being explicitly programmed.—Arthur Samuel, 1959</p></blockquote><p>Arthur Samuel是美国计算机游戏和人工智能领域的先驱之一。在IBM的时候，他开发出的西洋跳棋程序被认为是世界上第一个自学习程序。Samuel让该程序自己和自己下棋，很快它就习得了在哪些情况下赢的机会比较大，从而可以不断提高自己的棋艺。最终，该程序的棋艺已经远远超过Samuel。</p><p>Samuel这段话的意思是说，“<strong>机器学习是这样的一个研究领域，在没有显式编码的情况下赋予计算机学习的能力。</strong>”虽然这个定义看上去是挺不错的，但是却有点含糊不清。</p><a id="more"></a><p>后来在1998年， <a href="https://en.wikipedia.org/wiki/Tom_M._Mitchell" target="_blank" rel="noopener">Tom Mitchell</a>在他的著作<a href="https://www.amazon.com/Machine-Learning-Tom-M-Mitchell/dp/0070428077" target="_blank" rel="noopener">《Machine Learning 》</a>中给出了一个被广泛引用且更加正式的定义：</p><blockquote><p> A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.—Tom Mitchell, 1997</p></blockquote><p>这段话是说，“<strong>如果一个计算机程序在任务T中以P为度量的性能从经验E中得到了提升，那么可以说该程序从与某类任务T和性能度量P有关的经验E中进行了学习。</strong>” </p><p>根据该定义，一个机器学习问题必须具备三个要素：</p><ul><li><strong>任务（Tasks）</strong></li><li><strong>性能度量（Performance Measure）</strong></li><li><strong>训练经验（Training Experience）</strong></li></ul><p>以垃圾邮件过滤器（spam filter）为例，该程序的任务是标记垃圾邮件，性能度量可以是正确分类的比例，训练经验通常是包含正常邮件和垃圾邮件的训练数据集。</p><h2 id="为什么要使用机器学习？"><a href="#为什么要使用机器学习？" class="headerlink" title="为什么要使用机器学习？"></a>为什么要使用机器学习？</h2><p>考虑如何构建一个垃圾邮件过滤器。</p><h3 id="使用传统方式"><a href="#使用传统方式" class="headerlink" title="使用传统方式"></a>使用传统方式</h3><p><img src="https://tuchuang001.com/images/2017/11/05/d84888bdf33ee66725e1bda704a73eed.jpg" alt=""></p><p>首先人工提取垃圾邮件中的特征（比如一些经常出现的单词或短语），然后总结成“规则”写进代码中。若一封邮件满足其中某些规则，则将其标记为垃圾邮件。</p><p>弊端在于：随着时间的推移，程序中复杂、冗长的“规则”将变得难以维护。</p><h3 id="使用机器学习"><a href="#使用机器学习" class="headerlink" title="使用机器学习"></a>使用机器学习</h3><p><img src="https://tuchuang001.com/images/2017/11/05/53455b51d6df2b84f0970d44ca346f43.jpg" alt=""></p><p>基于机器学习的方法可以自动地从训练数据中学习垃圾邮件的特征，该过程无需过多的人工操作。</p><p>优点在于：程序通常更短、更容易维护，且准确率更高。</p><p>一般来说，机器学习擅长以下几个方面：</p><ul><li><strong>已存在的解法需要过多的人工操作，或者手动维护一长串的“规则”。</strong>例如，垃圾邮件的过滤；</li><li><strong>对于非常复杂的问题，传统方式通常不能够有效地解决。</strong>例如，语音识别问题；</li><li><strong>能够自动适应复杂多变的外部环境。</strong>例如，机器学习系统可以自动适应新数据；</li><li><strong>对复杂问题和大规模数据有很好的洞察能力。</strong>例如，可以发现数据中潜在的模式。</li></ul><h2 id="机器学习系统的类型"><a href="#机器学习系统的类型" class="headerlink" title="机器学习系统的类型"></a>机器学习系统的类型</h2><h3 id="有-无监督学习"><a href="#有-无监督学习" class="headerlink" title="有/无监督学习"></a>有/无监督学习</h3><p>根据在训练过程中得到的监督类型和数量，通常可以分为：</p><h4 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h4><p>在<strong>有监督学习（supervised learning）</strong>中，每一个训练数据都带有<strong>标签（labels）</strong>。比如，在垃圾邮件问题中，训练数据中的每封邮件都会带上是否是垃圾邮件（spam or ham）的标签。</p><p>有监督学习一般分为以下两类：</p><ul><li><strong>分类（classification）</strong></li></ul><p>比如，将邮件按是否是垃圾邮件进行分类。通常，该问题的标签是离散型数据。</p><p><img src="https://tuchuang001.com/images/2017/11/05/b1f3d44377279694e881806810f83e44.jpg" alt=""></p><ul><li><strong>回归（regression）</strong></li></ul><p>比如，根据车的一系列特征预测车的价格是多少。通常，该问题的标签是连续型数据。</p><p><img src="https://tuchuang001.com/images/2017/11/05/5e635c85e4335d577dce358f003f0230.jpg" alt=""></p><p>一些比较重要的有监督学习算法：</p><ul><li>K近邻（k-Nearest Neighbors）</li><li>线性回归（Linear Regression）</li><li>对数几率回归（Logistic Regression）</li><li>支持向量机（SVMs，Support Vector Machines）</li><li>决策树和随机森林（Decision Trees and Random Forests）</li><li>神经网络（Neural networks）</li></ul><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>在<strong>无监督学习（unsupervised learning）</strong>中，训练数据都是无标签的。</p><p>一般有以下几类任务：</p><ul><li><strong>聚类（Clustering）</strong></li></ul><p>比如，通过计算样本之间的相似性，将其聚拢成一个个簇。使得簇内样本的相似度高，簇外样本的相似度低。</p><p><img src="https://tuchuang001.com/images/2017/11/05/289e3e988536a156b3a04c331b773ec7.jpg" alt=""></p><ul><li><strong>可视化与降维（Visualization and dimensionality reduction）</strong></li></ul><p>比如，将高维的数据降维到低维空间（二维或三维），使得可以进行数据可视化。</p><p><img src="https://tuchuang001.com/images/2017/11/05/e85fc01f835edefaa407455b7a619f11.jpg" alt=""></p><ul><li><strong>异常检测（anomaly detection）</strong></li></ul><p>比如，检测信用卡中的非法交易、剔除数据中的异常点。</p><p><img src="https://tuchuang001.com/images/2017/11/05/9e028aacfbe2c58091bfedba9fdd19d6.jpg" alt=""></p><ul><li><strong>关联规则学习（association rule learning）</strong></li></ul><p>比如，在大量购物记录中挖掘出各个商品之间的购买关系。</p><p><img src="https://tuchuang001.com/images/2017/11/05/dc59dc05ed31036b7ebd444017adbd8f.jpg" alt=""></p><p>一些比较重要的无监督算法：</p><ul><li>聚类（Clustering）<ul><li>k均值（k-Means）</li><li>层序聚类分析（HCA，Hierarchical Cluster Analysis ）</li><li>期望最大化（EM，Expectation Maximization）</li></ul></li><li>可视化与降维（Visualization and dimensionality reduction）<ul><li>主成分分析（PCA，Principal Component Analysis ）</li><li>核PCA（Kernel PCA）</li><li>局部线性嵌入（LLE，Locally-Linear Embedding）</li><li>t分布随机领域嵌入（t-SNE，t-distributed Stochastic Neighbor Embedding）</li></ul></li><li>关联规则学习（Association rule learning）<ul><li>Apriori</li><li>Eclat</li></ul></li></ul><h4 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h4><p>在<strong>半监督学习（semi-supervised learning）</strong>中，训练数据通常由<strong>大量无标签数据</strong>和<strong>少量带标签数据</strong>构成。</p><p>比如，当你把一张家庭照上传到Google Photos，便可以自动识别出在哪些照片中出现了人物A，在哪些照片中出现了人物B，这是无监督聚类的过程。但是，如果想要知道人物A、人物B叫什么的话，那么只需要给每个人物打上一个”姓名“标签即可，这是有监督的过程。</p><p>因此，只需标记少量样本，便可以对每张照片的每个人物打上标签。</p><p><img src="https://tuchuang001.com/images/2017/11/05/6abc78a655c67db16fd2c7a392719c5f.jpg" alt=""></p><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p><strong>强化学习（Reinforcement Learning）</strong>是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。</p><p>在该问题中，学习系统被称为<strong>agent</strong>，它可以观察<strong>环境（environment）</strong>，执行<strong>动作（actions）</strong>，然后可以得到<strong>奖励（rewards）</strong>，最终学习到最优的<strong>策略（policy）</strong>。</p><p><img src="https://tuchuang001.com/images/2017/11/05/d4222a249b2d675a413dc1f0e4845d51.jpg" alt=""></p><h3 id="批量-在线学习"><a href="#批量-在线学习" class="headerlink" title="批量/在线学习"></a>批量/在线学习</h3><p>该分类标准是根据系统能否从连续的数据流中进行学习。</p><ul><li><strong>批量学习（Batching learning）</strong></li></ul><p>批量学习的每次训练都需要使用整个数据集，该过程通常是<strong>离线（offline）</strong>进行的。</p><p>模型离线训练完毕后，再部署到生产环境中去，在运行过程中模型也不会再进行训练。如果批量学习系统需要适应新的数据，那么必须重新进行训练，训练的数据由旧数据和新数据组成，训练完毕后再部署上去。</p><p>批量学习的过程非常消耗计算资源，通常是每隔24h或更久训练一次。</p><ul><li><strong>在线学习（Online learning）</strong></li></ul><p>在在线学习的过程中，可以依次递送数据（单个或者小批量）来逐步地训练系统。</p><p>该方法特别适用于需要不断接收连续的数据流，或者需要不断适应变化数据的系统。同时，在线学习也适用于计算资源缺乏的环境，因为通常系统学习完新数据后，便不再需要保留该数据，从而可以节约巨大的存储空间。</p><p><img src="https://tuchuang001.com/images/2017/11/05/2c77418e6ee25717f0e3103209e3dcba.jpg" alt=""></p><p>在线学习也常被用来进行<code>out-of-core learning</code>，使得系统可以在巨大的数据集（不能一次性放入机器的内存中）上进行训练。每次训练只载入数据集的部分数据，不断重复，直到所有数据都被处理过。</p><p>对于在线学习来说，一个很重要的参数是<strong>学习率（learning rate）</strong>。若学习率过高，那么系统将会更加适应新的数据，而更快遗忘旧的数据。若学习率过低，那么系统将会学习得很慢，但同时对新数据中的噪声或数据中没有代表性的样本不会太敏感。</p><p>在线学习面临的一个挑战是，一旦”坏数据“被输入到系统中，那么系统的性能将会逐渐降低。为了降低该风险，可以不断地监测系统，在性能下降时恢复到之前正常的状态；也可以使用异常检测算法对数据进行检测，没有问题后再输入到系统中去。</p><h3 id="基于实例-基于模型的学习"><a href="#基于实例-基于模型的学习" class="headerlink" title="基于实例/基于模型的学习"></a>基于实例/基于模型的学习</h3><p>该分类标准是系统是如何对未知数据进行<strong>泛化（generalize）</strong>。</p><ul><li><strong>基于实例的学习（Instance-based learning）</strong></li></ul><p>基于实例的学习只是简单地把训练数据存储起来，当遇到新的查询实例时，根据相似性计算规则从已知数据中找到相似的实例，然后对其进行泛化预测。例如，k近邻算法。</p><p><img src="https://tuchuang001.com/images/2017/11/05/aab4a3831ca8e8a0be55969771415327.jpg" alt=""></p><ul><li><strong>基于模型的学习（Mode-based learning）</strong></li></ul><p>基于模型的学习是从训练数据中建立一个<strong>模型（model）</strong>，然后使用该模型对未知数据进行泛化预测。例如，支持向量机。</p><p><img src="https://tuchuang001.com/images/2017/11/05/1f521df80ace687224d1262b900f952f.jpg" alt=""></p><h2 id="机器学习的主要挑战"><a href="#机器学习的主要挑战" class="headerlink" title="机器学习的主要挑战"></a>机器学习的主要挑战</h2><h3 id="训练数据方面"><a href="#训练数据方面" class="headerlink" title="训练数据方面"></a>训练数据方面</h3><ul><li><strong>训练数据的数量不够</strong></li></ul><p>训练数据的数量在一定程度上也影响最终模型的效果，特别是采用深度学习等方法，其所需数据量通常比较大。对于图片数据来说，可以通过平移、翻转、裁剪、加噪声等方式进行<strong>数据增强（data augmentation）</strong>。</p><ul><li><strong>训练数据的代表性不足</strong></li></ul><p>如果训练数据的代表性不足，通常训练出来的模型的泛化能力也比较弱。在数据采样的时候，如果样本数量较少，那么可能出现<strong>采样噪声（sampling noise）</strong>的问题；若采样方式错误，即使样本数量很多也可能不具有代表性，依然会出现<strong>采样偏差（sampling bias）</strong>的问题。</p><ul><li><strong>训练数据的质量不好</strong></li></ul><p>如果训练数据中充满了错误、异常点、噪声等等，那么训练出的模型也很难检测出原本真实数据中潜在的模式。所以，<strong>数据清洗（data cleaning）</strong>是整个机器学习过程中不可缺少的一个环节，其结果质量直接关系到模型效果和最终结论。</p><ul><li><strong>训练数据的特征与问题不相关</strong></li></ul><p><strong>特征工程（feature engineering）</strong>其本质上是一项工程活动，它目的是最大限度地从原始数据中提取特征以供算法和模型使用。一般认为，数据和特征决定了机器学习的上限，而模型和算法只能逼近这个上限而已。特征工程一般包括<strong>特征选择（feature selection）</strong>、<strong>特征提取（feature extraction）</strong>等部分。</p><h3 id="算法模型方面"><a href="#算法模型方面" class="headerlink" title="算法模型方面"></a>算法模型方面</h3><ul><li><strong>过拟合（overfitting）问题</strong></li></ul><p>模型复杂度过高，训练数据过少，训练误差虽小，但测试误差大。</p><p>一般通过<strong>正则化（generalization）</strong>方式解决，本质上是降低模型的复杂度。</p><ul><li><strong>欠拟合（underfitting）问题</strong></li></ul><p>模型复杂度过低，不能很好地拟合所有的数据，训练误差大。</p><p><img src="https://tuchuang001.com/images/2017/11/05/750fc8894f1a5daa7d30071878f2d708.jpg" alt=""></p><h2 id="测试和验证"><a href="#测试和验证" class="headerlink" title="测试和验证"></a>测试和验证</h2><p>评估一个模型的好坏，可以测试该模型对新样本的泛化能力。</p><p>通常将数据集分为两部分：<strong>训练集（training set）</strong>和<strong>测试集（test set）</strong>。其中，训练集用于模型参数的拟合，测试集用于对已经训练好的模型进行性能评估。</p><p>如果算法中存在<strong>超参数（hyperparameter）</strong>，那么可以从训练集中再划分出<strong>验证集（validation set）</strong>来进行调参。</p><p>一种常用的验证方式是：<strong>k折交叉验证（k-fold cross validation）</strong>。k折交叉验证将所有训练样本分成K份，一般每份样本的数量相等或相差不多。取一份作为测试样本，剩余K-1份作为训练样本。这个过程重复K次，取平均值作为最终的验证结果。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> hands-on ML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode501 Find Mode in Binary Search Tree</title>
      <link href="/posts/leetcode501-find-mode-in-binary-search-tree/"/>
      <url>/posts/leetcode501-find-mode-in-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary search tree (BST) with duplicates, find all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics" target="_blank" rel="noopener">mode(s)</a>) (the most frequently occurred element) in the given BST.</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Note:</strong> If a tree has more than one mode, you can return them in any order.</p><p><strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given BST [1,null,2,2],</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出二叉搜索树中的众数。</p><p>直观的想法是，遍历一遍二叉搜索树，用哈希表来记录每个数出现的次数，维护一个最大值，最后遍历哈希表找出众数即可。这个方法需要申请额外的空间，并且也没有用到BST的性质。</p><p>根据二叉搜索树的性质，我们使用中序遍历其实可以得到一个有序的结果。那么问题就转化为：给一个单调递增的数组，找出其中的众数。该问题只需要遍历一遍数组，将每个元素与其前驱元素比较是否相等，然后维护出现次数的最大值，不需要额外空间即可找到众数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>哈希表：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Map;</span><br><span class="line">    <span class="keyword">int</span> maxCnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        maxCnt = max(maxCnt, ++Map[root-&gt;val]);</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        Map.clear();</span><br><span class="line">        maxCnt = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: Map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.second == maxCnt) &#123;</span><br><span class="line">                ans.push_back(x.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>无需额外空间：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxCnt, curCnt;</span><br><span class="line">    TreeNode* preNode;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(root-&gt;left, ans);</span><br><span class="line">        <span class="keyword">if</span> (preNode) curCnt = (preNode-&gt;val == root-&gt;val) ? curCnt + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (curCnt &gt;= maxCnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curCnt &gt; maxCnt) ans.clear();</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            maxCnt = curCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = root;</span><br><span class="line">        inOrder(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        preNode = <span class="literal">nullptr</span>;</span><br><span class="line">        maxCnt = <span class="number">0</span>, curCnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        inOrder(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode479 Largest Palindrome Product</title>
      <link href="/posts/leetcode479-largest-palindrome-product/"/>
      <url>/posts/leetcode479-largest-palindrome-product/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Find the largest palindrome made from the product of two n-digit numbers.</p><p>Since the result could be very large, you should return the largest palindrome mod 1337.</p><p><strong>Note:</strong></p><p>The range of n is [1,8].</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">2</span><br><span class="line">Output: </span><br><span class="line">987</span><br><span class="line">Explanation: </span><br><span class="line">99 x 91 = 9009, 9009 % 1337 = 987</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出两个$n$位数乘积中最大的回文数。</p><p>首先，乘积的范围为$[10^{n-1} \cdot 10^{n-1}, (10^{n} - 1) \cdot (10^{n} - 1)]$，暴力的方法是遍历每一个数，检查是否为回文的，然后记录其中最大值。复杂度：$\mathcal{O}(10^{2n})$</p><p>一个可以优化的地方是，不再枚举所有的数，而是枚举所有的回文数，然后再判断这个回文数能否被分解为两个$n$位数的乘积。基于一个事实，两个$n$位数$(2 \le n \le 8)$乘积中最大的回文数的位数为$2n$位（本弱不会证明…）。所以只需枚举回文数的左半部分，然后再构造出回文数判断。复杂度：$\mathcal{O}(10^{1.5n})$</p><p>虽然理论复杂度比较高，但是因为是从大到小枚举，很快便能得到答案，实测只跑了300+ms。</p><p>当然，这题还可以本地打表交上去。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">palindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = x;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPalindrome</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="built_in">pow</span>(<span class="number">10</span>, n - <span class="number">1</span>), r = <span class="built_in">pow</span>(<span class="number">10</span>, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; --i) &#123; <span class="comment">// 枚举回文数左半部分</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p = palindrome(i); <span class="comment">// 构造回文数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = r; j * j &gt;= p; --j) &#123; </span><br><span class="line">                <span class="comment">// 判断p能否分解为两个n位数的乘积</span></span><br><span class="line">                <span class="comment">// j为其中较大者，故只需枚举到j * j &gt;= p</span></span><br><span class="line">                <span class="keyword">if</span> (p % j == <span class="number">0</span>) <span class="keyword">return</span> p % <span class="number">1337</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode437 Path Sum III</title>
      <link href="/posts/leetcode437-path-sum-iii/"/>
      <url>/posts/leetcode437-path-sum-iii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树中有多少条权值和为<code>sum</code>的路径。</p><p>遍历每个结点，以该结点作为根结点DFS搜索答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以root为根结点，路径和为sum的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> find(root-&gt;left, sum - root-&gt;val) <span class="comment">// 找左儿子中权值和为(sum - root-&gt;val)的路径数</span></span><br><span class="line">             + find(root-&gt;right, sum - root-&gt;val) </span><br><span class="line">             + (sum == root-&gt;val); <span class="comment">// 相等说明找到一条路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> find(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode415 Add Strings</title>
      <link href="/posts/leetcode415-add-strings/"/>
      <url>/posts/leetcode415-add-strings/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p><p><strong>Note:</strong></p><ol><li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li><li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li><li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li><li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">num1 = &quot;123&quot;</span><br><span class="line">num2 = &quot;456&quot;</span><br><span class="line">Output:</span><br><span class="line">&quot;579&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给两个以字符串表示的非负数<code>num1</code>和<code>num2</code>，返回其和。</p><p>模拟一遍加法的过程即可。</p><p>$sum[i] = (num1[i] + num2[i] + carry[i-1])  \% 10$</p><p>$carry[i] = (num1[i] + num2[i] + carry[i-1]) / 10$ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> a, b, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num1.size(), m = num2.size(), len = max(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            a = i &lt; n ? num1[n<span class="number">-1</span>-i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            b = i &lt; m ? num2[m<span class="number">-1</span>-i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            ans += <span class="keyword">char</span>(((a + b + carry) % <span class="number">10</span>) + <span class="string">'0'</span>);</span><br><span class="line">            carry = (a + b + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) ans += <span class="keyword">char</span>(carry + <span class="string">'0'</span>);</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode414 Third Maximum Number</title>
      <link href="/posts/leetcode414-third-maximum-number/"/>
      <url>/posts/leetcode414-third-maximum-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a <strong>non-empty</strong> array of integers, return the <strong>third</strong> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: The third maximum is 1.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Note that the third maximum here means the third maximum distinct number.</span><br><span class="line">Both numbers with value 2 are both considered as second maximum.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出数组中第三小的数。</p><p>模拟题。</p><p>如果一个数大于当前第一大数，那么更新第一、二、三大数。</p><p>如果只大于当前第二大数，那么更新第二、三大数。</p><p>如果只大于当前第三大数，那么更新第三大数。</p><p>注意相等情况的处理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> oo = <span class="number">1e18</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> firstNum = -oo, secondNum = -oo, thirdNum = -oo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= firstNum) &#123; <span class="comment">// 等于的情况也要归进来，不然会被拿去更新第二、三大数。</span></span><br><span class="line">                <span class="keyword">if</span> (x == firstNum) <span class="keyword">continue</span>;</span><br><span class="line">                thirdNum = secondNum;</span><br><span class="line">                secondNum = firstNum;     </span><br><span class="line">                firstNum = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= secondNum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == secondNum) <span class="keyword">continue</span>;</span><br><span class="line">                thirdNum = secondNum;</span><br><span class="line">                secondNum = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= thirdNum) thirdNum = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (thirdNum == -oo) ? firstNum : thirdNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode413 Arithmetic Slices</title>
      <link href="/posts/leetcode413-arithmetic-slices/"/>
      <url>/posts/leetcode413-arithmetic-slices/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure><p>The following sequence is not arithmetic.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [1, 2, 3, 4]</span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">for 3 arithmetic slices in A: </span><br><span class="line">[1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个序列，找出其中有多少个连续的子序列是等差序列。</p><hr><p>一个直观的想法是，双指针扫一遍数组，每次确定一个最长的等差序列$a[l..r]$，那么这个等差序列对答案的贡献是 $(len - 2) * (len - 1) / 2$，其中$len = r - l + 1$。</p><hr><p>另一个做法是使用动态规划，设$dp[i]$表示以$a[i]$结尾的等差序列的个数。</p><p>如果$a[i] - a[i-1] == a[i-1] - a[i-2]$，那么有$dp[i] = dp[i-1] + 1$，否则$dp[i] = 0$。</p><p>其中$dp[i] = dp[i-1] + 1$是怎么来的呢？</p><p>根据条件$a[i] - a[i-1] == a[i-1] - a[i-2]$我们知道，所有以$a[i-1]$结尾的等差序列，现在加上$a[i]$之后依然是等差序列。同时，还新增一个只有3个元素的等差序列$a[i-2 .. i]$，所以$dp[i] = dp[i-1] + 1$。</p><p>最后，答案$ans = \sum^{n-1}_{i=0} {dp[i]}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>双指针：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 小于3个元素，答案为0</span></span><br><span class="line">        <span class="keyword">int</span> diff = A[<span class="number">1</span>] - A[<span class="number">0</span>]; <span class="comment">// 当前序列的公差</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2</span>, len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; n &amp;&amp; r &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 更新等差序列的右端点r</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; A[r] - A[r - <span class="number">1</span>] == diff) r++;</span><br><span class="line">            len = r - l; <span class="comment">// 当前等差序列为a[l..r-1]</span></span><br><span class="line">            <span class="comment">// 计算该序列贡献的答案</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">3</span>) ans += (len - <span class="number">2</span>) * (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            l = r - <span class="number">1</span>; r++; <span class="comment">// 更新左右端点</span></span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> &lt; n) diff = A[l + <span class="number">1</span>] - A[l]; <span class="comment">// 更新公差</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>DP：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>); <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">2</span>] = (A[<span class="number">2</span>] - A[<span class="number">1</span>] == A[<span class="number">1</span>] - A[<span class="number">0</span>]);</span><br><span class="line">        ans += dp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode367 Valid Perfect Square</title>
      <link href="/posts/leetcode367-valid-perfect-square/"/>
      <url>/posts/leetcode367-valid-perfect-square/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a positive integer <em>num</em>, write a function which returns True if <em>num</em> is a perfect square else False.</p><p><strong>Note:</strong> <strong>Do not</strong> use any built-in library function such as <code>sqrt</code>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Returns: True</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否是完全平方数。</p><p>和这题<a href="/2017/06/11/LeetCode69-Sqrt(x)/">LeetCode69 Sqrt(x)</a>几乎一模一样。</p><p>只需在返回的时候判断二分搜索出来的答案，其平方之后还会不会与num相等即可。复杂度$\mathcal{O}(logn)$</p><hr><p>还有一种解法是，根据奇数和通项公式：$1+3+5+ \cdots + (2n-1) = n^2$ ，把num每次 -1、-3、-5…，看最后能否正好减到零。复杂度$\mathcal{O}(\sqrt n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = num, m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (m * m &lt;= num) l = m;</span><br><span class="line">            <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l * l == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode345 Reverse Vowels of a String</title>
      <link href="/posts/leetcode345-reverse-vowels-of-a-string/"/>
      <url>/posts/leetcode345-reverse-vowels-of-a-string/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">Output:</span><br><span class="line">&quot;holle&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个字符串，只翻转字符串中的元音字符。</p><p>在普通的翻转中，加入对元音字符的判断，使得指针每次只能指向元音。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">'a'</span> || c == <span class="string">'e'</span> || c == <span class="string">'i'</span> || c == <span class="string">'o'</span> || c == <span class="string">'u'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !check(s[l])) l++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !check(s[r])) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode342 Power of Four</title>
      <link href="/posts/leetcode342-power-of-four/"/>
      <url>/posts/leetcode342-power-of-four/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">16</span><br><span class="line">Output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否是4的次幂。</p><p>做过这题<a href="/2017/02/02/LeetCode231-Power-of-Two/">LeetCode231 Power of Two</a>的话，应该知道怎么判断一个数是否是2的次幂。</p><p>4次幂数显然满足2次幂数的性质，进一步观察发现，4次幂数二进制下“1”的位置只能在第0、2、…等偶数位。</p><p>因此，4次幂数如果和<code>0x55555555</code>相与的话，可以得到非零数，这就剔除了那些是2次幂数但不是4次幂数的数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; !(num &amp; (num<span class="number">-1</span>)) &amp;&amp; (num &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode190 Reverse Bits</title>
      <link href="/posts/leetcode190-reverse-bits/"/>
      <url>/posts/leetcode190-reverse-bits/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Reverse bits of a given 32 bits unsigned integer.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">43261596 (represented in binary as 00000010100101000001111010011100)</span><br><span class="line">Output:</span><br><span class="line">964176192 (represented in binary as 00111001011110000010100101000000)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>翻转32bits无符号整数。</p><p>暴力的做法是，对称着遍历然后<code>swap</code>即可。</p><p>不过，还有类似<a href="/2017/09/01/LeetCode191-Number-of-1-Bits/">LeetCode191 Number of 1 Bits</a>的优雅做法 (ﾉﾟ∀ﾟ)ﾉ </p><p>比如，翻转32bits无符号整数<code>1001 1011 0101 0010 1001 1111 0001 0010</code></p><p>那么可以先每16位翻转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1001 1011 0101 0010] [1001 1111 0001 0010]</span><br><span class="line">                             X</span><br><span class="line">Output: [1001 1111 0001 0010] [1001 1011 0101 0010]</span><br></pre></td></tr></table></figure><p>再每8位翻转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1001 1111] [0001 0010] | [1001 1011] [0101 0010]</span><br><span class="line">                   X            |            X</span><br><span class="line">Output: [0001 0010] [1001 1111] | [0101 0010] [1001 1011]</span><br></pre></td></tr></table></figure><p>接着每4位翻转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:  [0001] [0010] | [1001] [1111] | [0101] [0010] | [1001] [1011]</span><br><span class="line">              X       |       X       |       X       |       X      </span><br><span class="line">Output: [0010] [0001] | [1111] [1001] | [0010] [0101] | [1011] [1001]</span><br></pre></td></tr></table></figure><p>然后每2位翻转 …（就不给出具体的过程啦）</p><p>最后每1位翻转即可得到答案 <code>0100 1000 1111 1001 0100 1010 1101 1001</code></p><p>如果有仔细阅读<a href="/2017/09/01/LeetCode191-Number-of-1-Bits/">LeetCode191 Number of 1 Bits</a> 这篇文章，代码应该不难实现 (～￣▽￣)～ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 当前比特位不相同</span></span><br><span class="line">            <span class="keyword">if</span> (((n &gt;&gt; l) &amp; <span class="number">1</span>) ^ ((n &gt;&gt; r) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">              <span class="comment">// 各自取反</span></span><br><span class="line">                n ^= (<span class="number">1</span> &lt;&lt; l);</span><br><span class="line">                n ^= (<span class="number">1</span> &lt;&lt; r);</span><br><span class="line">            &#125;</span><br><span class="line">            l++; r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode307 Range Sum Query-Mutable</title>
      <link href="/posts/leetcode307-range-sum-query-mutable/"/>
      <url>/posts/leetcode307-range-sum-query-mutable/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j</em> (<em>i</em> ≤ <em>j</em>), inclusive.</p><p>The <code>update(i, val)</code> function modifies nums by updating the element at index i to val.</p><p><strong>Note:</strong></p><ol><li>The array is only modifiable by the <em>update</em> function.</li><li>You may assume the number of calls to <em>update</em> and <em>sumRange</em> function is distributed evenly.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1, 3, 5]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要求对数组支持单点修改，区间查询操作。</p><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">树状数组</a> 模板题，修改、查询复杂度都是$\mathcal{O}(logn)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* sum;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            sum[i] += x;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += sum[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        fill(sum, sum + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        add(i + <span class="number">1</span>, val - sumRange(i, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(j + <span class="number">1</span>) - getSum(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode303 Range Sum Query-Immutable</title>
      <link href="/posts/leetcode303-range-sum-query-immutable/"/>
      <url>/posts/leetcode303-range-sum-query-immutable/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j</em> (<em>i</em> ≤ <em>j</em>), inclusive.</p><p><strong>Note:</strong></p><ol><li>You may assume that the array does not change.</li><li>There are many calls to <em>sumRange</em> function.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>查询数组的区间和。</p><p>其中数组元素不会改变，会有频繁的查询操作。</p><p>$\mathcal{O}(n)$预处理出前缀和，然后$\mathcal{O}(1)$查询即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode278 First Bad Version</title>
      <link href="/posts/leetcode278-first-bad-version/"/>
      <url>/posts/leetcode278-first-bad-version/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在$n$个版本的产品中，找出第一个坏版本。</p><p>有一个性质是，坏版本之后的版本都是坏版本。使用普通的二分搜索即可，如果当前版本是坏版本，那么减少上界，否则增加下界。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(m)) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode101 Symmetric Tree</title>
      <link href="/posts/leetcode101-symmetric-tree/"/>
      <url>/posts/leetcode101-symmetric-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,2,3,4,4,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,2,null,3,null,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一颗二叉树是否是对称的。</p><p>首先判断给定的二叉树是否是空树，空树也算是对称的。</p><p>然后判断左右子树是否是对称的。即判断左右子树的值是否相等，并且递归下去判断「左子树的左儿子」和「右子树的右儿子」是否是对称的，以及「左子树的右儿子」和「右子树的左儿子」是否是对称的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断左右子树是否相等</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两棵都是空树</span></span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 有一棵不是空树</span></span><br><span class="line">        <span class="keyword">if</span> (!l ^ !r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> l-&gt;val == r-&gt;val &amp;&amp; check(l-&gt;left, r-&gt;right) &amp;&amp; check(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode172 Factorial Trailing Zeroes</title>
      <link href="/posts/leetcode172-factorial-trailing-zeroes/"/>
      <url>/posts/leetcode172-factorial-trailing-zeroes/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer $n$, return the number of trailing zeroes in $n!$.<br><strong>Note:</strong> Your solution should be in logarithmic time complexity.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">10</span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求$n!$末尾零的个数。</p><p>不难发现，其末尾的零来源于$n!=1 × 2  × \cdots × n$这一乘法过程中产生了多少个$10$。而$10 = 2 × 5$，因此要统计其中有多少个$2$和多少个$5$，但是由于$2$的数量多于$5$的数量，故只需统计$5$的数量即可。</p><p>现在问题转化为：求$n!=1 × 2  × \cdots × n$中有多少个$5$。</p><p>显然，能被$5$整除的数至少能贡献$1$个$5$，若同时又能被$5^2$整除，则还可以再贡献一个$5$，若继续能被$5^3$整除，那么还可以再贡献一个$5$… 所以，$ans = \lfloor n / 5\rfloor + \lfloor n / 5^2\rfloor + \lfloor n / 5^3\rfloor + … $</p><p>算法时间复杂度：$\mathcal{O}(log_{5}n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            ans += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode669 Trim a Binary Search Tree</title>
      <link href="/posts/leetcode669-trim-a-binary-search-tree/"/>
      <url>/posts/leetcode669-trim-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">      3</span><br><span class="line">     / </span><br><span class="line">   2   </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>修剪一颗二叉搜索树，使其权值都位于$[L, R]$之间。</p><p>考虑任意一个结点node。</p><p>若其权值小于$L$，根据<code>BST</code>的性质（左子树上所有结点的值均小于它的根节点的值，右子树上所有结点的值均大于它的根节点的值），其左子树（包括node本身）应该被修剪掉，此时node结点应该由被修剪后的右子树替代（即使修剪后的右子树变成空树也无妨）。</p><p>同理，若其权值大于$R$，根据<code>BST</code>的性质，其右子树（包括node本身）应该被修剪掉，此时node结点应该由被修剪后的左子树替代。</p><p>若权值正好在$[L, R]$区间内，那么node结点不变，继续递归下去修剪左右子树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; L) <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; R) <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, L, R);            </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode671 Second Minimum Node In a Binary Tree</title>
      <link href="/posts/leetcode671-second-minimum-node-in-a-binary-tree/"/>
      <url>/posts/leetcode671-second-minimum-node-in-a-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes.</p><p>Given such a binary tree, you need to output the <strong>second minimum</strong> value in the set made of all the nodes’ value in the whole tree.</p><p>If no such second minimum value exists, output -1 instead.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line">     / \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The smallest value is 2, but there isn&apos;t any second smallest value.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一颗非空的二叉树，结点权值为非负数。这棵二叉树有一个特殊的性质：每个结点要么没有儿子结点，要么一定有两个儿子结点，并且两个儿子结点的权值都<strong>大等于</strong>该节点的权值。现在，要求出这颗二叉树中<strong>第二小的权值</strong>是多少，若不存在则输出“-1”。</p><p>根据其性质，显然<strong>最小值为根结点的权值</strong>。那么，第二小的权值就应该等于除了根结点权值外的那个最小值。</p><p>所以，从根结点开始，若当前节点权值等于根结点权值，那么继续$dfs$下去。直到不相等的时候，说明该权值有可能是候选答案，与当前最优答案取个$min$即可，并且此时也不用继续搜下去，根据其性质可知后代结点不可能是答案。</p><p>对于不存在的情况，一开始可以设置答案$ans$为无穷大（由于<code>val</code>是<code>int类型</code>，因此可以设置为<code>INT_MAX</code>）。若$dfs$结束之后，$ans$没有改变的话，说明不存在答案，此时输出“-1”即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> minVal, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == minVal) &#123;</span><br><span class="line">            dfs(root-&gt;left, minVal, ans);</span><br><span class="line">            dfs(root-&gt;right, minVal, ans);            </span><br><span class="line">        &#125; <span class="keyword">else</span> ans = min(ans, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        dfs(root, root-&gt;val, ans);</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode264 Ugly Number II</title>
      <link href="/posts/leetcode264-ugly-number-ii/"/>
      <url>/posts/leetcode264-ugly-number-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p><p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">10</span><br><span class="line">Output:</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>输出第$n$个“丑数”。</p><p>不难发现，<strong>任意一个“丑数”都是通过其之前某个“丑数”乘2、3或5得到的</strong>。</p><p>那么，我们就可以从初始条件$dp[1] = 1$开始递推出整个“丑数”序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1×2, …</span><br><span class="line">↑</span><br><span class="line">1×3, …</span><br><span class="line">↑</span><br><span class="line">1×5, …</span><br><span class="line">↑</span><br><span class="line">dp[2] = min(dp[1] * 2, dp[1] * 3, dp[1] * 5) = 2; </span><br><span class="line">同时指向“2”的指针右移一格;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1×2, 2×2, …</span><br><span class="line">     ↑</span><br><span class="line">1×3, 2×3, …</span><br><span class="line">↑</span><br><span class="line">1×5, 2×5, …</span><br><span class="line">↑</span><br><span class="line">dp[3] = min(dp[2] * 2, dp[1] * 3, dp[1] * 5) = 3; </span><br><span class="line">同时指向“3”的指针右移一格;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1×2, 2×2, 3×2…</span><br><span class="line">     ↑</span><br><span class="line">1×3, 2×3, 3×3…</span><br><span class="line">     ↑</span><br><span class="line">1×5, 2×5, 3×5…</span><br><span class="line">↑</span><br><span class="line">dp[4] = min(dp[2] * 2, dp[2] * 3, dp[1] * 5) = 4; </span><br><span class="line">同时指向“2”的指针右移一格;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1×2, 2×2, 3×2, 4×2…</span><br><span class="line">          ↑</span><br><span class="line">1×3, 2×3, 3×3, 4×3…</span><br><span class="line">     ↑</span><br><span class="line">1×5, 2×5, 3×5, 4×5…</span><br><span class="line">↑</span><br><span class="line">dp[5] = min(dp[3] * 2, dp[2] * 3, dp[1] * 5) = 5; </span><br><span class="line">同时指向“5”的指针右移一格;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1×2, 2×2, 3×2, 4×2, 5×2,…</span><br><span class="line">          ↑</span><br><span class="line">1×3, 2×3, 3×3, 4×3, 5×3,…</span><br><span class="line">     ↑</span><br><span class="line">1×5, 2×5, 3×5, 4×5, 5×5,…</span><br><span class="line">     ↑</span><br><span class="line">dp[6] = min(dp[3] * 2, dp[2] * 3, dp[2] * 5) = 6; </span><br><span class="line">注意到此时，dp[3] * 2 和 dp[2] * 3同时取到最小值，</span><br><span class="line">那么，指向“2”的指针和指向“3”的指针应该同时右移一格，</span><br><span class="line">不然得到的序列中将出现重复元素。</span><br></pre></td></tr></table></figure><p>以此类推，最终就可以得到答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> idx_2 = <span class="number">0</span>, idx_3 = <span class="number">0</span>, idx_5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = min(dp[idx_2] * <span class="number">2</span>, min(dp[idx_3] * <span class="number">3</span>, dp[idx_5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[idx_2] * <span class="number">2</span>) idx_2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[idx_3] * <span class="number">3</span>) idx_3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[idx_5] * <span class="number">5</span>) idx_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode263 Ugly Number</title>
      <link href="/posts/leetcode263-ugly-number/"/>
      <url>/posts/leetcode263-ugly-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p><p>Note that <code>1</code> is typically treated as an ugly number.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">10</span><br><span class="line">Output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数的质因数是否只有2、3、5。</p><p>模拟一遍，不断用2、3、5去整除num，看能否能被除尽。</p><p>注意特判非正数的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> factor[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: factor) <span class="keyword">while</span> (num % x == <span class="number">0</span>) num /= x;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode204 Count Primes</title>
      <link href="/posts/leetcode204-count-primes/"/>
      <url>/posts/leetcode204-count-primes/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Count the number of prime numbers less than a non-negative number, <strong>n</strong>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>统计前$n$个数中有多少个素数。</p><p>可以用<code>Eratosthenes筛法</code>或<code>Euler筛法</code>，详见<a href="/2015/02/24/Seive-Of-Prime-Numbers/">素数筛法</a>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span>* isPrime = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">        fill(isPrime, isPrime+n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>*i; j &lt; n; j += i) isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode202 Happy Number</title>
      <link href="/posts/leetcode202-happy-number/"/>
      <url>/posts/leetcode202-happy-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p><strong>Example: </strong>19 is a happy number</p><ul><li>$1^2 + 9^2 = 82$</li><li>$8^2 + 2^2 = 68$</li><li>$6^2 + 8^2 = 100$</li><li>$1^2 + 0^2 + 0^2 = 1$</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">19</span><br><span class="line">Output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否是“happy”的。</p><p>“happy”的定义是每次将数$n$替换为其各数位的平方和，若最终得到1，则该数为“happy”。</p><p>如果一个数是“happy”的，可以直接模拟一遍，看是否得到1。但如果不是“happy”的话，那么模拟将陷入死循环，进入到一个不包含1的圈里。</p><p><img src="https://tuchuang001.com/images/2017/09/02/CycleFinding4.png" alt=""></p><p>这里介绍一个<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd.27s_Tortoise_and_Hare" target="_blank" rel="noopener">Floyd判圈算法</a>，又称龟兔赛跑算法。该算法可以在有限状态机、迭代函数或者链表上判断是否存在环。如果从同一个起点(即使这个起点不在某个环上)，同时开始以不同速度前进的两个指针最终相遇，那么可以判定存在一个环。</p><p>我们假设龟以1×的速度，兔以2×的速度从起点出发。若途中不存在圈，那么兔将率先到达终点。但是如果存在圈的话，龟兔便会在圈中相遇。此时兔必然是领先龟数圈，然后从后方追上龟。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算数位平方和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            ans += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = n, slow = n; <span class="comment">// 相同起点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = cal(slow); <span class="comment">// 模拟龟，1×速度</span></span><br><span class="line">            fast = cal(cal(fast)); <span class="comment">// 模拟兔，2×速度</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);  <span class="comment">// 直到相遇</span></span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>; <span class="comment">// 为1则在终点相遇，否则在圈中相遇</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode191 Number of 1 Bits</title>
      <link href="/posts/leetcode191-number-of-1-bits/"/>
      <url>/posts/leetcode191-number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">00000000000000000000000000001011</span><br><span class="line">Output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>统计32位无符号数中”1”的个数。</p><p>思路同<a href="/2017/01/21/LeetCode338-Counting-Bits/">LeetCode338 Counting Bits</a>。</p><hr><p>今天再介绍一种基于「分治」的算法来统计”1”的个数。</p><p>假设现在我们要统计<code>1001 1011 0101 0010 1001 1111 0001 0010</code>中“1”的个数。</p><p><img src="https://tuchuang001.com/images/2017/09/02/4.png" alt=""></p><p>基于分治的思想，我们先统计出每<code>2</code>位有多少个1，如图中第①层所示。</p><p>将每<code>2</code>位的结果合并，统计出每<code>4</code>位有多少个1，如图中第②层所示。</p><p>再将每<code>4</code>位的结果合并，统计出每<code>8</code>位有多少个1，如图中第③层所示。</p><p>接着将每<code>8</code>位的结果合并，统计出每<code>16</code>位有多少个1，如图中第④层所示。</p><p>最后将每<code>16</code>位的结果合并，统计出每<code>32</code>位有多少个1，如图中第⑤层所示，即可得到答案。</p><hr><p>好了，有了一个直观的感受后，现在考虑如何实现合并的过程。</p><p>初始的$n$为： <code>1001 1011 0101 0010 1001 1111 0001 0010</code>，</p><p>第①层的结果为：<code>0101 0110 0101 0001 0101 1010 0001 0001</code>，这该怎么得到呢?</p><p>一条语句即可搞定！</p><p><code>n = (n &amp; (0x55555555)) + ((n &gt;&gt; 1) &amp; (0x55555555));</code></p><p>很神奇有木有，让我们来分析一下这条语句干了什么！</p><hr><p>首先，十六进制的常数<code>0x55555555</code>转化为二进制是<code>0101 0101 0101 0101 0101 0101 0101 0101 0101</code>。</p><p>那么，<code>n &amp; 0x55555555</code>就可以提取$n$偶数位上的1：</p><p><img src="https://tuchuang001.com/images/2017/09/02/1.png" alt=""></p><p><code>(n &gt;&gt; 1) &amp; 0x55555555</code>就可以提取$n$奇数位上的1：</p><p><img src="https://tuchuang001.com/images/2017/09/02/2.png" alt=""></p><p>最后，<code>n = (n &amp; (0x55555555)) + ((n &gt;&gt; 1) &amp; (0x55555555))</code>把这两个结果相加，即可得到每两位上“1”的个数。</p><p><img src="https://tuchuang001.com/images/2017/09/02/3.png" alt=""></p><p>这就得到第①层的结果啦。</p><p><img src="https://tuchuang001.com/images/2017/09/01/1.png" alt=""></p><hr><p>现在考虑怎么得到第②层的结果。</p><p>既然得到每2位的结果是通过常数<code>0101 0101 0101 0101 0101 0101 0101 0101</code>，即<code>0x55555555</code>得到的。</p><p>那么类比一下，每4位就应该是通过常数<code>0011 0011 0011 0011 0011 0011 0011 0011</code>，即<code>0x3333333</code>得到。</p><p>经过第一层，此时$n$更新为<code>0101 0110 0101 0001 0101 1010 0001 0001</code>。</p><p>那么，<code>n &amp; 0x33333333</code>就等于：</p><p><img src="https://tuchuang001.com/images/2017/09/02/6.png" alt=""></p><p><code>(n &gt;&gt; 2) &amp; 0x33333333</code> （注意，现在要右移两位）就等于：</p><p><img src="https://tuchuang001.com/images/2017/09/02/7.png" alt=""></p><p>最后，<code>n = (n &amp; (0x33333333)) + ((n &gt;&gt; 2) &amp; (0x33333333));</code>相加即可得到每四位上“1”的个数。</p><p><img src="https://tuchuang001.com/images/2017/09/02/5.png" alt=""></p><p>这就得到第②层的结果啦。</p><p><img src="https://tuchuang001.com/images/2017/09/01/5.png" alt=""></p><hr><p>以此类推…</p><p>合并每4位，得到每8位的结果。常数为：<code>0000 1111 0000 1111 0000 1111 0000 1111</code>，即<code>0x0F0F0F0F</code>。</p><p>因此有<code>n = (n &amp; (0x0F0F0F0F)) + ((n &gt;&gt; 4) &amp; (0x0F0F0F0F));</code></p><p><img src="https://tuchuang001.com/images/2017/09/01/6.png" alt=""></p><hr><p>合并每8位，得到每16位的结果。常数为：<code>0000 0000 1111 1111 0000 0000 1111 1111</code>，即<code>0x00FF00FF</code>。</p><p>因此有<code>n = (n &amp; (0x00FF00FF)) + ((n &gt;&gt; 8) &amp; (0x00FF00FF));</code></p><p><img src="https://tuchuang001.com/images/2017/09/01/7.png" alt=""></p><hr><p>合并每16位，得到每32位的结果。常数为：<code>0000 0000 0000 0000 1111 1111 1111 1111</code>，即<code>0x0000FFFF</code>。</p><p>因此有<code>n = (n &amp; (0x0x0000FFFF)) + ((n &gt;&gt; 16) &amp; (0x0x0000FFFF));</code></p><p><img src="https://tuchuang001.com/images/2017/09/01/8.png" alt=""></p><p>最后得到 <code>n = 16</code>，即最开始所求的32位数<code>1001 1011 0101 0010 1001 1111 0001 0010</code>中有16个“1”。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) ans++, n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &amp; (<span class="number">0x55555555</span>)) + ((n &gt;&gt; <span class="number">1</span>) &amp; (<span class="number">0x55555555</span>));</span><br><span class="line">        n = (n &amp; (<span class="number">0x33333333</span>)) + ((n &gt;&gt; <span class="number">2</span>) &amp; (<span class="number">0x33333333</span>));</span><br><span class="line">        n = (n &amp; (<span class="number">0x0F0F0F0F</span>)) + ((n &gt;&gt; <span class="number">4</span>) &amp; (<span class="number">0x0F0F0F0F</span>));</span><br><span class="line">        n = (n &amp; (<span class="number">0x00FF00FF</span>)) + ((n &gt;&gt; <span class="number">8</span>) &amp; (<span class="number">0x00FF00FF</span>));</span><br><span class="line">        n = (n &amp; (<span class="number">0x0000FFFF</span>)) + ((n &gt;&gt; <span class="number">16</span>) &amp; (<span class="number">0x0000FFFF</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode168 Excel Sheet Column Title</title>
      <link href="/posts/leetcode168-excel-sheet-column-title/"/>
      <url>/posts/leetcode168-excel-sheet-column-title/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将数字转换为excel的表头。</p><p> 本质上还是二十六进制的转换。由于是从<code>1</code>开始，故转换的时候要减掉一。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += <span class="keyword">char</span>((--n) % <span class="number">26</span>  + <span class="string">'A'</span>);</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode167 Two Sum II Input array is sorted</title>
      <link href="/posts/leetcode167-two-sum-ii-input-array-is-sorted/"/>
      <url>/posts/leetcode167-two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">numbers=&#123;2, 7, 11, 15&#125;, target=9</span><br><span class="line">Output: </span><br><span class="line">index1=1, index2=2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个递增的数组，从中找到两个元素使得它们的和等于给定的目标。</p><p>题目保证存在唯一解，并且同一个元素不能使用两次。</p><p>暴力的做法是枚举两个元素，复杂度$\mathcal{O}(n^2)$。</p><p>由于数组单调递增，可以枚举一个元素，然后二分搜索另外一个元素，复杂度$\mathcal{O}(logn)$。</p><p>再来考虑双指针的做法，$l$指向第一个元素，$r$指向第二个元素，由于数组有序，因此可以根据<code>nums[l] + nums[r]</code> 和 <code>target</code>的大小关系来更新$l$或$r$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>二分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 标准的二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; key) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[r] == key) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = find(numbers, target - numbers[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != j &amp;&amp; j != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans.push_back(min(i, j) + <span class="number">1</span>);</span><br><span class="line">                ans.push_back(max(i, j) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (numbers[l] + numbers[r] != target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vector构造函数之一：通过list构造</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode154 Find Minimum in Rotated Sorted Array II</title>
      <link href="/posts/leetcode154-find-minimum-in-rotated-sorted-array-ii/"/>
      <url>/posts/leetcode154-find-minimum-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><hr><blockquote><p><em>Follow up</em> for “Find Minimum in Rotated Sorted Array”:<br>What if <em>duplicates</em> are allowed?</p><p>Would this affect the run-time complexity? How and why?</p></blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[3, 3, 3, 1, 2, 3]</span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="/2017/08/31/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/">LeetCode153 Find Minimum in Rotated Sorted Array</a>的加强版，现在多了<strong>元素会重复</strong>这个条件。</p><blockquote><p>由于原始数组单调，不妨考虑二分，但是怎么更新$l$和$r$呢？</p><p>如果此时位于$mid$的元素大于位于$r$的元素，那么说明$mid$正位于中枢元素的左侧（中枢元素就是<code>0</code>），即$[l, mid]$这一段区间都不可能是答案，于是更新<code>l = mid + 1</code>。</p><p>反之，说明$mid$位于中枢元素的右侧（或者就是中枢元素本身），于是更新<code>r = mid</code>。</p></blockquote><p>两道题的思路其实差不多，但是现在得考虑元素重复带来的影响。</p><p>也就是说如果出现$mid$的元素和$r$的元素相等的情况该怎么办？更新$l$还是更新$r$，以及怎么更新？</p><p>比如对于样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[3, 3, 3, 1, 2, 3]</span><br><span class="line"> ↑     ↑        ↑</span><br><span class="line">l=0  mid=2     r=5</span><br></pre></td></tr></table></figure><p>可能会认为此时应该<code>l = mid + 1</code>。</p><p>再考虑如下样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[3, 1, 2, 3, 3, 3, 3]</span><br><span class="line"> ↑        ↑        ↑</span><br><span class="line">l=0     mid=3     r=6</span><br></pre></td></tr></table></figure><p>此时又应该是<code>r = mid</code>。</p><p>出现这种情况的原因是，我们没办法判断中枢元素到底位于<code>mid</code>的左侧还是右侧，也就没办法进行相应的更新。</p><p>因此，遇到$mid$元素和$r$元素相等的情况，需要考虑打破这种相等状态，一种可能的方式是：只是将 $r$减一。</p><p>万一<code>nums[r]</code>是答案，将$r$减一会不会让最小值丢失？</p><p>不会的，因为<code>nums[r] == nums[mid]</code>，中间的<code>nums[mid]</code>还在呢。</p><p>那为什么不是将$l$加一，不是也有可能改变相等的情况吗？</p><p>因为现在的写法是$mid$和$r$比较。在这种写法下，如果通过$l$加1来打破相等状态，有可能会越过中枢元素。</p><p>比如考虑如下样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次二分：</span><br><span class="line">[3, 1, 2, 3, 3, 3, 3]</span><br><span class="line"> ↑        ↑        ↑</span><br><span class="line">l=0     mid=3     r=6</span><br><span class="line">mid元素和r元素相等，l++</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二次二分：</span><br><span class="line">[3, 1, 2, 3, 3, 3, 3]</span><br><span class="line">    ↑     ↑        ↑</span><br><span class="line">   l=1  mid=3     r=6</span><br><span class="line">mid元素还是和r元素相等，l++</span><br><span class="line">此时l=2，已经越过了中枢元素</span><br></pre></td></tr></table></figure><p>因此如果想用$l$加1，那么在二分的时候就得用$mid$和$l$做比较。</p><p>但是还是不推荐用$l$来和$mid$作比较，考虑如下样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 3]</span><br><span class="line">l = 0, r = 1, mid = 0</span><br><span class="line">l和mid相等，l++，又错过了中枢元素...</span><br></pre></td></tr></table></figure><p>因此遇到相等的情况，仅仅让$r$减一是比较保险的做法。</p><hr><p>接下来说说复杂度的事情。</p><p>虽然打着“二分”的旗号，可能认为复杂度是$\mathcal{O}(logn)$。</p><p>在没有重复元素的时候，复杂度确实是这样，但是有重复元素的时候，却要小心了。</p><p>考虑样例 <code>[1, 1, 1, 1, 1, 1]</code></p><p>那么每次都会碰到相等的情况，只能简单的<code>r--</code>，相当于遍历一遍数组，复杂度又退化到$\mathcal{O}(n)$了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; nums[r]) r = m;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode153 Find Minimum in Rotated Sorted Array</title>
      <link href="/posts/leetcode153-find-minimum-in-rotated-sorted-array/"/>
      <url>/posts/leetcode153-find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4, 5, 6, 7, 0, 1, 2]</span><br><span class="line">Output:</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递增的原始数组（没有重复的元素），经过某个中枢元素旋转后，得到一个新的数组。现在只给出新数组，求其中最小的元素。</p><p>直接遍历新数组，就可以找到最小的元素，复杂度$\mathcal{O}(n)$，但这显然不是我们想要的。</p><p>由于原始数组单调，不妨考虑二分，但是怎么更新$l$和$r$呢？</p><p>如果此时位于$mid$的元素大于位于$r$的元素，那么说明$mid$正位于中枢元素的左侧（中枢元素就是<code>0</code>），即$[l, mid]$这一段区间都不可能是答案，于是更新<code>l = mid + 1</code>。</p><p>反之，说明$mid$位于中枢元素的右侧（或者就是中枢元素本身），于是更新<code>r = mid</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode102 Binary Tree Level Order Traversal</title>
      <link href="/posts/leetcode102-binary-tree-level-order-traversal/"/>
      <url>/posts/leetcode102-binary-tree-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Output:</span><br><span class="line">return its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的层序遍历。</p><p><code>BFS</code>：初始化一个队列，存放节点信息以及对应的深度。由于是宽搜，所以每到达新的一层，就把上一层的信息全push到vector里。</p><p><code>DFS</code>：在前序遍历的时候，初始化好相应深度的vector，若以后又访问到该层，直接push到相应层的vector中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.push(make_pair(root, <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; p = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (p.second != pre) &#123; <span class="comment">// 新的一层</span></span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">                temp.clear();</span><br><span class="line">                pre = p.second;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(p.first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left != <span class="literal">NULL</span>) que.push(make_pair(p.first-&gt;left, p.second + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right != <span class="literal">NULL</span>) que.push(make_pair(p.first-&gt;right, p.second + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 第一次到达dep层，初始化一个空的vector</span></span><br><span class="line">        <span class="keyword">if</span> (vec.size() == dep) vec.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        vec[dep].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, dep + <span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode112 Path Sum</title>
      <link href="/posts/leetcode112-path-sum/"/>
      <url>/posts/leetcode112-path-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given the below binary tree and sum = 22</span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">Output:</span><br><span class="line">return true, as there exist a root-to-leaf </span><br><span class="line">path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一颗二叉树和一个值，问是否存在从根到叶的路径，满足路径权值和等于给定的值。</p><p>可以从根开始dfs，每经过一个节点就减去该结点的值，然后在叶结点判断给定的值是否被减到零。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode118 Pascal&#39;s Triangle</title>
      <link href="/posts/leetcode118-pascals-triangle/"/>
      <url>/posts/leetcode118-pascals-triangle/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">numRows = 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求$n$层的帕斯卡三角，也就是杨辉三角。</p><p>递推式如下：</p><script type="math/tex; mode=display">dp[i][j] = \left\{\begin{matrix}1 \; & \text{if j = 0 or j = i}\\dp[i-1][j-1] + dp[i-1][j] \; & \text{others}\\end{matrix}\right.</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) temp.push_back(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> temp.push_back(ans[i<span class="number">-1</span>][j<span class="number">-1</span>] +ans[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode119 Pascal&#39;s Triangle II</title>
      <link href="/posts/leetcode119-pascals-triangle-ii/"/>
      <url>/posts/leetcode119-pascals-triangle-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal’s triangle.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">k = 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[1,3,3,1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求第$k$层的帕斯卡三角。</p><p>一种方法是像<a href="/2017/08/21/LeetCode118-Pascals-Triangle/">LeetCode118 Pascal’s Triangle</a>那样，先把$k$层全求出来，然后再取出第$k$层，这样空间是$\mathcal{O}(k^2)$。</p><p>为了降低空间复杂度，可以考虑使用滚动数组。</p><p>观察下列的递推式，</p><script type="math/tex; mode=display">dp[i][j] = \left\{\begin{matrix}1 \; & \text{if j = 0 or j = i}\\dp[i-1][j] + dp[i-1][j-1] \; & \text{others}\\end{matrix}\right.</script><p>假设我们忽略第一维的信息，只利用$dp[j] = dp[j] + dp[j-1]$来更新，是否可以呢？</p><p>答案是可以的，但是需要注意更新的顺序。</p><p>在有两维的时候，$j$按什么顺序更新都没问题，但是在只有一维的情况下，$j$只能从大往小更新。</p><p>当$j$从大往小更新的时候，等号左边的$dp[j]$ 指代$dp[i][j]$，等号右边的$dp[j]$指代$dp[i-1][j]$，$dp[j-1]$指代$dp[i-1][j-1]$，这样才能保证更新的时候等号右边的数据还是上一层的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(rowIndex + <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; --j) dp[j] += dp[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode125 Valid Palindrome</title>
      <link href="/posts/leetcode125-valid-palindrome/"/>
      <url>/posts/leetcode125-valid-palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;race a car&quot;</span><br><span class="line">Output:</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个字符串是否是回文的，只考虑其中出现的字母、数字，并且忽略大小写。</p><p>使用双指针，$l$指向头部，$r$指向尾部，遇到非法字符则移动到合法字符为止，然后将字母转为小写进行比较。</p><p><code>isalnum()</code>函数是用来判断一个字符是否是字母或数字的，<code>tolower()</code>则是返回一个字母的小写状态，这些函数都定义在<code>&lt;cctype&gt;</code>头文件中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[l])) l++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[r])) r--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[l++]) != <span class="built_in">tolower</span>(s[r--])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode107 Binary Tree Level Order Traversal II</title>
      <link href="/posts/leetcode107-binary-tree-level-order-traversal-ii/"/>
      <url>/posts/leetcode107-binary-tree-level-order-traversal-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树层序遍历的逆序。</p><p>BFS一遍即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.push(make_pair(root, <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; p = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (p.second != pre) &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">                temp.clear();</span><br><span class="line">                pre = p.second;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(p.first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left != <span class="literal">NULL</span>) que.push(make_pair(p.first-&gt;left, p.second + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right != <span class="literal">NULL</span>) que.push(make_pair(p.first-&gt;right, p.second + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode108 Convert Sorted Array to Binary Search Tree</title>
      <link href="/posts/leetcode108-convert-sorted-array-to-binary-search-tree/"/>
      <url>/posts/leetcode108-convert-sorted-array-to-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将有序数组转成二叉搜索树。</p><p>由于是有序数组，每次在中间位置将数组分成左右两部分递归下去即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = build(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017福建省大学生程序设计竞赛总结</title>
      <link href="/posts/2017-fjpcpc-summary/"/>
      <url>/posts/2017-fjpcpc-summary/</url>
      
        <content type="html"><![CDATA[<p>　　正式赛的开场比较顺利，第一题是鸡兔同笼解方程，第二题是SG函数博弈，第三题是kmp，一人敲一题，都是1A。第四题是高精度题，不知道为什么机器明明装了JDK环境，但是却不提供Eclipse。于是我们就只能用文本编辑器写Java代码，然后提交到OJ上在线编译（尝试在本地用命令行编译运行，不过没成功）。一开始用了BigDecimal类，但是有精度问题wa了一次，最后发现用BigInteger就行了，最终2A。第五题是错排问题，我把错排公式给了队友，不过他好像卡在了什么地方，最后也找到bug然后过了。</p>   <a id="more"></a><p>　　最后过的一题，说来惭愧，是那道签到的计算几何题，判断两个三角形的位置关系是相交、包含还是相离。这道题又是从开场卡到封榜，一开始想了比较复杂的做法，敲了一个多边形面积交再加一些特判就交了上去，结果wa了。想法虽然比较复杂，但是应该是没错的。一开始坐标都用int型，后来改成用double型交了，又wa了。队友又帮我想了一个用凸包判断的办法，又wa了。感觉我们在这道签到题上已经越走越远了，最后这题其实只用叉积判断下就过了。离结束还有四十多分钟，现在已经过了六题，想要夺金必须还得再过一题才比较稳，于是我们又开了两题。一道之前认为是后缀自动机的题，敲完自动机部分的模板之后才发现好像想法有点问题。然后还剩二三十分钟的时候，又重新开了另一道可能是斜率优化的DP，最后到比赛结束样例也没调出来。</p><p><img src="https://tuchuang001.com/images/2017/08/25/29761bbab486d7895160f116a853111f.jpg" alt="2017FJPCPC·厦门"></p><p>　　赛前一周，我们队在VJ、CF上打了五场左右的训练赛，希望在省赛上能有不错的表现。但是，最终还是输了，银牌第一，与金失之交臂。</p><p>　　大学最后一场ACM比赛，还是留下了很多遗憾…</p><p>　　虽然已经退役了，但是还是非常感谢集训队提供的平台以及老师们的辛苦付出，两年来也参加了ICPC、CCPC、天梯赛、省赛、多校训练等大大小小的比赛。在这过程中，有喜悦、有遗憾，收获到了许多，也得到了锻炼和成长，感谢！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode69 Sqrt(x)</title>
      <link href="/posts/leetcode69-sqrtx/"/>
      <url>/posts/leetcode69-sqrtx/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Implement <code>int sqrt(int x)</code>.</p><p>Compute and return the square root of <em>x</em>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实现开根函数，返回值向下取整。</p><p>一种方法是二分搜索答案，每次检查$mid^2$和$x$的关系来更新上下界。</p><p>另外，也可以使用<a href="https://en.wikipedia.org/wiki/Newton%27s_method" target="_blank" rel="noopener">牛顿迭代法</a>。迭代公式：$f(x) = x^2 - n$，$x_{n+1}$ = $x_{n} - \frac{f(x_{n})}{f^{‘}(x_{n})}$ = $x_{n} - \frac{x_{n}^2-n}{2x_{n}}$ = $(x_n + \frac{n}{x_n}) / 2$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>二分：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = x, m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (m * m &lt;= x) l = m;</span><br><span class="line">            <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>牛顿迭代法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x0 = <span class="number">0</span>, x1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fabs</span>(x0 - x1) &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">            x0 = x1;</span><br><span class="line">            x1 = (x0 + x / x0) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(x0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
            <tag> 牛顿迭代法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode83 Remove Duplicates from Sorted List</title>
      <link href="/posts/leetcode83-remove-duplicates-from-sorted-list/"/>
      <url>/posts/leetcode83-remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">1-&gt;1-&gt;2</span><br><span class="line">Output:</span><br><span class="line">1-&gt;2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output:</span><br><span class="line">1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>删除有序链表中重复的数字。</p><p>记录下前驱节点的值，判断与当前节点的值是否相同，相同则删去。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preVal = INT_MAX;</span><br><span class="line">        ListNode *cur = head, *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == preVal) pre-&gt;next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> pre = cur;</span><br><span class="line">            preVal = cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode70 Climbing Stairs</title>
      <link href="/posts/leetcode70-climbing-stairs/"/>
      <url>/posts/leetcode70-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>上一个$n$阶的楼梯，每次可以走1或2步，问有多少种走法。</p><p>动态规划经典题，也是斐波那契数列。</p><p>令$dp[i]$为走到第$i$阶时的方案数，则$dp[i] = dp[i-1] + dp[i-2]$，也就是说第$i$阶可以从第$i-1$阶走1步 或 第$i-2$阶走2步转移过来。初始化$dp[0] = 1$，$dp[1] = 1$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, t; <span class="comment">//不必开数组，用三个变量模拟即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; </span><br><span class="line">            t = b;</span><br><span class="line">            b = a + b;</span><br><span class="line">            a = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode84 Largest Rectangle in Histogram</title>
      <link href="/posts/leetcode84-largest-rectangle-in-histogram/"/>
      <url>/posts/leetcode84-largest-rectangle-in-histogram/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt=""></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt=""></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[2,1,5,6,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在直方图中找到面积最大的矩形。</p><p>暴力的做法是，枚举每个点$h[i]$作为最小值，看它能向左扩展多远$l_i$，能向右扩展多远$r_i$, $ans = max \lbrace h[i] * (l_i + r_i) | i = 0..n-1 \rbrace $，复杂度$O(n^2)$。</p><p>这题其实是一道单调栈的经典题，使用单调栈可以快速维护出每个点的$l$和$r$值。单调栈中存放节点的信息，表示节点的高度$h_i$以及节点的$l_i$值，并通过$l_i$值推出相应的$r_i$值。单调栈按节点的高度递增排序。</p><p>接下来以样例为例，具体说明各个步骤。（红色代表进栈，蓝色代表出栈）</p><p><img src="https://tuchuang001.com/images/2017/06/19/1aba62.jpg" alt=""></p><p>一开始栈为空，第一个节点 $Node_1:\lbrace h = 2, l = 1 \rbrace$ 进栈。</p><p><img src="https://tuchuang001.com/images/2017/06/19/27db62.jpg" alt=""></p><p>由于当前节点  $Node_2:\lbrace h = 1, l = 1 \rbrace$ 与栈顶节点  $Node_1:\lbrace h = 2, l = 1 \rbrace$ 之间不满足单调性质，故栈顶元素出栈，计算蓝色部分的面积，并更新答案 , $area_1 = h_1 * (l_1 + r_1) = 2 * (1 + 0) = 2$， $ans = max(ans, area_1) = 2$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/3b0edf.jpg" alt=""></p><p>此时栈为空，接下来节点 $Node_2:\lbrace h = 1, l = 2 \rbrace$ 进栈，那么我们如何知道该节点向左延伸的最长距离为$2$呢？<br>前面提到，栈中的节点按高度递增排序，如果当前节点进栈之前，有若干节点由于破坏单调性而被弹出栈，则这些出栈的节点的高度一定是大于当前节点的高度的，也就说明当前节点可以往前延伸这么多的距离。<br>$Node_2$初始$l_2$值为$1$，由于$Node_1$被弹出栈，那么$Node_2$向左延伸的距离除了本身的$1$以外，还要加上$Node_1$延伸的长度$l_1$。因此$l_2 = 1 + l_1 = 1 + 1 = 2$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/4d4816.jpg" alt=""></p><p>节点 $Node_3:\lbrace h = 5, l = 1 \rbrace$ 正常进栈。</p><p><img src="https://tuchuang001.com/images/2017/06/19/5ca216.jpg" alt=""></p><p>节点 $Node_4:\lbrace h = 6, l = 1 \rbrace$ 正常进栈。</p><p><img src="https://tuchuang001.com/images/2017/06/19/6c9e0f.jpg" alt=""></p><p>节点 $Node_5:\lbrace h = 2, l = 1 \rbrace$ 想要进栈，但是发现栈顶元素破坏单调性，则节点$Node_4:\lbrace h = 6, l = 1 \rbrace$出栈，更新答案，$area_4 = h_4 * (l_4 + r_4) = 6 * (1 + 0) = 6$， $ans = max(ans, area_4) = 6$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/77d6c1.jpg" alt=""></p><p>此时，栈顶为节点 $Node_3:\lbrace h = 5, l = 1 \rbrace$，依旧破坏单调性，出栈，更新答案。<br>但是$Node_3$进栈时的$l_3$值为$1$，为什么图中蓝色的宽度为$2$呢？请不要忘记计算节点的$r$值！(由于前几个节点的$r$值都为$0$，我就忽略没讲$r$ 怎么算)<br>那么$r$值又是怎么算出来的呢？这就体现了单调栈的作用了！由于单调栈中节点的高度是递增排列的，因此如果节点$Node_3$出栈前有若干节点被弹出栈了的话，那么这些节点的高度一定是大于节点$Node_3$的，只要把这些节点的$l$值累加起来，就是$Node_3$的$r$值了！因此$r_3 = l\ _4 = 1$。$area_3 = h_3 * (l_3 + r_3) = 5 * (1 + 1) = 10$。$ans = max(ans, area_3) = 10$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/8cfd82.jpg" alt=""></p><p>节点 $Node_5:\lbrace h = 2, l = 3 \rbrace$进栈，其中$l_5 = 1 + l_3 + l_4 = 1 + 1 + 1 = 3$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/943e6a.jpg" alt=""></p><p>节点 $Node_6:\lbrace h = 3, l = 1 \rbrace$ 正常进栈。</p><p><img src="https://tuchuang001.com/images/2017/06/19/106b30a.jpg" alt=""></p><p>至此，所有节点都已进栈，其中节点$Node_1$、节点$Node_3$和节点$Node_4$都已经被弹出栈，出栈时也更新过答案了。<br>现在栈中还有节点$Node_2$、节点$Node_5$和节点$Node_6$。<br>节点$Node_6:\lbrace h = 3, l = 1 \rbrace$出栈，更新答案，$area_6 = h_6 * (l_6 + r_6) = 3 * (1 + 0) = 3$， $ans = max(ans, area_6) = 10$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/11.jpg" alt=""></p><p>节点$Node_5:\lbrace h = 2, l = 3 \rbrace$出栈，更新答案。其中$r_5 = l_6 = 1$，$area_5 = h_5 * (l_5 + r_5) = 2 * (3 + 1) = 8$， $ans = max(ans, area_5) = 10$。</p><p><img src="https://tuchuang001.com/images/2017/06/19/12.jpg" alt=""></p><p>节点$Node_2:\lbrace h = 1, l = 2 \rbrace$出栈，更新答案。其中$r_2 = l_5 +l_6 = 3 + 1 = 4$，$area_2 = h_2 * (l_2 + r_2) = 1 * (2 + 4) = 6$， $ans = max(ans, area_2) = 10$。</p><p>注意到，上述过程中每个节点只进栈和出栈各一次，因此复杂度是线性的！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> h; <span class="comment">// 节点i的高度</span></span><br><span class="line">        <span class="keyword">int</span> l; <span class="comment">// 节点i向左延伸的最长距离</span></span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line">        Node(<span class="keyword">int</span> height, <span class="keyword">int</span> cnt):h(height), l(cnt)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node&gt; sta;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, curl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; h: heights) &#123;</span><br><span class="line">            curl = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!sta.empty() &amp;&amp; sta.top().h &gt;= h) &#123;</span><br><span class="line">                ans = max(ans, (curl += sta.top().l) * sta.top().h);</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(Node(h, curl + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        curl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!sta.empty()) &#123;</span><br><span class="line">            ans = max(ans, (curl += sta.top().l) * sta.top().h);</span><br><span class="line">            sta.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode20 Valid Parentheses</title>
      <link href="/posts/leetcode20-valid-parentheses/"/>
      <url>/posts/leetcode20-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;()&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>括号匹配问题。</p><p>用一个符号栈来维护即可。若当前的括号可以和栈顶括号匹配，则栈顶括号出栈，否则当前括号进栈，最后判断栈是否为空即可知道是否正确匹配完成。具体实现一般先在栈中压入一个特殊符号，避免栈为空的特判。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; hs;</span><br><span class="line">        hs[<span class="string">')'</span>] = <span class="string">'('</span>; hs[<span class="string">'&#125;'</span>] = <span class="string">'&#123;'</span>; hs[<span class="string">']'</span>] = <span class="string">'['</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; sta;</span><br><span class="line">        sta.push(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp;c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs[c] != sta.top()) sta.push(c);</span><br><span class="line">            <span class="keyword">else</span> sta.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sta.top() == <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode27 Remove Element</title>
      <link href="/posts/leetcode27-remove-element/"/>
      <url>/posts/leetcode27-remove-element/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p><p>Do not allocate extra space for another array, you must do this in place with constant memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums = [3,2,2,3], val = 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">Your function should return length = 2, </span><br><span class="line">with the first two elements of nums being 2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将数组中所有指定元素移动到数组末尾，且不能使用额外的内存空间。</p><p>使用双指针，$i$ 指向当前访问的元素，$j$ 代表之前有出现过多少个非指定元素。将指定元素移到末尾，相当于将其他元素移到前面。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">        <span class="comment">/* 短小精悍的实现</span></span><br><span class="line"><span class="comment">        int k = 0;</span></span><br><span class="line"><span class="comment">        for (int&amp; x: nums) if (x != val) swap(x, nums[k++]);</span></span><br><span class="line"><span class="comment">        return k;        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode53 Maximum Subarray Element</title>
      <link href="/posts/leetcode53-maximum-subarray/"/>
      <url>/posts/leetcode53-maximum-subarray/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[-2,1,-3,4,-1,2,1,-5,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求数组最大子串和。</p><p>定义$dp[i]$为以第$i$个元素结尾的最大子串和。</p><p>显然，当$dp[i-1] &gt; 0$时，$ dp[i] = dp[i-1] + nums[i]$，否则$dp[i] = nums[i]$</p><p>最后$ans = max(dp[i]  |  i = 0..n-1)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) &#123;</span><br><span class="line">            sum &lt; <span class="number">0</span> ? sum = x : sum += x;</span><br><span class="line">            ans = max(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017团队程序设计天梯赛决赛总结</title>
      <link href="/posts/2017-cccc-final-summary/"/>
      <url>/posts/2017-cccc-final-summary/</url>
      
        <content type="html"><![CDATA[<p>　　去年新出的赛事，中国高校计算机大赛(China Collegiate Computing Contest,简称C4)，其中有一个项目是团队程序设计天梯赛。每个学校出三支队伍，每支队伍十个人。在本校参加完初赛后，有幸去杭州参加决赛。<br><a id="more"></a></p><p><img src="https://tuchuang001.com/images/2017/09/04/C4.jpg" alt="2017GPLT决赛·FZU-Autumn队"></p><p>　　天梯赛不同于ACM比赛，虽然名义上都是“组队赛”，但是更多还是考验选手的个人实力。一般来说基础阶段的8道题和进阶阶段的4道题都没什么问题，思路和算法不会复杂，很快就可以想到。但是，怎么将思路转化为无BUG的代码，怎么快速编码实现是值得重视的。确实，想到了思路但不一定会敲，会敲但不一定没有BUG，在没有BUG的情况下还要保证手速，有BUG了还要快速调试出错误，在决赛短短两个半小时的时间里还是非常紧迫的。</p><p>　　这次比赛我主要是跟榜刷题，而不是按照题号顺序写，这样有一个好处是不容易卡题，前面快速把水题过了也能给自己一些信心。然后天梯赛是按点给分的，所以如果是一些小的点没过我就直接跳过了，不在上面浪费时间。思路上先想暴力能不能做，能的话直接敲下去，至少也能保证得到大部分的分数，节约想正解的时间。</p><p>　　在高压下编码，调试的能力迅速下降，以致于3-1那题最后没调试出来，甚是遗憾。参加这次比赛，发现自己的编码能力还有待提高，也认识到自己与一些大牛之间的差距。同样是两个半小时，有人能够AK比赛正确地做出所有的题目，而自己却只能刚刚到达登顶阶段。所以，有的时候能“理论AC”一道题，但是未必能够在短时间内正确编码通过。防止“眼高手低”，还是要多动手刷题才是正道。</p><p>　　Anyway，FZU最终夺得了高校一等奖！</p><p><img src="https://tuchuang001.com/images/2017/09/04/snipaste_20170904_002521.png" alt="2017GPLT决赛·高校榜单"></p><p><img src="https://tuchuang001.com/images/2017/09/04/58ff0b48339ce2002883dbae.jpg" alt="2017GPLT决赛·颁奖典礼"></p><p><img src="https://tuchuang001.com/images/2017/09/04/QQ20170904001931.jpg" alt="2017GPLT决赛·一等奖高校"></p><p>（运气好的小伙伴已经出去逛西湖了，运气不好的小伙伴只能默默待在颁奖典礼现场QAQ）</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode442 Find All Duplicates in an Array</title>
      <link href="/posts/leetcode442-find-all-duplicates-in-an-array/"/>
      <url>/posts/leetcode442-find-all-duplicates-in-an-array/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of integers, 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p><p>Find all the elements that appear <strong>twice</strong> in this array.</p><p>Could you do it without extra space and in O(<em>n</em>) runtime?</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出所有在数组中出现两次的数。</p><p>类似<a href="/2017/01/16/LeetCode448-Find-All-Numbers-Disappeared-in-an-Array/">LeetCode448 Find All Numbers Disappeared in an Array</a>这题中的技巧，对原数组做标记(取个负)表示该数曾出现过，若下次遇到已经为负则说明重复出现。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDuplicates(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), id;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            id = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[id] &lt; <span class="number">0</span>) ans.push_back(id + <span class="number">1</span>);</span><br><span class="line">            nums[id] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode447 Number of Boomerangs</title>
      <link href="/posts/leetcode447-number-of-boomerangs/"/>
      <url>/posts/leetcode447-number-of-boomerangs/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given <em>n</em> points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code>and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).</p><p>Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong> (inclusive).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,0],[1,0],[2,0]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>统计有多少个$(i, j, k)$点对满足 $dis(i, j) = dis(i, k)$</p><p>固定一个点<script type="math/tex">i</script>, 用map维护该点与其他点的距离。则每种距离对答案的贡献为$A^{2}_{n}$，$n$为该距离的个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p1, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p1.first - p2.first) * (p1.first - p2.first) + </span><br><span class="line">               (p1.second - p2.second) * (p1.second - p2.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hs(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            hs.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) hs[dis(points[i], points[j])]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: hs) ans += x.second * (x.second - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode451 Sort Characters By Frequency</title>
      <link href="/posts/leetcode451-sort-characters-by-frequency/"/>
      <url>/posts/leetcode451-sort-characters-by-frequency/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&apos;e&apos; appears twice while &apos;r&apos; and &apos;t&apos; both appear once.</span><br><span class="line">So &apos;e&apos; must appear before both &apos;r&apos; and &apos;t&apos;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both &apos;c&apos; and &apos;a&apos; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &apos;A&apos; and &apos;a&apos; are treated as two different characters.Input: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将字符串按字符出现频率排序。</p><p>每个字符丢到对应的桶中，然后按桶的大小排序，最后按序输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) p[i].first = <span class="number">0</span>, p[i].second = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c: s) p[c].first++;</span><br><span class="line">        sort(p, p+<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">127</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">while</span> (p[i].first--&gt;<span class="number">0</span>) ans += <span class="keyword">char</span>(p[i].second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode459 Repeated Substring Pattern</title>
      <link href="/posts/leetcode459-repeated-substring-pattern/"/>
      <url>/posts/leetcode459-repeated-substring-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&apos;s the substring &quot;ab&quot; twice.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断字符串是否存在循环节。</p><p>kmp算法找字符串循环节的一个应用，具体见<a href="http://www.cnblogs.com/jackge/archive/2013/01/05/2846006.html" target="_blank" rel="noopener">KMP算法 —— next 数组的应用 —- 前缀中最小循环节，最大重复次数</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fail[<span class="number">10005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j, len = s.size();</span><br><span class="line">        j = fail[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != s[j]) j = fail[j];</span><br><span class="line">            fail[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        getFail(str);</span><br><span class="line">        <span class="keyword">int</span> len = str.size();</span><br><span class="line">        <span class="keyword">return</span> fail[len] != <span class="number">0</span> &amp;&amp; len % (len - fail[len]) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode496 Next Greater Element I</title>
      <link href="/posts/leetcode496-next-greater-element-i/"/>
      <url>/posts/leetcode496-next-greater-element-i/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are given two arrays <strong>(without duplicates)</strong> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>‘s elements in the corresponding places of <code>nums2</code>.</p><p>The Next Greater Number of a number <strong>x</strong> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.</p><p><strong>Note:</strong></p><ol><li>All elements in <code>nums1</code> and <code>nums2</code> are unique.</li><li>The length of both <code>nums1</code> and <code>nums2</code> would not exceed 1000.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出nums1中的元素在nums2中对应位置的右边且比它大的第一个数，不存在则输出-1。</p><p>单调栈的应用。由于nums1是nums2的子集，所以先预处理出nums2中的所有答案再查询。</p><p>栈中的元素保持单调递减，若当前访问的元素x大于栈顶的元素sta.top()，则栈顶元素出栈并记录答案（即sta.top()右边第一个比它大的数为x)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!sta.empty() &amp;&amp; sta.top() &lt; x) &#123;</span><br><span class="line">                hs[sta.top()] = x;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: findNums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hs.count(x)) x = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> x = hs[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode492 Construct the Rectangle</title>
      <link href="/posts/leetcode492-construct-the-rectangle/"/>
      <url>/posts/leetcode492-construct-the-rectangle/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. The area of the rectangular web page you designed must equal to the given target area.</span><br><span class="line"></span><br><span class="line">2. The width W should not be larger than the length L, which means L &gt;= W.</span><br><span class="line"></span><br><span class="line">3. The difference between length L and width W should be as small as possible.</span><br></pre></td></tr></table></figure><p>You need to output the length L and the width W of the web page you designed in sequence.</p><p><strong>Note:</strong></p><ol><li>The given area won’t exceed 10,000,000 and is a positive integer</li><li>The web page’s width and length you designed must be positive integers.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对给定的面积，在满足的条件下，求出长和宽</p><p>条件是：l * w == area &amp;&amp; l &gt;= w &amp;&amp; l 和 r 的差要尽可能的小</p><p>从$\sqrt{area}$开始枚举宽度w，然后再判断是否满足上述条件即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="built_in">sqrt</span>(<span class="number">1.0</span> * area); w &gt;= <span class="number">1</span>; --w) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = area / w;</span><br><span class="line">            <span class="keyword">if</span> (l * w == area) &#123;</span><br><span class="line">                ans.push_back(max(l, w));</span><br><span class="line">                ans.push_back(min(l, w));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode504 Base 7</title>
      <link href="/posts/leetcode504-base-7/"/>
      <url>/posts/leetcode504-base-7/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer, return its base 7 string representation.</p><p><strong>Note:</strong> The input will be in range of [-1e7, 1e7].</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 100</span><br><span class="line">Output: &quot;202&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -7</span><br><span class="line">Output: &quot;-10&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将一个十进制数转化为七进制数。</p><p>注意负数以及零的处理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = num &gt; <span class="number">0</span> ? num : -num;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ans += <span class="keyword">char</span>(x % <span class="number">7</span> + <span class="string">'0'</span>);</span><br><span class="line">            x /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) ans = <span class="string">'-'</span> + ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode506 Relative Ranks</title>
      <link href="/posts/leetcode506-relative-ranks/"/>
      <url>/posts/leetcode506-relative-ranks/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given scores of <strong>N</strong> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p><p><strong>Note:</strong></p><ol><li>N is a positive integer and won’t exceed 10,000.</li><li>All the scores of athletes are guaranteed to be unique.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, </span><br><span class="line">so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class="line">For the left two athletes, you just need to output their </span><br><span class="line">relative ranks according to their scores.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据数组元素的大小，给出排名。前三输出金银铜牌，其余输出名次。</p><p>sort一下就好了，用pair姿势会比较优雅。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRelativeRanks(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line">    <span class="comment">// pair第一位存元素大小，第二位存下标</span></span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) vec.push_back(make_pair(-x, id++));</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans(siz);</span><br><span class="line">        <span class="built_in">string</span> medals[<span class="number">3</span>] = &#123;<span class="string">"Gold Medal"</span>, <span class="string">"Silver Medal"</span>, <span class="string">"Bronze Medal"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            id = vec[i].second;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">3</span>) ans[id] = medals[i];</span><br><span class="line">            <span class="keyword">else</span> ans[id] = to_string(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode513 Find Bottom Left Tree Value</title>
      <link href="/posts/leetcode513-find-bottom-left-tree-value/"/>
      <url>/posts/leetcode513-find-bottom-left-tree-value/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><p><strong>Note:</strong> You may assume the tree (i.e., the given root node) is not <strong>NULL</strong>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3</span><br><span class="line">     /   / \</span><br><span class="line">    4   5   6</span><br><span class="line">       /</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>输出二叉树最后一层最靠左的节点。</p><p>dfs一遍即可，具体看注释～</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// pair第一维存深度，第二维存节点的值</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; find(<span class="keyword">int</span> dep, TreeNode* root) &#123;</span><br><span class="line">      <span class="comment">// 空节点随便返回一个不可能取到的小值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">      <span class="comment">// 叶节点返回当前深度以及节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> make_pair(dep, root-&gt;val);</span><br><span class="line">      <span class="comment">// 递归访问左右儿子节点</span></span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; l = find(dep + <span class="number">1</span>, root-&gt;left), r = find(dep + <span class="number">1</span>, root-&gt;right);</span><br><span class="line">      <span class="comment">// 返回更深的结果，深度相同返回左儿子</span></span><br><span class="line">        <span class="keyword">return</span> l.first &gt;= r.first ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(<span class="number">1</span>, root).second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode520 Detect Capital</title>
      <link href="/posts/leetcode520-detect-capital/"/>
      <url>/posts/leetcode520-detect-capital/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li>All letters in this word are capitals, like “USA”.</li><li>All letters in this word are not capitals, like “leetcode”.</li><li>Only the first letter in this word is capital if it has more than one letter, like “Google”.</li></ol><p>Otherwise, we define that this word doesn’t use capitals in a right way.</p><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个字符串是否由全是大写字母或全是小写字母或开头大写其余小写组成。</p><p>记录大写字母的个数，特判一下即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: word) <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) count++;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) || (count == word.size()) || (count == <span class="number">1</span> &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coursera Machine Learning 应用机器学习算法的建议</title>
      <link href="/posts/coursera-advice-for-applying-machine-learning/"/>
      <url>/posts/coursera-advice-for-applying-machine-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="下一步该怎么办"><a href="#下一步该怎么办" class="headerlink" title="下一步该怎么办"></a>下一步该怎么办</h2><p>当你实现了一个带有正则化的线性回归来预测房价之后，也许你会发现结果并不尽如人意。</p><p>此时你可以试试以下一些方法：</p><ul><li>获取更多的训练数据</li><li>尝试更小的特征集合</li><li>添加额外的特征</li><li>添加多项式特征</li><li>增大或减小正则化参数$\lambda$</li></ul><a id="more"></a><h2 id="评估假设函数"><a href="#评估假设函数" class="headerlink" title="评估假设函数"></a>评估假设函数</h2><p>一个假设函数可能在训练集上的误差很小，但是并不是说这个误差越小越好（这通常意味着过拟合了）。因此，对于给定的训练样本，通常可以将其分为<strong>训练集</strong>（training set）和<strong>测试集</strong>（test set），一般来说分成七三开。</p><p>接下来我们将：</p><ul><li>使用训练集来学习参数$\Theta$以及最小化<script type="math/tex">J_{train}(\Theta)</script></li><li>在测试集上评估误差$J_{test}(\Theta)$</li></ul><p>对于线性回归：</p><script type="math/tex; mode=display">J_{test}(\Theta) = \dfrac{1}{2m_{test}} \sum_{i=1}^{m_{test}}(h_\Theta(x^{(i)}_{test}) - y^{(i)}_{test})^2</script><p>对于逻辑回归：</p><script type="math/tex; mode=display">err(h_\Theta(x),y) = \begin{matrix} 1 & \mbox{if } h_\Theta(x) \geq 0.5\ and\ y = 0\ or\ h_\Theta(x) < 0.5\ and\ y = 1\newline 0 & \mbox otherwise \end{matrix}</script><script type="math/tex; mode=display">J_{test}(\Theta) = \dfrac{1}{m_{test}} \sum^{m_{test}}_{i=1} err(h_\Theta(x^{(i)}_{test}), y^{(i)}_{test})</script><h2 id="模型选择和训练-验证-测试集"><a href="#模型选择和训练-验证-测试集" class="headerlink" title="模型选择和训练/验证/测试集"></a>模型选择和训练/验证/测试集</h2><p>我们之前已经遇到过过拟合问题了，也知道训练误差小并不代表着它的泛化能力也好。</p><p>因此，我们需要对模型进行选择，找到合适的参数，比如正则化参数的大小、多项式特征的次数等等（俗称调参）。然后比较，在哪些参数下，模型的表现性能最好（也就是说测试误差最小）。</p><p>另外，在模型选择的时候，除了用到训练集和测试集外，通常还会用到<strong>交叉验证集</strong>（cross validation set），一般按6 : 2 : 2的比例划分。</p><p>接下来还是一样，分别计算训练、验证和测试的误差：</p><p><img src="https://tuchuang001.com/images/2017/03/18/lecture10-1.png" alt="train/validation/test error" width="80%" height="80%"></p><ul><li>使用训练集来学习参数$\Theta$以及最小化$J_{train}(\Theta)$</li><li>使用验证集来调参</li><li>使用测试集来评估泛化能力</li></ul><p>注意：永远不要使用测试集来调参！</p><h2 id="偏差vs方差"><a href="#偏差vs方差" class="headerlink" title="偏差vs方差"></a>偏差vs方差</h2><p>如果你的模型得到比较差的结果，通常有以下两种原因：</p><ul><li><strong>高偏差</strong>（high bias）：欠拟合，一般$J_{train}(\Theta)$和$J_{CV}(\Theta)$都很高，并且$J_{CV}(\Theta) \approx J_{train}(\Theta)$</li><li><strong>高方差</strong>（high variance）：过拟合，一般是$J_{train}(\Theta)$比较低，但是$J_{CV}(\Theta)$却远高于$J_{train}(\Theta)$</li></ul><p><img src="https://tuchuang001.com/images/2017/03/18/lecture10-2.png" alt="bias vs variance" width="50%" height="50%"></p><h2 id="正则化对偏差-方差的影响"><a href="#正则化对偏差-方差的影响" class="headerlink" title="正则化对偏差/方差的影响"></a>正则化对偏差/方差的影响</h2><p>接下来，我们看看如何通过正则化参数$\lambda$来影响偏差和方差。</p><ul><li>$\lambda$<strong>过大时</strong>：所有权重参数$\Theta$都受到惩罚，大多数参数可能因此而趋于0，这也导致假设函数的结果趋于0，从而引起欠拟合的问题</li><li>$\lambda$<strong>过小时</strong>：考虑极端情况$\lambda = 0$，此时完全没有正则化项，当然假设函数会尽可能的拟合数据，从而引起过拟合的问题</li></ul><p><img src="https://tuchuang001.com/images/2017/03/18/lecture10-3.png" alt="regularization and bias/variance" width="60%" height="60%"></p><p>为了选择模型以及正则化参数$\lambda$，通常需要以下几步：</p><ul><li>创建一个正则化参数列表 (比如说 $λ∈{0,0.01,0.02,0.04…}$);</li><li>使用不同的多项式次数或其他参数变量来生成一系列的模型</li><li>迭代正则化参数列表，对每个$\lambda$在这一系列的模型上学习权重参数$\Theta$</li><li>使用该$\Theta$来计算交叉验证误差（计算的时候不需要正则化）</li><li>选择在验证集上表现最好的参数组合</li><li>然后用该参数组合在测试集上计算$J_{test}(\Theta)$，检验其泛化能力</li></ul><h2 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h2><p>绘制学习曲线通常有助于检查和提高模型的性能</p><p>那么，什么是<strong>学习曲线</strong>呢？</p><p><img src="https://tuchuang001.com/images/2017/03/18/lecture10-4.png" alt="learning curves" width="60%" height="60%"></p><p>通常以训练集大小为横轴，将训练误差$J_{train}(\Theta)$和验证误差$J_{CV}(\Theta)$绘制在一起来观测训练结果。</p><p>学习曲线一般有以下两种情况：</p><ul><li><p><strong>高偏差的情况</strong></p><p><img src="https://tuchuang001.com/images/2017/03/18/lecture10-5.png" alt="high bias" width="60%" height="50%"></p><p>在$N$比较小时，$J_{train}(\Theta)$会比较低，但是$J_{CV}(\Theta)$比较高</p><p>在$N$比较大时，$J_{train}(\Theta)$和$J_{CV}(\Theta)$都很高，并且$J_{CV}(\Theta) \approx J_{train}(\Theta)$</p><p>如果学习曲线出现这种情况的话，一般来说即使得到更多的训练样本也是没太大帮助的</p></li><li><p><strong>高方差的情况</strong></p><p><img src="https://tuchuang001.com/images/2017/03/18/lecture10-6.png" alt="high variance" width="60%" height="60%"></p><p>在$N$比较小时，$J_{train}(\Theta)$会比较低，但是$J_{CV}(\Theta)$比较高</p><p>在$N$比较大时，随着$N$的增大，$J_{train}(\Theta)$会一直增加，同时$J_{CV}(\Theta)$会一直减小，但是会保持$J_{train}(\Theta) \lt J_{CV}(\Theta)$，且它们之间的差距还是会很明显的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode500 Keyboard Row</title>
      <link href="/posts/leetcode500-keyboard-row/"/>
      <url>/posts/leetcode500-keyboard-row/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a List of words, return the words that can be typed using letters of <strong>alphabet</strong> on only one row’s of American keyboard like the image below.</p><p><img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="keyboard row"></p><p><strong>Note:</strong></p><ol><li>You may use one character in the keyboard more than once.</li><li>You may assume the input string will only contain letters of alphabet.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个字符串是不是由键盘上同一行的字符组成的，若是则输出该字符串。</p><p>将同一行的字符用map映射到同一个值，然后再对输入的字符串逐个字符比较判断即可。</p><p>注意大小写的问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">string</span> r[<span class="number">3</span>] = &#123;<span class="string">"QWERTYUIOP"</span>, <span class="string">"ASDFGHJKL"</span>, <span class="string">"ZXCVBNM"</span>&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: r[i]) hs[c] = i;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s: words) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = hs[<span class="built_in">toupper</span>(s[<span class="number">0</span>])], ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: s) <span class="keyword">if</span> (hs[<span class="built_in">toupper</span>(c)] != row) ok = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok) ans.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode21 Merge Two Sorted Lists</title>
      <link href="/posts/leetcode21-merge-two-sorted-lists/"/>
      <url>/posts/leetcode21-merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[1, 2, 3, 3]</span><br><span class="line">[1, 4, 5]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: </span><br><span class="line">[1, 1, 2, 3, 3, 4, 5]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>合并两个有序链表。</p><p>实现分为递归和非递归的方式，其中非递归写起来稍微麻烦一点，需要判断的情况比较多。相比较之下，递归的写法更加直观自然。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li><p><strong>非递归版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* newList = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* head = newList; <span class="comment">// 指向新链表的头</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果l2为空，或者l1的值小等于l2的，则把l1的值加到新链表中</span></span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">NULL</span> || (l1 != <span class="literal">NULL</span> &amp;&amp; l1-&gt;val &lt;= l2-&gt;val)) &#123;</span><br><span class="line">                head-&gt;val = l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;val = l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="comment">// l1和l2都为空，则退出</span></span><br><span class="line">            <span class="keyword">if</span> (!l1 &amp;&amp; !l2) <span class="keyword">break</span>;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 || !l2) <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode28 Implement strStr</title>
      <link href="/posts/leetcode28-implement-strstr/"/>
      <url>/posts/leetcode28-implement-strstr/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Implement strStr().</p><p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">abca</span><br><span class="line">ca</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实现strStr()函数。该函数是用来在s串中查询是否存在串t的，若存在则返回第一次出现的下标。</p><p>字符串匹配的模板题，使用<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">KMP算法</a>即可。注意要特判串t为空的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* fail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j, n = s.size();</span><br><span class="line">        fail = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        j = fail[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != s[j]) j = fail[j];</span><br><span class="line">            fail[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle == <span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getFail(needle);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; haystack[i] != needle[j]) j = fail[j];</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode35 Search Insert Position</title>
      <link href="/posts/leetcode35-search-insert-position/"/>
      <url>/posts/leetcode35-search-insert-position/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1,3,5,6], 5 → 2</span><br><span class="line">[1,3,5,6], 2 → 1</span><br><span class="line">[1,3,5,6], 7 → 4</span><br><span class="line">[1,3,5,6], 0 → 0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将一个数插入到有序数组（数组中没有重复的元素）中去，输出插入的位置。</p><p>二分查找即可。知乎上有一个讨论<a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">二分查找有几种写法？它们的区别是什么？</a>，可以围观一下~</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[r] &lt; target) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode50 Pow(x, n)</title>
      <link href="/posts/leetcode50-powx-n/"/>
      <url>/posts/leetcode50-powx-n/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Implement pow(<em>x</em>, <em>n</em>).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>计算$x^n$，其中​<script type="math/tex">x</script>为浮点数，​<script type="math/tex">n</script>为整数。</p><p>使用快速幂算法，注意特判<script type="math/tex">n</script>小于0的情况。</p><p><img src="https://tuchuang001.com/images/2017/02/25/QQ20170225161019.png" alt="快速幂算法" width="70%" height="70%"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) p = <span class="number">-1L</span>L * n, x = <span class="number">1.0</span> / x;</span><br><span class="line">        <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>, x = x*x)  <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ans *= x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode9 Palindrome Number</title>
      <link href="/posts/leetcode9-palindrome-number/"/>
      <url>/posts/leetcode9-palindrome-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Determine whether an integer is a palindrome. Do this without extra space.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否是回文的。</p><p>首先负数肯定不是，因为有个负号。其次，最后一位不能为0，因为翻转之后会有前导0。</p><p>然后只要把前半段和后半段的数（后半段的要翻转一下）取出来比较，判断是否相等即可。</p><p>比如123321，则前半段为123，翻转之后的后半段也是123，说明是回文的。</p><p>注意如果是奇数的话，要去掉中间的那位再比较。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x &gt; <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (rev &lt; x) &#123;</span><br><span class="line">            rev = rev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (rev == x) || (rev / <span class="number">10</span> == x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coursera Machine Learning 神经网络模型</title>
      <link href="/posts/coursera-neural-networks-model/"/>
      <url>/posts/coursera-neural-networks-model/</url>
      
        <content type="html"><![CDATA[<h2 id="非线性假设函数"><a href="#非线性假设函数" class="headerlink" title="非线性假设函数"></a>非线性假设函数</h2><p>　　既然前面已经有效果不错的线性回归和逻辑回归模型了，那么我们为什么还需要神经网络模型呢？试想，在面对一个复杂庞大的数据集时，若使用线性回归我们势必要增加大量的特征才能够较好的拟合数据。比如说现在有$n$个特征，要生成所有的平方项，则其数量大约在$\mathcal{O}(n^2/2)$左右，显然次数越高其数量增长速度越快。举个例子，现在我们有一个50*50像素的黑白照片数据集，训练目标是判断图片中是否包含有车辆。若我们选取每个像素来作为特征的话，那么特征数量$n$则为2500（如果是RGB彩色图片的话，则是7500），则其所有的平方项特征大约在三百万左右! 显然这是不切实际的，因此我们必须另辟蹊径。幸运的是，神经网络能为我们提供更为复杂的模型表示。</p><a id="more"></a><p><img src="https://tuchuang001.com/images/2017/02/20/lecture8-1.png" alt="车辆检测" width="70%" height="70%"></p><h2 id="神经网络表示"><a href="#神经网络表示" class="headerlink" title="神经网络表示"></a>神经网络表示</h2><p>神经网络是一种用来模拟人类大脑神经元工作的学习方法。</p><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>生物意义上的神经元由以下三部分组成：</p><ul><li>细胞体（处理信息）</li><li>树突（输入端）</li><li>轴突（输出端）</li></ul><p><img src="https://tuchuang001.com/images/2017/02/20/lecture8-2.png" alt="神经元" width="70%" height="70%"></p><p>而在人工神经网络中，“神经元”则是一个简化的逻辑单元。其中的输入则是$x_1\cdots x_n$这些特征（其中$x_0$叫bias unit，恒为1），输出则是由假设函数计算得出，处理输入的信息则是采用各种激活函数（常用的有Sigmoid函数等），特别的还有称为权重的$\theta$参数，用来对输入给予不同的权重。</p><p><img src="https://tuchuang001.com/images/2017/02/20/lecture8-3.png" alt="逻辑单元" width="70%" height="70%"></p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>神经网络由若干层（layer）组成。第一层叫做“输入层”，最后一层叫做“输出层”，中间还有若干个“隐藏层”。</p><p><img src="https://tuchuang001.com/images/2017/02/20/lecture8-4.png" alt="神经网络" width="70%" height="70%"></p><p><img src="https://tuchuang001.com/images/2017/02/20/lecture8-5.png" alt="神经网络" width="70%" height="70%"></p><script type="math/tex; mode=display">\begin{align*}& a_i^{(j)} = \text{第$j$层的第$i$个激活单元} \newline& \Theta^{(j)} = \text{从第$j$层到第$j+1$层的权重矩阵}  \newline& \text{如果第$j$层有 $s_j$个单元且第$j+1$有$s_{j+1}$个单元,那么 $\Theta^{(j)}$是 $s_{j+1} \times (s_j + 1)$维的矩阵.}\end{align*}</script><h3 id="前向传播的向量化实现"><a href="#前向传播的向量化实现" class="headerlink" title="前向传播的向量化实现"></a>前向传播的向量化实现</h3><p><img src="https://tuchuang001.com/images/2017/02/20/lecture8-6.png" alt="前向传播" width="70%" height="70%"></p><p>为了将前向传播用向量化方法实现，我们引入一个新的变量： $z_k^{(j)}$表示第$j$层第$i$个单元激活函数里的参数。</p><p>因此有$z^{(j)} = \Theta^{(j-1)}a^{(j-1)}$，$a^{(j)} = g(z^{(j)})$。若最后一层为第$k$层，则最终的结果为 $h_\Theta(x) = a^{k} = g(z^{(k)})$</p><h2 id="非线性分类实例"><a href="#非线性分类实例" class="headerlink" title="非线性分类实例"></a>非线性分类实例</h2><h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><p><img src="https://tuchuang001.com/images/2017/02/21/lecture8-8.png" alt="逻辑与" width="40%" height="40%"></p><script type="math/tex; mode=display">\Theta^{(1)} =\begin{bmatrix}-30 & 20 & 20\end{bmatrix}</script><script type="math/tex; mode=display">\begin{align*}& h_\Theta(x) = g(-30 + 20x_1 + 20x_2) \newline \newline & x_1 = 0 \ \ and \ \ x_2 = 0 \ \ then \ \ g(-30) \approx 0 \newline & x_1 = 0 \ \ and \ \ x_2 = 1 \ \ then \ \ g(-10) \approx 0 \newline & x_1 = 1 \ \ and \ \ x_2 = 0 \ \ then \ \ g(-10) \approx 0 \newline & x_1 = 1 \ \ and \ \ x_2 = 1 \ \ then \ \ g(10) \approx 1\end{align*}</script><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h3><p><img src="https://tuchuang001.com/images/2017/02/21/lecture8-10.png" alt="逻辑或" width="40%" height="40%"></p><script type="math/tex; mode=display">\Theta^{(1)} =\begin{bmatrix}-10 & 20 & 20\end{bmatrix}</script><script type="math/tex; mode=display">\begin{align*}& h_\Theta(x) = g(-10 + 20x_1 + 20x_2) \newline \newline & x_1 = 0 \ \ and \ \ x_2 = 0 \ \ then \ \ g(20) \approx 0 \newline & x_1 = 0 \ \ and \ \ x_2 = 1 \ \ then \ \ g(-10) \approx 0 \newline & x_1 = 1 \ \ and \ \ x_2 = 0 \ \ then \ \ g(-10) \approx 0 \newline & x_1 = 1 \ \ and \ \ x_2 = 1 \ \ then \ \ g(10) \approx 1\end{align*}</script><h3 id="异或非"><a href="#异或非" class="headerlink" title="异或非"></a>异或非</h3><p>这是一个由多个层组合起来的更复杂的函数表示。</p><p><img src="https://tuchuang001.com/images/2017/02/22/lecture8-11.png" alt="异或非" width="70%" height="70%"></p><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>输出层可以有多个输出单元，第$i$个单元为1表示输入的样本属于第$i$类。</p><p><img src="https://tuchuang001.com/images/2017/02/22/lecture8-12.png" alt="多分类问题" width="70%" height="70%"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coursera Machine Learning 逻辑回归和正则化</title>
      <link href="/posts/coursera-logistic-regression-and-regularization/"/>
      <url>/posts/coursera-logistic-regression-and-regularization/</url>
      
        <content type="html"><![CDATA[<h2 id="二元分类"><a href="#二元分类" class="headerlink" title="二元分类"></a>二元分类</h2><p>对于二元分类来说，其输出值 $y$ 不再是一个连续的值，而是属于 $\lbrace 0,1 \rbrace$，一般0代表<code>negative class</code>，而1代表<code>positive class</code>。想要实现二元分类，一种方法是在线性回归的基础上进行修改，比如说输出值$y$超过了某一阈值，则认为它属于1，否则属于0，但是这个效果通常来说不是很好。</p><a id="more"></a><h2 id="假设函数的表示"><a href="#假设函数的表示" class="headerlink" title="假设函数的表示"></a>假设函数的表示</h2><p>首先，分类问题中的$h_\theta (x)$函数要满足$0 \leq h_\theta (x) \leq 1$，为此引入一个新的函数——<code>Sigmoid Function</code>。sigmoid函数定义为：$g(z) = \dfrac{1}{1 + e^{-z}}$，它可以将任意的实数映射到区间$(0, 1)$ 。函数的大致图像如下：</p><p><img src="https://tuchuang001.com/images/2017/02/04/lecture6-1.png" alt="sigmoid函数" width="70%" height="70%"></p><p>在分类问题中，$h_\theta (x) =  g ( \theta^T x )$，也就是在sigmoid函数作用下，将原本线性回归的输出值映射到$(0, 1)$区间。同时$h_\theta (x)$的含义也有了变化，代表着在输入为$x$的情况下 ，其类别为<code>1</code>的概率大小。形式化的表示就是：$h_\theta(x) = P(y = 1 | x; \theta)$</p><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><p>在将$h_\theta (x)$ 映射到$ (0, 1) $区间之后，我们可以认为当$h_\theta(x) \geq 0.5 $时$y = 1$，$h_\theta(x) &lt; 0.5$时$y = 0$。观察sigmoid函数的图像不难发现，$z \geq 0$ 时 $g(z) \geq 0.5 $，因此 $y = 1$ 的充要条件就是 $\theta^T x &gt;= 0$ 。而所谓的决策边界(decision boundary)就是 $ \theta^T x = 0$ 所构成的曲线。</p><p><img src="https://tuchuang001.com/images/2017/02/04/lecture6-2.png" alt="decision boundary" width="80%" height="80%"></p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>逻辑回归的损失函数如下：</p><script type="math/tex; mode=display">\begin{align*}& J(\theta) = \dfrac{1}{m} \sum_{i=1}^m \mathrm{Cost}(h_\theta(x^{(i)}),y^{(i)}) \newline & 其中\newline & \mathrm{Cost}(h_\theta(x),y) = -\log(h_\theta(x)) \; & \text{if y = 1} \newline & \mathrm{Cost}(h_\theta(x),y) = -\log(1-h_\theta(x)) \; & \text{if y = 0}\end{align*}</script><p>还是先来看下函数图像，有一个直观的感受</p><center><img src="https://tuchuang001.com/images/2017/02/04/lecture6-3.png" alt="" width="30%" height="30%"><img src="https://tuchuang001.com/images/2017/02/04/lecture6-4.png" alt="" width="30%" height="30%"></center><p>上述的 Cost 函数要分类讨论，计算的时候比较麻烦。其实可以化简成一个式子来表示两种情况，就是  $\mathrm{Cost}(h_\theta(x),y) = - y \; \log(h_\theta(x)) - (1 - y) \log(1 - h_\theta(x))$  ，不难验证两者是等价的。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>$J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]$</p><p>梯度下降算法（跟线性回归时的一样）：</p><script type="math/tex; mode=display">\begin{align*}& Repeat \; \lbrace \newline & \; \theta_j := \theta_j - \alpha \dfrac{\partial}{\partial \theta_j}J(\theta) \newline & \rbrace\end{align*}</script><p>其中，$\dfrac{\partial}{\partial \theta_j}J(\theta)  = \frac{1}{m}\sum_{i=1}^m \left [ h_\theta(x^{(i)}) - y^{(i)} \right ] x^{(i)}_j$</p><h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p>虽然采用梯度下降算法也能求得结果，但是还存在一些更好的优化算法。不过一般来说都会比较复杂，没必要自己亲自实现。Matlab或Octave中有提供一个<code>fminunc</code>函数可以用来找到一个无约束多变量函数的最小值 (Find a minimum of an unconstrained multivariable function) 。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[jVal, gradient]</span> = <span class="title">costFunction</span><span class="params">(theta)</span></span></span><br><span class="line">  jVal = [...code to compute J(theta)...];</span><br><span class="line">  gradient = [...code to compute derivative of J(theta)...];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">options = optimset(<span class="string">'GradObj'</span>, <span class="string">'on'</span>, <span class="string">'MaxIter'</span>, <span class="number">100</span>);</span><br><span class="line">initialTheta = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure><p>具体用法参阅：<a href="https://cn.mathworks.com/help/optim/ug/fminunc-unconstrained-minimization.html" target="_blank" rel="noopener">fminunc Unconstrained Minimization</a></p><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>在多分类问题中，结果不再仅仅只有0、1两类，而是可能有多种分类结果。那么此时该如何处理呢？</p><p>其实很简单，One-vs-all！将多分类问题转化成二元分类问题。</p><p>比如$y \in \lbrace0, 1 … n\rbrace$ ，那么我们可以训练 $n+1$ 个二元分类器 $h_\theta ^{(0)}(x),  h_\theta ^{(1)}(x), …, h_\theta ^{(n)}(x)$ 。在第 $i$ 个二元分类器中，它只要计算当前输入为第 $i$ 个分类的概率。那么样本的类别就是等于这 $n+1$个结果中概率最大的那个类别，即 $ \mathrm{类别} = \max_i( h_\theta ^{(i)}(x) ) $ 。</p><p><img src="https://tuchuang001.com/images/2017/02/04/lecture6-5.png" alt="one vs all" width="80%" height="80%"></p><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p><strong>欠拟合</strong>(underfitting)：模型复杂度过低，不能很好的拟合所有的数据，训练误差大。</p><p><strong>过拟合</strong>(Overfitting)：模型复杂度过高，训练数据过少，训练误差虽小，但测试误差大。</p><p>欠拟合对应<strong>高偏差(bias)</strong>，过拟合对应<strong>高方差(variance)</strong>。</p><p><img src="https://tuchuang001.com/images/2017/02/04/lecture7-1.png" alt="one vs all" width="80%" height="80%"></p><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>通过在损失函数中加入正则化项(regularizer)来避免过拟合问题。</p><script type="math/tex; mode=display">min_\theta\ \dfrac{1}{2m}\ \left[ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum_{j=1}^n \theta_j^2 \right]</script><p>其中，$\lambda$ 称作正则化参数，用来控制<strong>拟合训练数据</strong>和<strong>保持参数值较小</strong>这两个目标之间的关系。</p><ul><li><p>对线性回归进行正则化</p><p><strong>梯度下降：</strong></p><script type="math/tex; mode=display">\begin{align*} & \text{Repeat}\ \lbrace \newline & \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \newline & \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right] &\ \ \ \ \ \ \ \ \ \ j \in \lbrace 1,2...n\rbrace\newline & \rbrace\end{align*}</script><p><strong>正规方程(Normal equation)：</strong></p><script type="math/tex; mode=display">\begin{align*}& \theta = \left( X^TX + \lambda \cdot L \right)^{-1} X^Ty \newline& \text{其中}\ \ L = \begin{bmatrix} 0 & & & & \newline & 1 & & & \newline & & 1 & & \newline & & & \ddots & \newline & & & & 1 \newline\end{bmatrix}\end{align*}</script></li></ul><ul><li><p>对逻辑回归进行正则化</p><script type="math/tex; mode=display">J(\theta) = - \frac{1}{m} \sum_{i=1}^m \large[ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2</script><p><strong>梯度下降：</strong></p><script type="math/tex; mode=display">\begin{align*}& \text{Repeat}\ \lbrace \newline& \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \newline& \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right] &\ \ \ \ \ \ \ \ \ \ j \in \lbrace 1,2...n\rbrace\newline& \rbrace\end{align*}</script></li></ul><p>需要注意的是，一般都不对 $\theta_0$ 进行正则化（$\theta_0$ 恒为1），因此在上面的公式中下标 $j$ 都从1开始。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode268 Missing Number</title>
      <link href="/posts/leetcode268-missing-number/"/>
      <url>/posts/leetcode268-missing-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p><p><strong>Note</strong>:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>Given <em>nums</em> = <code>[0, 1, 3]</code> return <code>2</code>.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从$[0, n]$ 中给出 $n$ 个不同的数，问哪一个数不在里面。</p><p><script type="math/tex">0</script> 到 <script type="math/tex">n</script> 之和 再扣掉 数组元素之和，即得到答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), ans = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) ans -= x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode326 Power of Three</title>
      <link href="/posts/leetcode326-power-of-three/"/>
      <url>/posts/leetcode326-power-of-three/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer, write a function to determine if it is a power of three.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否为3的次幂。</p><p>直接模拟，或者先找到<script type="math/tex">int</script>范围内最大的3次幂（也就是1162261467）看能否整除，能整除说明输入的是3的次幂。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt; n; x *= <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> x == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode350 Intersection of Two Arrays II</title>
      <link href="/posts/leetcode350-intersection-of-two-arrays-ii/"/>
      <url>/posts/leetcode350-intersection-of-two-arrays-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Note:</strong></p><ul><li>Each element in the result should appear as many times as it shows in both arrays.</li><li>The result can be in any order.</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求两个数组的交，结果不去重。</p><p>具体解法可参考<a href="/2017/01/26/LeetCode349-Intersection-of-Two-Arrays/">LeetCode349-Intersection-of-Two-Arrays</a>这题，只不过少掉了去重操作而已。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(nums1[i]);</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode401 Binary Watch</title>
      <link href="/posts/leetcode401-binary-watch/"/>
      <url>/posts/leetcode401-binary-watch/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>A binary watch has 4 LEDs on the top which represent the <strong>hours</strong> (<strong>0-11</strong>), and the 6 LEDs on the bottom represent the <strong>minutes</strong> (<strong>0-59</strong>).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="img"></p><p>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p><strong>Note:</strong></p><ul><li>The order of output does not matter.</li><li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li><li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, </span><br><span class="line">         &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个神奇的二进制手表… 问当有n个LED灯亮起时，可能的时间是多少。</p><p>直接枚举所有时间，再判断当前时间的二进制表示中1的个数是否满足即可。用到了 一个小技巧就是把时间用二进制压缩表示。<code>h &lt;&lt; 6 | m</code>，h是小时数，m是分钟数，由于分钟数最多用6个二进制位表示即可，所以低6位用来表示分钟，高位则表示小时。最后再用系统自带的<code>__builtin_popcount()</code>函数计算二进制中1的个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; readBinaryWatch(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; ++h)  &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; ++m) &#123;</span><br><span class="line">               <span class="keyword">if</span> (__builtin_popcount(h &lt;&lt; <span class="number">6</span> | m) == num) &#123;</span><br><span class="line">                   ans.push_back(to_string(h) + (m &lt; <span class="number">10</span> ? <span class="string">":0"</span> : <span class="string">":"</span>) + to_string(m));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode405 Convert a Number to Hexadecimal</title>
      <link href="/posts/leetcode405-convert-a-number-to-hexadecimal/"/>
      <url>/posts/leetcode405-convert-a-number-to-hexadecimal/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">two’s complement</a> method is used.</p><p><strong>Note:</strong></p><ol><li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li><li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>&#39;0&#39;</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li><li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li><li>You <strong>must not use any method provided by the library</strong> which converts/formats the number to hex directly.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;1a&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求一个int类型整数的十六进制表示。</p><p>直接4位4位压缩表示即可。需要注意的是负数的情况，由于C++中<code>&gt;&gt;</code>运算是带符号右移，负数的符号位是1右移高位会补1…然而我们的判断终止条件是为0（补1的话是永远不可能移到0的…），因此要先把有符号数转成无符号数再处理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x = num, bit;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            bit = x &amp; <span class="number">0XF</span>;</span><br><span class="line">            ans += bit &gt; <span class="number">9</span> ? bit - <span class="number">10</span> + <span class="string">'a'</span> : bit + <span class="string">'0'</span>;</span><br><span class="line">            x &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode409 Longest Palindrome</title>
      <link href="/posts/leetcode409-longest-palindrome/"/>
      <url>/posts/leetcode409-longest-palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example <code>&quot;Aa&quot;</code> is not considered a palindrome here.</p><p><strong>Note:</strong><br>Assume the length of given string will not exceed 1,010.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>问从输入的字符串中任意挑选出字符所能够组成的最长回文串的长度是多少。每个字符只能用一次，也可以不用。</p><p>一看题目还以为求最长回文子串，<code>Manacher</code>算法走起啊… 然而仔细看题并不是，其实只是一个模拟。首先统计出所有字符的个数，然后偶数个的通通加进来，奇数个的就扣掉一个变成偶数再加进来。注意，如果存在某个字符的个数是奇数的话，答案长度可以再加1，因为可以把这个字符放在中间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(c)) cnt[c-<span class="string">'A'</span>][<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">else</span> cnt[c-<span class="string">'a'</span>][<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, add = <span class="number">0</span>, cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                cur = cnt[i][j];</span><br><span class="line">                <span class="keyword">if</span> (cur &amp; <span class="number">1</span>) add = <span class="number">1</span>;</span><br><span class="line">                ans += cur - (cur &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode189 Rotate Array</title>
      <link href="/posts/leetcode189-rotate-array/"/>
      <url>/posts/leetcode189-rotate-array/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For example, with n = 7 and k = 3, </span><br><span class="line">the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将数组中每个元素循环右移k位。</p><p>不妨记A = [1, 2, 3, 4]，B = [5, 6, 7]，其目标就是是将原数组从 AB 变成 BA，所以可以运用$BA = (A^TB^T)^T$这一性质。注：$A^T$的意思是将数组$A$中元素翻转。</p><p><img src="https://tuchuang001.com/images/2017/02/03/leetcode.png" alt="leetCode189"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(nums[l++], nums[r--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        k %= n; <span class="comment">// 去掉无意义的移动</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, n - k, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode8 String to Integer (atoi)</title>
      <link href="/posts/leetcode8-string-to-integer-atoi/"/>
      <url>/posts/leetcode8-string-to-integer-atoi/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Implement atoi to convert a string to an integer.</p><p><strong>Hint:</strong> Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p><p><strong>Notes:</strong> It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: </span><br><span class="line">123</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实现$atoi$函数，这是一个将字符串转成$int$的函数。</p><p>这题坑爹的是要考虑所有可能的输入情况，然后又不给你样例…(#‵ ′)凸</p><p>自认为考虑周到了，符号啊，溢出啊，非法字符啊都考虑了，但是提交却WA了几遍…</p><p>第一次WA在输入可能有前导空白，比如 <code>&quot;   123&quot;</code>  。。第二次WA在正数的符号处理，比如像<code>+1</code>  （orz…只处理了’-‘的情况，没想到正数前面也可能加个’+’）。。</p><p>总的来说，$atoi$函数处理的方式应该是，先忽略前导空白符，再判断是否有+-符号，然后处理到第一个非法字符（不是0-9）为止。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, sign = <span class="number">1</span>, n = str.size();</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; n &amp;&amp; <span class="built_in">isspace</span>(str[l]); ++l); <span class="comment">// 处理空白符</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; str[l] == <span class="string">'-'</span>) sign = <span class="number">-1</span>, ++l; <span class="comment">// 处理符号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; n &amp;&amp; str[l] == <span class="string">'+'</span>) sign = <span class="number">1</span>, ++l;</span><br><span class="line">        <span class="keyword">for</span> (r = l; r &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[r]); ++r); <span class="comment">// 找到第一个非法字符</span></span><br><span class="line">        str = str.substr(l, r - l); <span class="comment">// 合法数字的子串</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c: str) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (sign * num &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (sign * num &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode7 Reverse Integer</title>
      <link href="/posts/leetcode7-reverse-integer/"/>
      <url>/posts/leetcode7-reverse-integer/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Reverse digits of an integer.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example1: x = 123, return 321</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example2: x = -123, return -321</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将一个int类型数字翻转。</p><p>只要注意两点：<strong>符号</strong>和<strong>溢出</strong>。虽然输入是<code>int</code>类型，但是翻转之后不保证也在<code>int</code>范围内，比如说<code>1000000007</code>（十亿零七）翻转之后变成<code>7000000001</code>（七十亿零一），已经超过INT_MAX（2147483647）了，溢出就直接输出0即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sign = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) sign = <span class="number">-1</span>, x = -x;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans *= sign;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; INT_MAX || ans &lt; INT_MIN) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode121 Best Time to Buy and Sell Stock</title>
      <link href="/posts/leetcode121-best-time-to-buy-and-sell-stock/"/>
      <url>/posts/leetcode121-best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">max. difference = 6-1 = 5 (not 7-1 = 6, </span><br><span class="line">as selling price needs to be larger than buying price)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7, 6, 4, 3, 1]</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给出$N$天的股价，在只能做一次交易的情况下，问最大收益是多少。</p><p>考虑第$i$天卖出的最大收益，其实就是等于第$i$天的价格减去前$i-1$天的最低价格，即<script type="math/tex">prices[i] - min \{ prices[k] \ |\  k = 1..i-1 \}</script> ，那么只要维护一个当前最小值就好了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, curMin = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: prices) &#123;</span><br><span class="line">            ans = max(ans, x - curMin);</span><br><span class="line">            curMin = min(curMin, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode13 Roman to Integer</title>
      <link href="/posts/leetcode13-roman-to-integer/"/>
      <url>/posts/leetcode13-roman-to-integer/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a roman numeral, convert it to an integer.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">XI</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: </span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将罗马数字转换成十进制数。</p><p>对罗马数字的转换规则并不是很熟悉，搜索之后也看得一脸懵逼…</p><blockquote><p>来源： <a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97" target="_blank" rel="noopener">维基百科—罗马数字</a></p><ul><li>重复数次：一个罗马数字重复几次，就表示这个数的几倍。</li><li>右加左减：<ul><li>在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。</li><li>在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。</li><li>但是，左减时不可跨越一个位值。</li><li>左减数字必须为一位。</li><li>右加数字不可连续超过三位。</li></ul></li><li>加线乘千：<ul><li>在罗马数字的上方加上一条横线或者加上下标的Ⅿ，表示将这个数乘以1000，即是原数的1000倍。</li><li>同理，如果上方有两条横线，即是原数的1000000倍。</li></ul></li><li>数码限制：<ul><li>同一数码最多只能连续出现三次，如40不可表示为XXXX，而要表示为XL。</li><li>例外：由于IV是古罗马神话主神朱庇特（即IVPITER，古罗马字母里没有J和U）的首字，因此有时用IIII代替IV。</li></ul></li></ul></blockquote><p>好在本题只要求罗马数字转十进制且数字范围不大，我们其实只要关注<strong>重复数次</strong>和<strong>右加左减</strong>这两个规则。简单来说，就是直接把所有数字都加起来，再扣掉“左减”的贡献即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hs[<span class="string">'I'</span>] = <span class="number">1</span>;   hs[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        hs[<span class="string">'X'</span>] = <span class="number">10</span>;  hs[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        hs[<span class="string">'C'</span>] = <span class="number">100</span>; hs[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        hs[<span class="string">'M'</span>] = <span class="number">1000</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        initMap();</span><br><span class="line">        <span class="keyword">int</span> ans = hs[s[<span class="number">0</span>]], n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs[s[i<span class="number">-1</span>]] &lt; hs[s[i]]) ans += hs[s[i]] - <span class="number">2</span>*hs[s[i<span class="number">-1</span>]];</span><br><span class="line">            <span class="keyword">else</span> ans += hs[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode206 Reverse Linked List</title>
      <link href="/posts/leetcode206-reverse-linked-list/"/>
      <url>/posts/leetcode206-reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Reverse a singly linked list.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1 -&gt; 2 -&gt; 3</span><br><span class="line">Output: 3 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>翻转链表。</p><p>建pre和next指针，然后理清指针之间该怎么交换就好了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode217 Contains Duplicate</title>
      <link href="/posts/leetcode217-contains-duplicate/"/>
      <url>/posts/leetcode217-contains-duplicate/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1 2 2 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断数组中是否有重复的数字。</p><p>map记录下即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) <span class="keyword">if</span> (++hs[x] &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode231 Power of Two</title>
      <link href="/posts/leetcode231-power-of-two/"/>
      <url>/posts/leetcode231-power-of-two/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer, write a function to determine if it is a power of two.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否为2的次幂。</p><p>显然2次幂在二进制表示中只有一个1，所以可以用<a href="/2017/01/21/LeetCode338-Counting-Bits">LeetCode338 Counting Bits</a>中的方法计算1的个数。</p><p>其实还有比较简单的方法是，将这个“1”去掉，看得到的数是否为0，为0说明二进制中只有一个1。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> bitCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n &amp;= (n<span class="number">-1</span>), bitCount++);</span><br><span class="line">       <span class="keyword">return</span> bitCount == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; (n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Matlab Tutorial</title>
      <link href="/posts/matlab-tutorial/"/>
      <url>/posts/matlab-tutorial/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 元素操作</span></span><br><span class="line"><span class="number">5</span>+<span class="number">6</span></span><br><span class="line"><span class="number">3</span><span class="number">-2</span></span><br><span class="line"><span class="number">5</span>*<span class="number">8</span></span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">2</span>^<span class="number">6</span> <span class="comment">% 次方，不是异或</span></span><br><span class="line"><span class="number">1</span> == <span class="number">2</span> <span class="comment">% 假</span></span><br><span class="line"><span class="number">1</span> ~= <span class="number">2</span> <span class="comment">% 真  注意，不是用 "!="</span></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> || <span class="number">0</span></span><br><span class="line">xor(<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 变量赋值</span></span><br><span class="line">a = <span class="number">3</span>; <span class="comment">% 加分号就不会立即输出</span></span><br><span class="line">b = <span class="string">'hi'</span>;</span><br><span class="line">c = <span class="number">3</span>&gt;=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 显示</span></span><br><span class="line">a = <span class="built_in">pi</span></span><br><span class="line"><span class="built_in">disp</span>(a)</span><br><span class="line"><span class="built_in">disp</span>(sprintf(<span class="string">'2 decimals: %0.2f'</span>, a)) <span class="comment">% 类似C中printf</span></span><br><span class="line"><span class="built_in">disp</span>(sprintf(<span class="string">'6 decimals: %0.6f'</span>, a))</span><br><span class="line">format long <span class="comment">% 改变显示的格式</span></span><br><span class="line">a</span><br><span class="line">format short</span><br><span class="line">a</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  向量和矩阵</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">4</span>; <span class="number">5</span> <span class="number">6</span>] <span class="comment">% 3x2矩阵</span></span><br><span class="line"></span><br><span class="line">v = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]   <span class="comment">% 行向量</span></span><br><span class="line">v = [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>] <span class="comment">% 列向量</span></span><br><span class="line">v = <span class="number">1</span>:<span class="number">0.1</span>:<span class="number">2</span>   <span class="comment">% 从1到2，步长为0.1</span></span><br><span class="line">v = <span class="number">1</span>:<span class="number">6</span>       <span class="comment">% 从1到6，默认步长为1</span></span><br><span class="line"></span><br><span class="line">C = <span class="number">2</span>*<span class="built_in">ones</span>(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">% 等同于 C = [2 2 2; 2 2 2]</span></span><br><span class="line">w = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>)   <span class="comment">% 1x3 的全一向量</span></span><br><span class="line">w = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>)  <span class="comment">% 1x3 的全零向量</span></span><br><span class="line">w = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">3</span>)   <span class="comment">% 1x3矩阵，元素的值在(0,1)之间，产生于均匀分布</span></span><br><span class="line">w = <span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">3</span>)  <span class="comment">% 1x3矩阵，产生于标准正态分布</span></span><br><span class="line">w = <span class="number">-6</span> + <span class="built_in">sqrt</span>(<span class="number">10</span>)*(<span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">10000</span>));  </span><br><span class="line">hist(w)    <span class="comment">% 绘制直方图，默认10等分</span></span><br><span class="line">hist(w,<span class="number">50</span>) <span class="comment">% 绘制直方图，50等分</span></span><br><span class="line"></span><br><span class="line">I = <span class="built_in">eye</span>(<span class="number">4</span>)   <span class="comment">% 4x4 单位矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% help 函数，可以查看每个函数的说明</span></span><br><span class="line">help <span class="built_in">eye</span></span><br><span class="line">help <span class="built_in">rand</span></span><br><span class="line">help help</span><br></pre></td></tr></table></figure><h2 id="Moving-Data-Around"><a href="#Moving-Data-Around" class="headerlink" title="Moving Data Around"></a>Moving Data Around</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 维数</span></span><br><span class="line">sz = <span class="built_in">size</span>(A) <span class="comment">% 返回1x2 矩阵: [行数, 列数]</span></span><br><span class="line"><span class="built_in">size</span>(A,<span class="number">1</span>) <span class="comment">% 行数</span></span><br><span class="line"><span class="built_in">size</span>(A,<span class="number">2</span>) <span class="comment">% 列数</span></span><br><span class="line"><span class="built_in">length</span>(v) <span class="comment">% 最长维的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">pwd   <span class="comment">% 显示当前路径</span></span><br><span class="line">cd <span class="string">'C:\Users\ang\Octave files'</span>  <span class="comment">% 改变目录</span></span><br><span class="line">ls    <span class="comment">% 显示当前目录下的文件</span></span><br><span class="line">load q1y.dat   <span class="comment">% 也可写成 load('q1y.dat')</span></span><br><span class="line">load q1x.dat</span><br><span class="line">who   <span class="comment">% 显示当前工作空间的变量</span></span><br><span class="line">whos  <span class="comment">% 显示当前工作空间变量的详细信息</span></span><br><span class="line">clear q1y      <span class="comment">% 若没有指定变量名，则清空当前工作空间的全部变量</span></span><br><span class="line">v = q1x(<span class="number">1</span>:<span class="number">10</span>); <span class="comment">% q1x的前10个元素 (按列数下来)</span></span><br><span class="line">save hello.mat v;  <span class="comment">% 将变量v的内容保存在hello.mat里</span></span><br><span class="line">save hello.txt v -ascii; <span class="comment">% 以ascii码保存</span></span><br><span class="line"><span class="comment">% fopen, fread, fprintf, fscanf </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 索引</span></span><br><span class="line">A(<span class="number">3</span>,<span class="number">2</span>)  <span class="comment">% (行, 列)</span></span><br><span class="line">A(<span class="number">2</span>,:)  <span class="comment">% 得到第二行</span></span><br><span class="line">        <span class="comment">% ":" 意味着得到那一维的所有元素</span></span><br><span class="line">A(:,<span class="number">2</span>)  <span class="comment">% 得到第二列</span></span><br><span class="line">A([<span class="number">1</span> <span class="number">3</span>],:) <span class="comment">% 得到第1和第3行的元素</span></span><br><span class="line"></span><br><span class="line">A(:,<span class="number">2</span>) = [<span class="number">10</span>; <span class="number">11</span>; <span class="number">12</span>]     <span class="comment">% 改变第二行的元素</span></span><br><span class="line">A = [A, [<span class="number">100</span>; <span class="number">101</span>; <span class="number">102</span>]]; <span class="comment">% 加一列</span></span><br><span class="line">A(:) <span class="comment">% 以列向量的形式展示矩阵A中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将数据放在一起</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">4</span>; <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">B = [<span class="number">11</span> <span class="number">12</span>; <span class="number">13</span> <span class="number">14</span>; <span class="number">15</span> <span class="number">16</span>] <span class="comment">% 和A同维</span></span><br><span class="line">C = [A B]  <span class="comment">% A、B并排</span></span><br><span class="line">C = [A, B] <span class="comment">% A、B并排</span></span><br><span class="line">C = [A; B] <span class="comment">% A、B上下排列</span></span><br></pre></td></tr></table></figure><h2 id="Computing-on-Data"><a href="#Computing-on-Data" class="headerlink" title="Computing on Data"></a>Computing on Data</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 初始化变量</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>;<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">B = [<span class="number">11</span> <span class="number">12</span>;<span class="number">13</span> <span class="number">14</span>;<span class="number">15</span> <span class="number">16</span>]</span><br><span class="line">C = [<span class="number">1</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">v = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 矩阵操作</span></span><br><span class="line">A * C  <span class="comment">% 矩阵乘法</span></span><br><span class="line">A .* B <span class="comment">% 逐元素相乘</span></span><br><span class="line"><span class="comment">% A .* C  or A * B 会得到错误 </span></span><br><span class="line">A .^ <span class="number">2</span> <span class="comment">% 对A中每个元素都平方</span></span><br><span class="line"><span class="number">1.</span>/v   <span class="comment">% 对v中每个元素取倒数</span></span><br><span class="line"><span class="comment">% 以下三个函数，对标量、向量、矩阵都适用</span></span><br><span class="line"><span class="built_in">log</span>(v)  </span><br><span class="line"><span class="built_in">exp</span>(v)</span><br><span class="line"><span class="built_in">abs</span>(v)</span><br><span class="line"></span><br><span class="line">-v  <span class="comment">% -1*v</span></span><br><span class="line"></span><br><span class="line">v + <span class="built_in">ones</span>(<span class="built_in">length</span>(v), <span class="number">1</span>)  </span><br><span class="line"><span class="comment">% v中每个元素都加1，也可写成 v + 1</span></span><br><span class="line"></span><br><span class="line">A'  <span class="comment">% 矩阵转置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 一些有用的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% max  (or min)</span></span><br><span class="line">a = [<span class="number">1</span> <span class="number">15</span> <span class="number">2</span> <span class="number">0.5</span>]</span><br><span class="line">val = <span class="built_in">max</span>(a)</span><br><span class="line">[val,ind] = <span class="built_in">max</span>(a) <span class="comment">% 返回最大的元素，及其第一次出现的下标</span></span><br><span class="line">val = <span class="built_in">max</span>(A) <span class="comment">% 返回矩阵A中每列的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 比较</span></span><br><span class="line">a &lt; <span class="number">3</span> <span class="comment">% 检查a是否小于3</span></span><br><span class="line"><span class="built_in">find</span>(a &lt; <span class="number">3</span>) <span class="comment">% 找出a中所有小于3的位置, 按列数</span></span><br><span class="line">A = <span class="built_in">magic</span>(<span class="number">3</span>) <span class="comment">% 生成3阶幻方</span></span><br><span class="line">[r,c] = <span class="built_in">find</span>(A&gt;=<span class="number">7</span>)  <span class="comment">% 返回A&gt;=7的元素的横纵坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% sum, prod</span></span><br><span class="line">sum(a)  <span class="comment">% 按列求和</span></span><br><span class="line">prod(a) <span class="comment">% 按列求积</span></span><br><span class="line"><span class="built_in">floor</span>(a)<span class="comment">% 向下取整</span></span><br><span class="line"><span class="built_in">ceil</span>(a) <span class="comment">% 向上取整</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">rand</span>(<span class="number">3</span>),<span class="built_in">rand</span>(<span class="number">3</span>)) <span class="comment">% 逐元素比较大小</span></span><br><span class="line"><span class="built_in">max</span>(A,[],<span class="number">1</span>) <span class="comment">% 返回矩阵A中每列的最大值, 等于max(A)</span></span><br><span class="line"><span class="built_in">max</span>(A,[],<span class="number">2</span>) <span class="comment">% 返回矩阵A中每行的最大值</span></span><br><span class="line">A = <span class="built_in">magic</span>(<span class="number">9</span>)</span><br><span class="line">sum(A,<span class="number">1</span>) <span class="comment">% 按列求和</span></span><br><span class="line">sum(A,<span class="number">2</span>) <span class="comment">% 按行求和</span></span><br><span class="line">sum(sum( A .* <span class="built_in">eye</span>(<span class="number">9</span>) )) <span class="comment">% 主对角线求和</span></span><br><span class="line">sum(sum( A .* <span class="built_in">flipud</span>(<span class="built_in">eye</span>(<span class="number">9</span>)) )) <span class="comment">% 副对角线求和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 矩阵伪逆 (pseudo-inverse)</span></span><br><span class="line">pinv(A)        <span class="comment">% 等于inv(A'*A)*A'</span></span><br></pre></td></tr></table></figure><h2 id="Plotting-Data"><a href="#Plotting-Data" class="headerlink" title="Plotting Data"></a>Plotting Data</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 绘图</span></span><br><span class="line">t = [<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.98</span>];</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">4</span>*t);</span><br><span class="line"><span class="built_in">plot</span>(t,y1); <span class="comment">% 见pic1</span></span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/02/02/pic1.png" alt="pic1" width="50%" height="50%"><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y2 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">4</span>*t);</span><br><span class="line"><span class="built_in">hold</span> on;  <span class="comment">% 保持当前图像，"hold off"关闭</span></span><br><span class="line"><span class="built_in">plot</span>(t,y2,<span class="string">'r'</span>); <span class="comment">% 见pic2</span></span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/02/02/pic2.png" alt="pic2" width="50%" height="50%"><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xlabel(<span class="string">'time'</span>); <span class="comment">% 横轴标识符</span></span><br><span class="line">ylabel(<span class="string">'value'</span>); <span class="comment">% 纵轴标识符</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'sin'</span>,<span class="string">'cos'</span>); <span class="comment">% 图例</span></span><br><span class="line">title(<span class="string">'my plot'</span>); <span class="comment">% 标题</span></span><br><span class="line"><span class="comment">% 见pic3</span></span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/02/02/pic3.png" alt="pic3" width="50%" height="50%"><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print -dpng <span class="string">'myPlot.png'</span> <span class="comment">% 保存当前图片</span></span><br><span class="line">close;           <span class="comment">% 关闭当前图片</span></span><br></pre></td></tr></table></figure></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>); <span class="built_in">plot</span>(t, y1); <span class="comment">% 在figure1中绘制图像</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>); <span class="built_in">plot</span>(t, y2); <span class="comment">% 在figure2中绘制图像</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>), clf;  <span class="comment">% 清空figure2中的图像</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);  <span class="comment">% 创建 1x2 的子图, 并访问第一个子图</span></span><br><span class="line"><span class="built_in">plot</span>(t,y1); <span class="comment">% 图像绘制在第一个子图上,见pic4</span></span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/02/02/pic4.png" alt="pic4" width="50%" height="50%"><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);  <span class="comment">% 创建 1x2 的子图, 并访问第二个子图</span></span><br><span class="line"><span class="built_in">plot</span>(t,y2); <span class="comment">% 图像绘制在第二个子图上,见pic5</span></span><br><span class="line">axis([<span class="number">0.5</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>]);  <span class="comment">% 改变坐标轴范围</span></span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/02/02/pic5.png" alt="pic5" width="50%" height="50%"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 将矩阵以图像显示,见pic6</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">imagesc(<span class="built_in">magic</span>(<span class="number">15</span>)), colorbar, colormap gray;</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/02/02/pic6.png" alt="pic6" width="50%" height="50%"></p><h2 id="Control-statements"><a href="#Control-statements" class="headerlink" title="Control statements"></a>Control statements</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% for 循环</span></span><br><span class="line">v = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    v(<span class="built_in">i</span>) = <span class="number">2</span>^<span class="built_in">i</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% while 循环</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span> &lt;= <span class="number">5</span></span><br><span class="line">  v(<span class="built_in">i</span>) = <span class="number">100</span>; </span><br><span class="line">  <span class="built_in">i</span> = <span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% break、continue</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">true</span>, </span><br><span class="line">  v(<span class="built_in">i</span>) = <span class="number">999</span>; </span><br><span class="line">  <span class="built_in">i</span> = <span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">i</span> == <span class="number">6</span>,</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% if-else 语句</span></span><br><span class="line"><span class="keyword">if</span> v(<span class="number">1</span>)==<span class="number">1</span>,</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'The value is one!'</span>);</span><br><span class="line"><span class="keyword">elseif</span> v(<span class="number">1</span>)==<span class="number">2</span>,</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'The value is two!'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'The value is not one or two!'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[输出实参表]</span> = 函数名<span class="params">(输入实参数)</span></span></span><br><span class="line">    注释部分</span><br><span class="line">    函数体语句</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">定义:</span><br><span class="line"><span class="comment">% foo.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x, y]</span> = <span class="title">foo</span><span class="params">(a, b)</span></span></span><br><span class="line">    x = a + b;</span><br><span class="line">    y = a - b;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">调用:</span><br><span class="line">&gt;&gt; a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">&gt;&gt; [x, y] = foo(a, b)</span><br><span class="line">x =</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">y =</span><br><span class="line">    <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coursera Machine Learning 多元线性回归和多项式回归</title>
      <link href="/posts/coursera-linear-regression-with-multiple-variables-and-polynomial-regression/"/>
      <url>/posts/coursera-linear-regression-with-multiple-variables-and-polynomial-regression/</url>
      
        <content type="html"><![CDATA[<h2 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h2><h3 id="多特征"><a href="#多特征" class="headerlink" title="多特征"></a>多特征</h3><ul><li><p>$x^{(i)}$ ：第i个训练数据</p></li><li><p>$x_j^{(i)}$ ：第$i$个数据的第$j$个特征</p></li><li><p>$m$ ：训练集大小</p></li><li><p>$n$ ：特征数量</p></li></ul><script type="math/tex; mode=display">\begin{align*}h_\theta (x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_3 + \cdots + \theta_n x_n \newline =\begin{bmatrix}\theta_0 \hspace{2em} \theta_1 \hspace{2em} ... \hspace{2em} \theta_n\end{bmatrix}\begin{bmatrix}x_0 \newline x_1 \newline \vdots \newline x_n\end{bmatrix}= \theta^T x\end{align*}</script><p>若对整个数据集进行运算，有：$h_\theta(X) = X \theta$</p><a id="more"></a><h3 id="多变量的梯度下降"><a href="#多变量的梯度下降" class="headerlink" title="多变量的梯度下降"></a>多变量的梯度下降</h3><ul><li>Gradient Descent(梯度下降算法)</li></ul><script type="math/tex; mode=display">\begin{align*}& \text{repeat until convergence:} \; \lbrace \newline \; & \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; & \text{for j := 0...n}\newline \rbrace\end{align*}</script><p>  矩阵形式：$\theta := \theta - \frac{\alpha}{m} X^{T} (X\theta - \vec{y})$</p><ul><li><p>Feature Scaling(特征缩放)</p><p>用原始数据除以该数据的范围（即RANGE = MAX-MIN)，或除以标准差。</p></li></ul><ul><li><p>Mean Normalization(均值归一化)</p><p>用原始数据减去该数据的均值。</p><p>运用上述两种技术，得到公式：$x_i := \dfrac{x_i - \mu_i}{s_i}$，其中$\mu_i$是$x$的平均值，${s_i}$是$x$的标准差。</p></li><li><p>Learning Rate(学习率)</p><p>α过小：慢收敛</p><p>α过大：每次迭代可能不会使J值减小，可能因此导致发散</p></li></ul><h3 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h3><p>有的时候线性回归不能很好的拟合数据，这个时候可以考虑用多项式回归。</p><p><img src="https://tuchuang001.com/images/2017/01/30/28714028-file_1485591952299_1166.png" alt="Polynomial Regression"></p><p>比如对于 $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_1^2 + \theta_3 x_1^3$ 这个函数来说，我们可以新建两个变量$x_2$ 、 $x_3$ 使得 $ x_2 = x_1^{2} $ 、$ x_3 = x_1^{3}$ ，从而转化成线性回归的形式，得到 $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_3$</p><h2 id="分析法计算参数"><a href="#分析法计算参数" class="headerlink" title="分析法计算参数"></a>分析法计算参数</h2><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>正规方程（Normal Equation）</p><p>formula ：$\theta = (X^T X)^{-1}X^T y$</p><p><strong>注意</strong>：其中矩阵的逆是伪逆矩阵，即<a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse" target="_blank" rel="noopener">Moore–Penrose pseudoinverse</a>，在Matlab中可用<code>pinv</code>计算。</p><p>这个公式可以直接算出$\theta$的值，不需要像梯度下降那样进行迭代，也不需要进行<code>Feature scaling</code>和<code>Mean normalization</code>。</p><p><strong>对比</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Gradient Descent</th><th style="text-align:left">Normal Equation</th></tr></thead><tbody><tr><td style="text-align:left">Need to choose alpha</td><td style="text-align:left">No need to choose alpha</td></tr><tr><td style="text-align:left">Needs many iterations</td><td style="text-align:left">No need to iterate</td></tr><tr><td style="text-align:left"><script type="math/tex">O(kn^2)</script></td><td style="text-align:left"><script type="math/tex">O(n^3)</script>, need to calculate inverse of <script type="math/tex">X^TX</script></td></tr><tr><td style="text-align:left">Works well when n is large</td><td style="text-align:left">Slow if n is very large</td></tr></tbody></table></div><h3 id="可逆性问题"><a href="#可逆性问题" class="headerlink" title="可逆性问题"></a>可逆性问题</h3><p>如果$X^TX$不可逆，主要有以下两种原因：</p><ul><li>有多余的特征，且这些特征线性相关</li><li>特征过多，比如说特征数(n)比样本数(m)还多</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode100 Same Tree</title>
      <link href="/posts/leetcode100-same-tree/"/>
      <url>/posts/leetcode100-same-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断两颗二叉树是否相等，必须结构相等且值也相等。</p><p>dfs时，对p和q是否为空进行分类讨论。在p、q都不为空时，再判断下节点值是否相等。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode122 Best Time to Buy and Sell Stock II</title>
      <link href="/posts/leetcode122-best-time-to-buy-and-sell-stock-ii/"/>
      <url>/posts/leetcode122-best-time-to-buy-and-sell-stock-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1, 2, 100, 10]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">99</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给出每天的股价，每天只能进行一笔交易，可以买入或卖出，问最大的盈利是多少。</p><p>如果价格在$[i, j]$天呈现 <script type="math/tex">price_{i} < price_{i+1} < ... < price_{j}</script>的趋势，那么在第<script type="math/tex">i</script>天买入，第<script type="math/tex">j</script>天卖出，至少可以使得利润不会变得更差。</p><p><img src="https://tuchuang001.com/images/2017/01/30/40813449-file_1485584650990_4767.png" alt="示例图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i]) &#123;</span><br><span class="line">                ans += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode169 Majority Element</title>
      <link href="/posts/leetcode169-majority-element/"/>
      <url>/posts/leetcode169-majority-element/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1, 2, 2, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出数组中出现次数大于$⌊ n/2 ⌋$次的元素。</p><p>一个直观的想法是用$map$记录每个数字出现的次数然后再比较是否大于指定的次数即可。当然，分治也可以做，每次划分成子区间去找，合并的时候看那个出现的次数更多。这两个做法复杂度都是$\mathcal{O}(nlogn)$的。</p><p>其实也有线性复杂度的做法。先讲一下位运算的做法，出现次数大于$n/2$次的元素，显然其对应的二进制位出现的次数肯定也大于$n/2$次，所以枚举二进制位然后判断一下次数即可。</p><p>然后再介绍一个神奇的算法<strong>Moore Voting Algorithm</strong>，具体可以参阅<a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html" target="_blank" rel="noopener">A Linear Time Majority Vote Algorithm</a><br>主要思想是将两两不同的数相互抵消，剩下没有消掉的肯定是次数超过一半的数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>哈希：</strong> $\mathcal{O}(nlogn)$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) <span class="keyword">if</span> (++hashTable[x] &gt; times) <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>分治：</strong>$\mathcal{O}(nlogn)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lans = find(nums, l, m), rans = find(nums, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">int</span> lcnt = <span class="number">0</span>, rcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == lans) lcnt++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == rans) rcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcnt &gt; rcnt ? lans : rans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>位运算</strong>：$\mathcal{O}(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mask = <span class="number">1</span>, times = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i, mask &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// 枚举二进制位</span></span><br><span class="line">            <span class="keyword">int</span> bitCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) <span class="keyword">if</span> (x &amp; mask) bitCount++; </span><br><span class="line">            <span class="keyword">if</span> (bitCount &gt; times) ans |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Moore Voting Algorithm：</strong>$\mathcal{O}(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt) cnt++, ans = x; <span class="comment">// 若没有候选答案，则把当前这个数作为候选答案</span></span><br><span class="line">            <span class="keyword">else</span> ans == x ? cnt++ : cnt--; <span class="comment">// 比较当前的数和候选答案是否相等，不相等则消掉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode171 Excel Sheet Column Number</title>
      <link href="/posts/leetcode171-excel-sheet-column-number/"/>
      <url>/posts/leetcode171-excel-sheet-column-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给出excel表头相应的数字。</p><p>水题…二十六进制的转换。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) ans = ans * <span class="number">26</span> + c - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode237 Delete Node in a Linked List</title>
      <link href="/posts/leetcode237-delete-node-in-a-linked-list/"/>
      <url>/posts/leetcode237-delete-node-in-a-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 </span><br><span class="line">and you are given the third node with value 3, </span><br><span class="line">the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>删除链表中某个指定的结点。</p><p>一个显然的做法就是拿后继<code>node-&gt;next</code>去覆盖当前这个<code>node</code>结点。</p><p>好了，代码就一行<code>node = node-&gt;next</code>，但submit后WA了…orz</p><p>其实这样写虽然是将指向node的指针指向了其后继结点，但是node前驱的后继指针却没有改变，因此实际上链表根本就没有被改变。</p><p>正确的写法应该是去更改内容，而不是更改指针。即<code>*node = *(node-&gt;next)</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        *node = *(node-&gt;next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode242 Valid Anagram</title>
      <link href="/posts/leetcode242-valid-anagram/"/>
      <url>/posts/leetcode242-valid-anagram/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given two strings <em>s</em> and <em>t</em>, write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p><p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.</span><br><span class="line">s = &quot;rat&quot;, t = &quot;car&quot;, return false.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断两个字符串是否“相等”（即字符的顺序不重要，只需比较每个字符的个数）。</p><p>模拟，用cnt数组记录每个字符的个数，比较下即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cnt2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) cnt1[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t) cnt2[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] != cnt2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode258 Add Digits</title>
      <link href="/posts/leetcode258-add-digits/"/>
      <url>/posts/leetcode258-add-digits/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.</p><p><strong>Follow up:</strong><br>Could you do it without any loop/recursion in O(1) runtime?</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. </span><br><span class="line">Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个非负数，每次将其替换为它的各位数字之和，直到为这个数只有一位为止。(其实就是求一个数的<a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank" rel="noopener">digital root</a>)</p><p>直接模拟显然是可以的，那么考虑如何$\mathcal{O}(1)$算出答案。</p><p>对任意一个数 $n$ 来说，可以将其表示为</p><p>$n = a_{n-1} \ast 10^{n-1} + a_{n-2} \ast 10^{n-2} + … a_{1} \ast 10^{1} + a_{0} \ast 10^{0}$</p><p>同时注意到，10的任意次方模9都为1，则</p><p>$ n \equiv a_{n-1} \ast 1 + a_{n-2} \ast 1 + … a_{1} \ast 1 + a_{0} \ast 1 (mod  9) $</p><p>右边就是$n$的各位数之和，然后把它赋给$n$不断迭代即可。</p><p><strong>结论：</strong></p><p><img src="https://tuchuang001.com/images/2017/01/30/digitalroot.png" alt="digital root"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = num % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">return</span> ans ? ans : <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode387 First Unique Character in a String</title>
      <link href="/posts/leetcode387-first-unique-character-in-a-string/"/>
      <url>/posts/leetcode387-first-unique-character-in-a-string/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出在字符串中只出现过一次的字符的下标。</p><p>水题…统计一遍即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;, i = <span class="number">0</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) cnt[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c-<span class="string">'a'</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode404 Sum of Left Leaves</title>
      <link href="/posts/leetcode404-sum-of-left-leaves/"/>
      <url>/posts/leetcode404-sum-of-left-leaves/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Find the sum of all left leaves in a given binary tree.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一颗二叉树，求所有左叶子节点的和。</p><p>首先叶子节点比较好判断，只要知道它的左右儿子是否都为空即可。</p><p>由于函数的参数只传了该节点的信息进去，没有传入该节点是父节点的左儿子还是右儿子等信息，所以难点主要在于怎么判断一个节点是否是左叶子节点。</p><p>针对这一点，我们必须提前到父节点进行判断。</p><p>父节点只需对其左儿子进行判断，如果这个左儿子是叶子节点，则该左儿子就对答案有贡献。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) &#123; <span class="comment">// 左儿子不为空</span></span><br><span class="line">            <span class="comment">// 左儿子为叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) ans += root-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">else</span> ans += sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode453 Minimum Moves to Equal Array Elements</title>
      <link href="/posts/leetcode453-minimum-moves-to-equal-array-elements/"/>
      <url>/posts/leetcode453-minimum-moves-to-equal-array-elements/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a <strong>non-empty</strong> integer array of size <em>n</em>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <em>n</em> - 1 elements by 1.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only three moves are needed (remember each move increments two elements):</span><br><span class="line"></span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个非空数组，每操作一次可以给其中$n-1$个数加1，问至少要操作多少次可以让数组中每个数都相等。</p><p>（这是easy分类的题目，但是感觉身体被掏空，写了几次都WA了… </p><p>其实这题从反面来看比较好考虑，每次让$n-1$个数加1，其实等价于让一个数减1。所以问题就等价于每次让一个数减1，问要经过多少次后能让所有数相等。答案即为$sum - n * minMum$。（也就是所有数都减到最小的那个数为止）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minNum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x: nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            minNum = min(minNum, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - nums.size() * minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode349 Intersection of Two Arrays</title>
      <link href="/posts/leetcode349-intersection-of-two-arrays/"/>
      <url>/posts/leetcode349-intersection-of-two-arrays/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Note:</strong></p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求两个数组的交集。注意答案中不能有重复的元素。</p><p><strong>二分：</strong><br>先对nums1排序，然后遍历nums2中每个元素，对每个元素用二分查找是否存在于nums1中，去重可用map维护。</p><p><strong>双指针：</strong><br>对nums1和nums2都排序，当双指针指向相同的数时加到答案里即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>二分：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; hashTable;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums2) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = lower_bound(nums1.begin(), nums1.end(), x);</span><br><span class="line">            <span class="keyword">if</span> (iter != nums1.end() &amp;&amp; *iter == x &amp;&amp; !hashTable.count(x)) &#123;</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">                hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>双指针：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; hashTable;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hashTable.count(nums1[i])) ans.push_back(nums1[i]);</span><br><span class="line">                hashTable[nums1[i]] = <span class="literal">true</span>;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>优雅的实现：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums2) <span class="keyword">if</span> (s.erase(x)) ans.push_back(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode383 Ransom Note</title>
      <link href="/posts/leetcode383-ransom-note/"/>
      <url>/posts/leetcode383-ransom-note/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p><p>Each letter in the magazine string can only be used once in your ransom note.</p><p><strong>Note:</strong><br>You may assume that both strings contain only lowercase letters.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给两个字符串，在第二个串中每个字母只能使用一次的情况下，问能否构造得到第一个串。</p><p>首先遍历第二个串，得到每个字母的个数，然后再遍历第一个串，看对应字母的个数是否足够即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch: magazine) cnt[ch-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch: ransomNote) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--cnt[ch-<span class="string">'a'</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coursera Machine Learning 一元线性回归和梯度下降</title>
      <link href="/posts/coursera-linear-regression-with-one-variable-and-gradient-descent/"/>
      <url>/posts/coursera-linear-regression-with-one-variable-and-gradient-descent/</url>
      
        <content type="html"><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>有监督学习，即从标签化的数据中进行训练学习。</p><blockquote><p>In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.</p></blockquote><a id="more"></a><h3 id="回归-Regression"><a href="#回归-Regression" class="headerlink" title="回归 (Regression)"></a>回归 (Regression)</h3><p>预测的值一般为连续的</p><p><img src="https://tuchuang001.com/images/2017/01/30/lecture1-1.png" alt="预测房价"></p><h3 id="分类-Classification"><a href="#分类-Classification" class="headerlink" title="分类 (Classification)"></a>分类 (Classification)</h3><p>预测的值一般为离散的</p><p><img src="https://tuchuang001.com/images/2017/01/30/lecture1-2.png" alt="预测是否患有肿瘤"></p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习，即数据中不含有标签，一般用于聚类，相似的数据将聚合形成一个个的簇。</p><blockquote><p>Unsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.</p></blockquote><h3 id="聚类-clustering"><a href="#聚类-clustering" class="headerlink" title="聚类 (clustering)"></a>聚类 (clustering)</h3><p><img src="https://tuchuang001.com/images/2017/01/30/lecture1-3.png" alt="聚类"></p><h2 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h2><ul><li><p>$x$ : 输入</p></li><li><p>$y$ : 输出</p></li><li><p>$m$ : 训练集大小</p></li><li><p>$(x^{(i)}, y^{(i)})$ : 训练集中第$i$个数据</p></li><li><p>$function \ h:\ X → Y$  : 预测的函数，也叫<code>hypothesis</code></p><p><img src="https://tuchuang001.com/images/2017/01/30/lecture2-1.png" alt="Model Representation"></p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数，用来评价模型的预测值与真实值的不一致程度，它是一个非负实值函数。损失函数越小，模型的性能就越好。 </p><p><code>Squared error function：</code></p><script type="math/tex; mode=display">J(\theta_0, \theta_1) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2</script><p>除以$m$可以排除训练集大小带来的影响，除以2是方便后面梯度下降求导数时约掉!</p><p><img src="https://tuchuang001.com/images/2017/01/30/lecture2-3.png" alt="损失函数的目标"></p><p>特别需要注意的是，下面右边的叫<strong>轮廓图</strong>，在同一个”圆圈”上的参数，其$J$值是一样的！<br><img src="https://tuchuang001.com/images/2017/01/30/lecture2-4.png" alt="h函数和J函数的示意图"></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降，用来求解满足Goal的参数$\theta_0$, $\theta_1$</p><ul><li>$\alpha$ (learning rate): 学习率，过小会导致下降太慢，过大可能导致结果不收敛</li><li>算法中$\theta_0$, $\theta_1$需要同时更新！</li></ul><p><img src="https://tuchuang001.com/images/2017/01/30/lecture2-5.png" alt="梯度下降算法"></p><p>特别的，对于<strong>一元线性回归</strong>模型，有</p><script type="math/tex; mode=display">\begin{align*} \theta_0 := & \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}(h_\theta(x_{i}) - y_{i}) \newline \theta_1 := & \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}\left((h_\theta(x_{i}) - y_{i}) x_{i}\right)  \end{align*}</script><p>而且对于线性模型的$J$函数，它的形状类似“碗状”，只有全局最小值，因此从任意一点开始，梯度下降算法一定能够找到全局最小值！</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode338 Counting Bits</title>
      <link href="/posts/leetcode338-counting-bits/"/>
      <url>/posts/leetcode338-counting-bits/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><p><strong>Follow up:</strong></p><ul><li>It is very easy to come up with a solution with run time <strong>O(n*sizeof(integer))</strong>. But can you do it in linear time <strong>O(n)</strong> /possibly in a single pass?</li><li>Space complexity should be <strong>O(n)</strong>.</li><li>Can you do it like a boss? Do it without using any builtin function like <strong>__builtin_popcount</strong> in c++ or in any other language.</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For num = 5 you should return [0,1,1,2,1,2].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求 <script type="math/tex">0</script>~<script type="math/tex">n</script> 这<script type="math/tex">n+1</script>个数，每个数的二进制表示中1的个数是多少。</p><p>首先我们来考虑，一个数的二进制表示中1的个数要怎么求</p><ul><li><strong>直接遍历每个二进制位：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) ans += (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>有多少个1就遍历多少次（通过lowbit跳转）：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n&amp;-n; &#125;</span><br><span class="line"><span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n -= lowbit(n)) ans++;</span><br></pre></td></tr></table></figure><p>首先来说下<script type="math/tex">lowbit</script>的作用，这个是用来求一个数的二进制表示中最右边的那个“1”。<br>举个例子比较直观，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n           -&gt;    0000 0000 1010 1100</span><br><span class="line">                                  ↑</span><br><span class="line">lowbit(n)   -&gt;    0000 0000 0000 0100</span><br></pre></td></tr></table></figure></p><p>那么 为什么 <script type="math/tex">n\&-n</script> 能求出<script type="math/tex">lowbit</script>呢？（注意到计算机内部以<strong>补码</strong>表示数）</p><p>假设<script type="math/tex">n</script>的第<script type="math/tex">0</script>~<script type="math/tex">i</script>位全为0，那么最右边的“1”即为第<script type="math/tex">i+1</script>位，形如  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxx xxxx xxx1 0000  （x可为0或1）</span><br><span class="line">             ↑</span><br><span class="line">          第i+1位</span><br></pre></td></tr></table></figure><p>取反后则形如 (假设x取反后变为y)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yyyy yyyy yyy0 1111  </span><br><span class="line">             ↑</span><br><span class="line">          第i+1位</span><br></pre></td></tr></table></figure><p>再加1后则形如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yyyy yyyy yyy1 0000  </span><br><span class="line">             ↑</span><br><span class="line">          第i+1位</span><br></pre></td></tr></table></figure><p>两个相与（&amp;）后则求出最右边的“1”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  xxxx xxxx xxx1 0000 (前面提到x取反后为y，即 x &amp; y = 0)</span><br><span class="line">&amp; yyyy yyyy yyy1 0000</span><br><span class="line">---------------------</span><br><span class="line">  0000 0000 0001 0000</span><br></pre></td></tr></table></figure><p>举个例子，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n     -&gt;    0000 0000 1010 1100</span><br><span class="line">-n    -&gt;    1111 1111 0101 0100  (各二进制位取反再加1)</span><br><span class="line">n&amp;-n  -&gt;    0000 0000 0000 0100</span><br></pre></td></tr></table></figure></p><p>了解了<script type="math/tex">lowbit</script>之后，再来看下<code>for (; n &gt; 0; n -= lowbit(n)) ans++;</code>这句为什么能求出<script type="math/tex">n</script>中所有的1。不难发现，<script type="math/tex">n</script>每次减掉<script type="math/tex">lowbit</script>等价于把<script type="math/tex">n</script>最右边的那个“1”去掉。因此，循环执行这个操作的次数即为<script type="math/tex">n</script>中1的个数。</p><p>最后，推荐大家参阅 <a href="http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html" target="_blank" rel="noopener">算法-求二进制数中1的个数</a>，这篇博客囊括了几乎所有这方面的算法~</p><hr><p>上面提到的两个做法，复杂度近似<script type="math/tex">O(nlogn)</script>，那么如何优化到<script type="math/tex">O(n)</script>呢？<br>不妨考虑<script type="math/tex">lowbit</script>那个做法的思路，<script type="math/tex">n</script>中1的个数等价于<script type="math/tex">n - lowbit(n)</script>这个数中1的个数再加1。<br>至此，我们可以用动态规划的方法来递推出答案！</p><script type="math/tex; mode=display">dp[i] = \left\{\begin{matrix}0 \; & \text{if i = 0}\\dp[n - lowbit(n)] + 1 \; & \text{others}\\end{matrix}\right.</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>做法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n; n -= n&amp;-n, ans++);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i) vec.push_back(cal(i));</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>做法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(num + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) dp[i] = dp[i-(i&amp;-i)] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode419 Battleships in a Board</title>
      <link href="/posts/leetcode419-battleships-in-a-board/"/>
      <url>/posts/leetcode419-battleships-in-a-board/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an 2D board, count how many different battleships are in it. The battleships are represented with <code>&#39;X&#39;</code>s, empty slots are represented with <code>&#39;.&#39;</code>s. You may assume the following rules:</p><ul><li>You receive a valid board, made of only battleships or empty slots.</li><li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li><li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><p>In the above board there are 2 battleships.</p><p><strong>Invalid Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...X</span><br><span class="line">XXXX</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p><p><strong>Follow up:</strong><br>Could you do it in <strong>one-pass</strong>, using only <strong>O(1) extra memory</strong> and <strong>without modifying</strong> the value of the board?</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个n*m的棋盘，上面有一些N×1或者是1×N的战舰（N可以为任意数，只要非零且不超过棋盘大小），其中任意两个战舰之间有一个空方块隔开，问有多少艘战舰。</p><p>这题直观的想法是求有多少个连通分量，dfs一下即可。但是这没用到”N×1或者是1×N”这个性质，思考之后发现，其实只需判断一个 ‘X’ 的左边或者是上边是否也有 ‘X’ 即可，若没有，这就说明这个 X 是属于一个新的战舰，答案加1。扫一遍棋盘即可，不用额外的数组，也不需要修改棋盘（dfs的做法则需要）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>DFS版：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> r, c;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dir[k][<span class="number">0</span>], ny = y + dir[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= r || ny &lt; <span class="number">0</span> || ny &gt;= c || board[nx][ny] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(board, nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        r = board.size();</span><br><span class="line">        c = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>扫一遍即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = board.size(), c = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i - <span class="number">1</span> &lt; <span class="number">0</span> || i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] != <span class="string">'X'</span>) &amp;&amp; </span><br><span class="line">                        (j - <span class="number">1</span> &lt; <span class="number">0</span> || j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] != <span class="string">'X'</span>)) ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode104 Maximum Depth of Binary Tree</title>
      <link href="/posts/leetcode104-maximum-depth-of-binary-tree/"/>
      <url>/posts/leetcode104-maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:   </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \ </span><br><span class="line">4   5</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的最大深度。</p><p>dfs遍历一遍即可，当前最大深度为左右子树深度的最大值加1！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode136 Single Number</title>
      <link href="/posts/leetcode136-single-number/"/>
      <url>/posts/leetcode136-single-number/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3, 1, 2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个数组，其中只有一个数出现一次，其余数字都出现两次。现在要找出只出现过一次的那个数字是多少。</p><p>考虑异或运算的性质：<strong>两个相同的数异或为0</strong> 以及 <strong>异或满足交换律</strong></p><p>那么我们只要对数组求个异或和 <script type="math/tex">ans = a_1  \bigoplus  a_2 \bigoplus ... \bigoplus a_n</script> 由于出现两次的数字都异或掉了，所以最后剩下的即为答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">            ans ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode226 Invert Binary Tree</title>
      <link href="/posts/leetcode226-invert-binary-tree/"/>
      <url>/posts/leetcode226-invert-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Invert a binary tree.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input：</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>翻转一棵二叉树。</p><p>dfs即可，每次swap左右子树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode283 Move Zeroes</title>
      <link href="/posts/leetcode283-move-zeroes/"/>
      <url>/posts/leetcode283-move-zeroes/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Note</strong>:</p><ol><li>You must do this <strong>in-place</strong> without making a copy of the array.</li><li>Minimize the total number of operations.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For example, given nums = [0, 1, 0, 3, 12], </span><br><span class="line">after calling your function, nums should be [1, 3, 12, 0, 0].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个数组，现在要把所有0都移到数组的末尾，其他非零数字的相对顺序不能改变。</p><p>考虑双指针，令<code>l</code>为答案数组的指针，<code>r</code>为原数组的指针。<code>r</code>在移动到一个非零的数时，把它和<code>l</code>指向的位置的元素进行交换。</p><p>为什么可以交换呢？因为此时<code>l</code>指向的位置的元素只有两种情况，要么<code>nums[l] == nums[r]</code> (或者说是l == r) 要么 <code>nums[l] == 0</code>。因此交换之后就相当于把0往后移了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(), l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r]) swap(nums[l++], nums[r]);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode292 Nim Game</title>
      <link href="/posts/leetcode292-nim-game/"/>
      <url>/posts/leetcode292-nim-game/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, if there are 4 stones in the heap, then you will never win the game: </span><br><span class="line">no matter 1, 2, or 3 stones you remove, the last stone will always be removed by</span><br><span class="line">your friend.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一堆石子，然后两个人轮流从堆中取走1-3个，规定取走最后一个石子的人获胜。现在给定石子的个数，问先手能否获胜。</p><p>典型的<a href="https://en.wikipedia.org/wiki/Nim" target="_blank" rel="noopener">尼姆游戏</a>，用SG函数打个表找找规律即可。可以发现当石子个数为4的倍数时，其SG函数值为0，此时先手必败。</p><p>关于NIM游戏和SG函数，可以参阅：<a href="https://software.intel.com/zh-cn/blogs/2014/03/06/nim-sg" target="_blank" rel="noopener"><a href="https://software.intel.com/zh-cn/blogs/2014/03/06/nim-sg" target="_blank" rel="noopener">博弈之 Nim 游戏和 sg 函数</a></a></p><p><img src="https://tuchuang001.com/images/2017/01/30/leetcode292.png" alt="前12个SG函数值"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打表程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sg[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSG</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sg[x] &gt;= <span class="number">0</span>) <span class="keyword">return</span> sg[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) s.insert(getSG(x - i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i) <span class="keyword">if</span> (!s.count(i)) <span class="keyword">return</span> sg[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sg, <span class="number">-1</span>, <span class="keyword">sizeof</span>(sg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) <span class="built_in">cout</span> &lt;&lt; <span class="string">"sg["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; getSG(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> SG函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode371 Sum of Two Integers</title>
      <link href="/posts/leetcode371-sum-of-two-integers/"/>
      <url>/posts/leetcode371-sum-of-two-integers/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Calculate the sum of two integers <em>a</em> and <em>b</em>, but you are <strong>not allowed</strong> to use the operator <code>+</code> and <code>-</code>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given a = 1 and b = 2, return 3.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在不使用<code>+</code> 和 <code>-</code>的情况下，求a+b。</p><p>回顾一下数逻里的<strong>加法器</strong></p><p><img src="https://tuchuang001.com/images/2017/01/30/03b26c9679af36df.gif" alt="加法器"></p><p>其中</p><script type="math/tex; mode=display">s_i = a_i \bigoplus b_i</script><script type="math/tex; mode=display">c_i = a_i  \&  b_i</script><p>那么我们只要模拟这个过程就可实现加法运算啦！</p><p><strong>a ^ b</strong> : 不进位求和</p><p><strong>(a &amp; b) &lt;&lt; 1 </strong>: 把进位通过左移加到高位</p><p>递归这一过程，直到没有进位为止。</p><p>比如 a = 3, b = 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">第一次迭代：</span><br><span class="line">a             -&gt;  0000 0000 0000 0011</span><br><span class="line">b             -&gt;  0000 0000 0000 0101</span><br><span class="line">a ^ b         -&gt;  0000 0000 0000 0110</span><br><span class="line">(a &amp; b) &lt;&lt; 1  -&gt;  0000 0000 0000 0010</span><br><span class="line"></span><br><span class="line">第二次迭代：</span><br><span class="line">a             -&gt;  0000 0000 0000 0110</span><br><span class="line">b             -&gt;  0000 0000 0000 0010</span><br><span class="line">a ^ b         -&gt;  0000 0000 0000 0100</span><br><span class="line">(a &amp; b) &lt;&lt; 1  -&gt;  0000 0000 0000 0100</span><br><span class="line"></span><br><span class="line">第三次迭代：</span><br><span class="line">a             -&gt;  0000 0000 0000 0100</span><br><span class="line">b             -&gt;  0000 0000 0000 0100</span><br><span class="line">a ^ b         -&gt;  0000 0000 0000 0000</span><br><span class="line">(a &amp; b) &lt;&lt; 1  -&gt;  0000 0000 0000 1000</span><br><span class="line"></span><br><span class="line">第四次迭代:</span><br><span class="line">a             -&gt;  0000 0000 0000 0000</span><br><span class="line">b             -&gt;  0000 0000 0000 1000</span><br><span class="line">a ^ b         -&gt;  0000 0000 0000 1000</span><br><span class="line">(a &amp; b) &lt;&lt; 1  -&gt;  0000 0000 0000 0000</span><br><span class="line"></span><br><span class="line">第五次迭代:</span><br><span class="line">a             -&gt;  0000 0000 0000 1000</span><br><span class="line">b             -&gt;  0000 0000 0000 0000</span><br><span class="line"></span><br><span class="line">此时b为0，返回答案a=8</span><br></pre></td></tr></table></figure><p>由于数字在计算机内部以<strong>补码</strong>形式表示，有 <strong>[X＋Y]补 = [X]补＋[Y]补 </strong>，所以上述思路对于负数也适用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>) : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode389 Find the Difference</title>
      <link href="/posts/leetcode389-find-the-difference/"/>
      <url>/posts/leetcode389-find-the-difference/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given two strings <strong>s</strong> and <strong>t</strong> which consist of only lowercase letters.</p><p>String <strong>t</strong> is generated by random shuffling string <strong>s</strong> and then add one more letter at a random position.</p><p>Find the letter that was added in <strong>t</strong>.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;abcd&quot;</span><br><span class="line">t = &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&apos;e&apos; is the letter that was added.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给两个只含小写字母的字符串s和t，其中串t为串s打乱之后的某一排列，同时在某一随机位置新增一个字符。现在要找到这一新增的字符。</p><p>一个直观的想法是开一个数组记录s中每个字母出现的次数，然后再开一个数组也记录t中每个字母出现的次数，然后比较一下哪个字母的个数不一样，即为新增的字符。</p><p>如果之前做过<a href="http://orzyt.cn/2017/01/19/LeetCode136-Single-Number/">LeetCode136 Single Number</a>这道题的话，那么另一个想法就是考虑能不能把字符串也进行异或呢，剩下的不就是那个“Single Char”了吗？显然是可以的！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cnt2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            cnt1[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            cnt2[t[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt2[t[size] - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] != cnt2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">char</span>(i + <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">char</span> ch = t[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ch ^= s[i] ^ t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode455 Assign Cookies</title>
      <link href="/posts/leetcode455-assign-cookies/"/>
      <url>/posts/leetcode455-assign-cookies/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Note:</strong><br>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: You have 3 children and 2 cookies. </span><br><span class="line">The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, </span><br><span class="line">you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You have 2 children and 3 cookies. </span><br><span class="line">The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough </span><br><span class="line">to gratify all of the children, You need to output 2.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有n个小朋友和m块饼干，第i个小朋友至少要g[i]大小的饼干，而第i块饼干大小为s[i]，每个小朋友只能分到一块饼干，问分掉这些饼干最多能让多少个小朋友满意。</p><p>先把小朋友的需求以及饼干的大小按递增排个序。基于贪心的思想，饼干能早分掉就尽早分掉，在排完序后，如果第j块饼能满足第i个小朋友，那么肯定也能满足前i-1个小朋友，因此把饼干早分掉不会使结果变得更差。（早分掉的意思是一旦当前饼干能满足当前小朋友的需求，就分给他，而不必把饼干留到后面分）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end()); </span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,  p2= <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; g.size() &amp;&amp; p2 &lt; s.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[p1] &lt;= s[p2]) p1++, ans++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建之法读书笔记</title>
      <link href="/posts/learning-by-doing-notes/"/>
      <url>/posts/learning-by-doing-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　早在10月份还在上软工实践课的时候，就立了一个Flag说要读完<a href="https://book.douban.com/subject/25965995/" target="_blank" rel="noopener">《构建之法》</a>。可惜当时并没有完整地将书读过一遍，而是在实践中要用什么内容就读什么内容。后来等有时间通读过一遍后，却没有记录成博客，等到邹欣老师给我留言的时候已临近期末，再加上自己的拖延症，导致该文静静地躺在草稿箱中不见天日。（这么看来，deadline真的是第一生产力…</p> <a id="more"></a><h2 id="初步印象"><a href="#初步印象" class="headerlink" title="初步印象"></a>初步印象</h2><p>　　软件工程，一开始给我的体会就如同书中二柱说的那样，”软件工程讲的净是一些奇妙玄幻的概念，拗口的专业名词加上纷繁复杂的流程，其实做软件完全没有那么难，主要靠的还是程序员自身的修养和完成工作的素质“。（摘自7.7节 练习与讨论）面对课内教材动辄二十几章的内容（还是经过改编的本科教学版），如果不是为了考试，实在是没多大兴趣翻下去。好在，栋哥在课程伊始给了一些参考书籍，其中有一本叫《构建之法——现代软件工程》，翻阅了几页之后，给我的第一印象是<strong>生动有趣，接地气！</strong></p><p>　　在开篇，作者提到了“程序 = 数据结构 + 算法”这个广为人（程序员）知的名言，我由于常敲算法题，对此深以为然。我一直以为软件和程序之间差别应该不大，所以才会有二柱那样的体会。但是后来作者通过移山公司程序员阿超的例子展现了软件和程序的区别，提出<strong>“软件 = 程序 +软件工程”</strong>这一推论。这让我对软件的认识发生了深刻的改变，会写算法和数据结构、会写能跑的程序只能算是自己的一项基本功，在此基础上，软件工程这门学问才是真正决定了软件的质量和命运。不得不说，概论部分介绍的方方面面，让我第一次对软工有一个全景式的直观感受。</p><p>　　虽然软件工程涉及的面非常的广，但是作者还是尽可能的囊括了软工的方方面面。“全书对软件工程内容的覆盖不逊于任何一本现行的教材”，确实，从目录中便可窥知一二。不仅包括从软件工程师的成长、团队流程、敏捷开发到项目经理、用户体验、测试发布这些软件工程的核心内容，最后还包括了IT创新和职业道德等内容，因此<strong>覆盖面广</strong>也是书中一大特点。</p><p>　　全书始终贯穿着<strong>情景式、对话式的对白</strong>，作者善于将一些晦涩难懂的概念透过人物生动形象、幽默有趣的对白展现出来，可谓是深入浅出。这可能跟邹老师曾投身于教学一线有关，才会了解学生在学习软工课时的痛点。在阅读对话的时候，自己也会不知不觉地融入其中，仿佛也在着参与这场讨论。在第七章讲到MSF（Microsoft Solution Framework，微软解决方案框架）时，其中有许许多多的对话内容，这对于我们这种一点都没接触过MSF的同学理解它的思想有很大的帮助。试想，如果一上来就长篇大论各种虚无缥缈的概念，第一是什么第二是什么balabala…，我想很多人是没多大兴趣看下去。即使勉强看下去，没有实际软件开发经验的学生也会看的一头雾水，到头来也还是什么也不知道。</p><p>　　邹老师始终强调 <strong>Learning by Doing，做中学</strong>的模式，这也是他自己在教学实践过程中总结出来的。因此，书中不仅仅流于概念和方法论的介绍，还十分<strong>注重实践</strong>过程，对于大部分内容都会配合很多的思考与练习，同时也会提供相关的评价指标。毕竟，软工如果只有理论没有实践，也就失去这门课的意义了。周筠老师在知乎专栏文章 <a href="https://zhuanlan.zhihu.com/p/23554675?refer=yeka52" target="_blank" rel="noopener">他们说我们永远做不到，然而我们有『做中学』（Learning by doing）——来吧，IT小小鸟</a> 里也举了一些具体的例子，说明了将该模式与软工实践结合的益处。不得不说，栋哥采用“做中学”来指导我们的软工实践课是一个正确的选择，选修了这次的软工实践课可谓是受益匪浅！</p><h2 id="付诸实践"><a href="#付诸实践" class="headerlink" title="付诸实践"></a>付诸实践</h2><p>　　在软工实践课上，也曾布置过多次博客作业（<a href="https://edu.cnblogs.com/campus/fzu/FZUSE2016/homework/57" target="_blank" rel="noopener">需求分析与原型设计</a>，<a href="https://edu.cnblogs.com/campus/fzu/FZUSE2016/homework/84" target="_blank" rel="noopener">毕设导师智能匹配</a>，<a href="https://edu.cnblogs.com/campus/fzu/FZUSE2016/homework/107" target="_blank" rel="noopener">软件产品案例分析</a>），通过阅读书中相关内容后将其付诸于实践。其中，前两次是<strong>结对编程</strong>项目，需要和同伴一起完成。书中提到，结对编程中有两个角色：驾驶员和领航员，一个负责具体的执行，另一个负责导航、检查、护航。在实践当中也确实如此，一个人掌控键盘编写程序，一个在旁边指出程序中的错误，这在一定程度上确实能够提高代码的质量。书中为结对编程提供了“方法论”，讲述了如何进行结对编程以及两人合作的技巧等。其中给我留下深刻印象的是4.6.2小节—<strong>如何正确地给予反馈</strong>，作者将反馈分为最外层（行为和后果）、中间层（习惯和动机）和最内层（本质和固有属性），不同层次的反馈给人不同的感受。如果将反馈上升到最内层，说不定两人合作将从磨合阶段直接到解体阶段… 感谢当时的结对同伴，在结对编程的时候我们能够进行有效的交流反馈，顺利地完成任务！在结对编程的同时，我们还学习了解了<strong>PSP</strong>（Personal Software Process，个人开发流程），并估计了完成结对编程项目所需的耗时。</p><p>　　在软件产品案例分析中，我们不仅要充当实际用户、还要充当测试人员甚至是项目经理。这个难度看起来有点高，要一人分饰多角。其实在软件开发过程中，也常常需要这种换位思考。在进行<strong>需求分析</strong>时，书中提供了一个竞争性需求分析框架—<strong>NABCD模型</strong>，这一模型被多次用于我们的实践课程作业中。第12章<strong>用户体验</strong>中举了飞机中的遥控器等例子，强调了用户体验设计的一个重要目标就是要降低用户的认知阻力，也就是我们常说的“这款软件上手快不快”。因此在软件产品案例分析中，用户体验部分也作为我评测的一大重点。评测部分还有一项内容是“估计这个项目做到这个程度大约需要多少时间”，书中也举了一个“徒步遍历中国陆地边界”的例子，同学们给出了从50天到不可能的各种答案。除了盲目的估计，其实也有一套有章可循的<strong>项目估计</strong>的经验公式：Y = X ± X ÷ N。</p><p>　　在<strong>团队开发</strong>中，我们团队经历了萌芽、磨合、规范和创造阶段。当然，我们不会像王屋村“搬砖团队”那样，临时聚在一起，各自完成任务就走人，没有一个集体的目标。虽然我们组内经常戏称各种抱大腿，如下图所示。</p><p><img src="https://tuchuang001.com/images/2017/01/30/1018687-20170123205455769-824174602.png" alt=""></p><p>但是我觉得，我们倒像是属于<strong>功能团队模式</strong>，大家都平等地相互协作鼓励，为了完成一个共同的目标而努力（脑海中又回想起了一次次的<strong>Scrum每日冲刺</strong>，一次次的约<strong>活动室敲代码</strong>、<strong>alpha版本发布</strong>前的通宵和发布后的<strong>事后诸葛亮会议</strong>、两次版本发布的答辩以及去教学办展示后又<strong>改需求</strong>的无奈… ）现在回想起来那几个月的历程，也算是一段难忘的经历吧。</p><h2 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h2><p>其实吧，自己作为一名学生也没有什么实际软件开发经验，也谈不上提什么建议，所以下述内容可能也有不对的地方，还请各位批评指正。</p><ul><li>书中的注释都放在每一章的最后，感觉翻起来不太方便，直接附在相关页的下方会不会更好？</li><li>本书有较多的超链接，虽然封面提供了整合链接的二维码，但是有的时候读者可能仅仅对某一注释中的链接感兴趣，所以希望能够提供短链接</li><li>2.1.1小节 用VSTS写单元测试，这边给的例子是用C#编写的，但是大多数同学应该没有C#编程经验，所以建议可以更换成同学们比较熟悉的语言，如C++等。这样也可以跟第四章中关于代码规范方面用C++举例相对应起来</li><li>第七章用了一个章节讲了微软解决方案框架，如果说本书的定位是面向高校的软工教材的话，我觉得可以不用这么多篇幅，MSF这部分可能更适合作为补充延伸的阅读材料</li><li>希望能够有一个完整的项目贯穿全书始终，比如像《软件工程—实践者的研究方法》这本书中的“SafeHome”安全住宅项目，这样可能使读者更好地把各部分内容串在一起理解，融会贯通</li><li>索引部分的条目可以稍微精简一些，更加突出重点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode344 Reverse String</title>
      <link href="/posts/leetcode344-reverse-string/"/>
      <url>/posts/leetcode344-reverse-string/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a function that takes a string as input and returns the string reversed.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;hello&quot;, return &quot;olleh&quot;.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>输出一个串的翻转串。</p><p>C++自带reverse函数，一行代码的事…</p><p>或者直接for循环到长度的一半，交换s[i]和s[size-1-i]即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size / <span class="number">2</span>; ++i) swap(s[i], s[size<span class="number">-1</span>-i]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode412 Fizz Buzz</title>
      <link href="/posts/leetcode412-fizz-buzz/"/>
      <url>/posts/leetcode412-fizz-buzz/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Write a program that outputs the string representation of numbers from 1 to <em>n</em>.</p><p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出 1 ~ n 中3的倍数、5的倍数以及15的倍数。对于3的倍数输出 “Fizz” ，5的倍数输出 “Buzz” ，15的倍数输出 “FizzBuzz” ，其余的输出对应的数字。</p><p>简单模拟，<del>但是C++好像没有提供 int 转 string 的函数，还得自己动手写一个…</del></p><p>其实C++有提供int转string函数，叫<code>to_string()</code>  ORZ…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">int2Str</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; num;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        ss &gt;&gt; str;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fizzBuzz(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">15</span> == <span class="number">0</span>) vec.push_back(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) vec.push_back(<span class="string">"Fizz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) vec.push_back(<span class="string">"Buzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> vec.push_back(int2Str(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode463 Island Perimeter</title>
      <link href="/posts/leetcode463-island-perimeter/"/>
      <url>/posts/leetcode463-island-perimeter/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Answer: 16</span><br></pre></td></tr></table></figure><p><strong>Explanation</strong>: The perimeter is the 16 yellow stripes in the image below:<br><img src="https://leetcode.com/static/images/problemset/island.png" alt="Explanation"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个地图，含有水和陆地，陆地为一个联通块（四方向联通，且联通块内部不会包含水），问联通块的周长。</p><p>首先一块陆地（1*1大小）对周长的贡献是4，只有当它在某个方向上的邻居也是陆地时，这个贡献被抵消掉。因此只要遍历每块陆地的4个方向，判断一下是否有贡献即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = grid.size(), c = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> perimeter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>], y = j + dir[k][<span class="number">1</span>]; <span class="comment">// 邻居坐标</span></span><br><span class="line">                      <span class="comment">// 若越界 或者 是水 ，则加上该方向上的贡献</span></span><br><span class="line">                        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= r || y &lt; <span class="number">0</span> || y &gt;= c || grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            perimeter++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perimeter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode476 Number Complement</title>
      <link href="/posts/leetcode476-number-complement/"/>
      <url>/posts/leetcode476-number-complement/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p><p><strong>Note:</strong></p><ol><li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li><li>You could assume no leading zero bit in the integer’s binary representation.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), </span><br><span class="line">and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), </span><br><span class="line">and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求一个32-bit正数各二进制位取反后的数。</p><p>位运算的简单操作。通过<strong>移位</strong>运算符取得num第i位上的数，再用<strong>异或</strong>操作取反（与1进行异或），最后用<strong>或</strong>运算加到ans的第i位上即可。</p><p>另一个思路是，用二进制位数和num一样且各位都为1的数与num异或即为答案。</p><p>比如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10101 &lt;- num</span><br><span class="line">^ 11111 &lt;- 二进制全为1</span><br><span class="line">-------</span><br><span class="line">  01010</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; num; num &gt;&gt;= <span class="number">1</span>, ++i) &#123;</span><br><span class="line">            ans |= (((num &amp; <span class="number">1</span>) ^ <span class="number">1</span>) &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ans &lt;= num) ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (ans - <span class="number">1</span>) ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode448 Find All Numbers Disappeared in an Array</title>
      <link href="/posts/leetcode448-find-all-numbers-disappeared-in-an-array/"/>
      <url>/posts/leetcode448-find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p><p>Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.</p><p>Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给出一个长度为n的数组，数组元素大小也在[1,n]内，有些数字出现1次，有些出现2次，问哪些数字没出现过。</p><p>显然，我们可以开个辅助数组标记哪些数字出现过，然后遍历辅助数组即可找到没出现过的。</p><p>但是，不开额外的数组该怎么做呢？那么就必须得充分利用原数组nums！</p><p>因此，nums身兼二职，在不破坏原数组信息的情况下，还要肩负起辅助数组的重任！</p><p>为了记录信息，不改变nums的值是不可能的，所以我们必须找到一个记录信息的方式，使得要用到nums原值的时候可以很方便恢复回来。一个直观的想法是取负，比如 i 这个数字出现过，则把nums[i]取负（多次出现只取负一次）。因此，想得到nums[i]的原值只需取个绝对值即可，想要知道数字 i 出现过没有只需判断nums[i]是否小于0。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>开O(n)的辅助数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; exist(nums.size() + <span class="number">5</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            exist[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exist[i]) ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不开额外的空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt; <span class="number">0</span>) nums[index] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) ans.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode2 Add Two Numbers</title>
      <link href="/posts/leetcode2-add-two-numbers/"/>
      <url>/posts/leetcode2-add-two-numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: </span><br><span class="line">7 -&gt; 0 -&gt; 8</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给两个数位链表，输出求和之后的链表。<br>类似于高精度加法的过程，边求和边进位。为了处理起来方便，可以把小数加到大数上（无需得到真实大小，仅根据链表长度判断大小即可），然后由大数统一处理进位即可。<br>(唉，太久没写链表了，思路不清晰的话调试起来好痛苦…)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>; <span class="comment">// l1的长度</span></span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>; <span class="comment">// l2的长度</span></span><br><span class="line">        ListNode* ptrL1 = l1; <span class="comment">// 指向l1</span></span><br><span class="line">        ListNode* ptrL2 = l2; <span class="comment">// 指向l2</span></span><br><span class="line">        <span class="keyword">while</span> (ptrL1) &#123; <span class="comment">// 得到l1的长度</span></span><br><span class="line">            len1++;</span><br><span class="line">            ptrL1 = ptrL1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ptrL2) &#123; <span class="comment">// 得到l2的长度</span></span><br><span class="line">            len2++;</span><br><span class="line">            ptrL2 = ptrL2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) swap(l1, l2); <span class="comment">// 将“大数”放在l1上</span></span><br><span class="line">        ptrL1 = l1; ptrL2 = l2;</span><br><span class="line">        <span class="keyword">while</span> (ptrL2) &#123; <span class="comment">// 由于l2指向“小数”，故仅需判断l2是否为空即可</span></span><br><span class="line">            ptrL1-&gt;val += ptrL2-&gt;val; <span class="comment">// l2 加到 l1 上</span></span><br><span class="line">            <span class="keyword">if</span> (ptrL1-&gt;val &gt;= <span class="number">10</span>) &#123; <span class="comment">// 处理进位</span></span><br><span class="line">                <span class="keyword">if</span> (ptrL1-&gt;next == <span class="literal">NULL</span>) ptrL1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                ptrL1-&gt;next-&gt;val += (ptrL1-&gt;val) / <span class="number">10</span>;</span><br><span class="line">                ptrL1-&gt;val %= <span class="number">10</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向后继</span></span><br><span class="line">            ptrL1 = ptrL1-&gt;next;</span><br><span class="line">            ptrL2 = ptrL2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理后续的进位</span></span><br><span class="line">        <span class="keyword">while</span> (ptrL1 &amp;&amp; ptrL1-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptrL1-&gt;next == <span class="literal">NULL</span>) ptrL1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ptrL1-&gt;next-&gt;val += (ptrL1-&gt;val) / <span class="number">10</span>;</span><br><span class="line">            ptrL1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            ptrL1 = ptrL1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode461 Hamming Distance</title>
      <link href="/posts/leetcode461-hamming-distance/"/>
      <url>/posts/leetcode461-hamming-distance/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="noopener">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p><p>0 ≤ <code>x</code>, <code>y</code> &lt; 2^31.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给两个32-bit数，求它们有多少个不同的二进制位。<br>判断数x的第i为是否为1：<code>(x &gt;&gt; i) &amp; 1</code><br>异或运算性质：<code>0 ^ 0 = 1 ^ 1 = 0</code>  <code>1 ^ 0 = 0 ^ 1 = 1</code> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((x &gt;&gt; i) &amp; <span class="number">1</span>) ^ ((y &gt;&gt; i) &amp; <span class="number">1</span>)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode485 Max Consecutive Ones</title>
      <link href="/posts/leetcode485-max-consecutive-ones/"/>
      <url>/posts/leetcode485-max-consecutive-ones/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p><p><strong>Note:</strong></p><ul><li>The input array will only contain <code>0</code> and <code>1</code>.</li><li>The length of input array is a positive integer and will not exceed 10,000</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个0-1数组，求数组中最长的连续1的个数。<br>循环模拟一遍，遇到非1的数字，更新最长的答案即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">-1</span>); <span class="comment">// 为了方便处理，在数组末尾加入一个非1的数字</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) cnt++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = max(ans, cnt);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode1 Two Sum</title>
      <link href="/posts/leetcode1-two-sum/"/>
      <url>/posts/leetcode1-two-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个数组和一个目标数字，若数组中某两个数字之和等于目标数字，输出它们两个的下标。</p><p>一个直观的想法是通过暴力枚举。复杂度$\mathcal{O}(n^2)$</p><p>另一个想法是把数组中的元素放入哈希表中，当枚举到array[i]时，只要查询 target - array[i] 是否存在于哈希表中即可。复杂度$\mathcal{O}(nlogn)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>暴力版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(), flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    index.push_back(i);</span><br><span class="line">                    index.push_back(j);</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            hashTable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashTable.find(num) != hashTable.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != hashTable[num]) &#123;</span><br><span class="line">                    index.push_back(i);</span><br><span class="line">                    index.push_back(hashTable[num]);</span><br><span class="line">                    <span class="keyword">break</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件工程实践总结</title>
      <link href="/posts/software-engineering-summary/"/>
      <url>/posts/software-engineering-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="再回首"><a href="#再回首" class="headerlink" title="再回首"></a>再回首</h2><p>1、<strong>对比现在的你和开学初博客开篇的课程目标和期待</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">开学的目标</th><th style="text-align:center">现在的情况</th></tr></thead><tbody><tr><td style="text-align:center">学习软件开发的完整过程</td><td style="text-align:center">经过一个学期理论和实践的学习，在经历过需求分析、系统设计、编码、测试、交付验收等环节以及alpha和beta版本的开发，大体上掌握了软件（web）开发的基本流程。</td></tr><tr><td style="text-align:center">增强团队协作与沟通交流的能力</td><td style="text-align:center">加入了“我说的都队”小组，在强大的pm的带领下，小伙伴们配合得相当默契，团队成员之间有充分的沟通与交流，经常约在活动室一起敲代码。</td></tr><tr><td style="text-align:center">掌握各种开发工具的使用</td><td style="text-align:center">能初步掌握常用的开发工具，详情请见第2点“学习和使用的新软件和新工具”。</td></tr><tr><td style="text-align:center">合理安排时间、项目进度</td><td style="text-align:center">在两个版本的冲刺中，由于pm的合理安排和计划，我们小组仅仅在alpha版本发布前通宵过一次，其他时间基本按照计划走，稳得不行！</td></tr></tbody></table></div><a id="more"></a><p>2、<strong>总结这门课程的实践给你带来的提升：</strong></p><p>（1）学习和使用的新软件</p><ul><li>原型设计工具Axure RP、MockingBot</li><li>Windows下的Markdown书写软件Typora</li><li>分布式版本控制软件git以及托管平台github /coding.net</li><li>Microsoft Visio画流程图、类图</li><li>sublime text编写前端代码</li><li>WAMP搭建本地web服务器</li></ul><p>（2）学习和使用的新工具</p><ul><li>浏览器自带的开发者工具（说实话之前没怎么碰过这个…</li><li>JavaScript单元测试框架——Qunit</li><li>在线思维导图——百度脑图</li><li>阿里巴巴矢量图标库——iconfont</li><li>在线教程网学习前端知识——w3school</li></ul><p>（3）学习和掌握的新语言、新平台</p><ul><li>html、css、JavaScript</li></ul><p>（4）统计一下，你在这门软件工程实践中，完成了多少行的代码</p><ul><li>不到1k行代码。主要原因还是在于中间出去参加了两场ACM比赛，大概有十几天不在学校。所以PM考虑实际情况后，分配给我的编码工作量比较少。</li></ul><p>（5）学习和掌握的新方法</p><ul><li>面向搜索引擎编程</li><li>前端没学过，只好边学边用</li></ul><p>（6）其他的提升</p><ul><li>大学第一次通宵献给软工，竟不觉得困…</li><li>写前端界面，然后强迫症又加深了…</li></ul><h2 id="人月神话"><a href="#人月神话" class="headerlink" title="人月神话"></a>人月神话</h2><p>1、经验总结</p><ul><li>别试图想先学完一个语言，再开始进行编码工作，直接上手才是硬道理</li><li>文档工作不是表面功夫，认真对待对后期将有极大的帮助</li><li>团队成员之间的沟通交流非常重要，特别是前后端的配合</li><li>对pm分配的任务，觉得有疑问的地方要及时提出</li><li>站立式会议时间不长，要充分利用机会进行总结，三省吾身</li><li>项目进度安排要合理，将各个功能点分配好，避免出现熬夜赶工现象</li><li>团队成员聚在活动室一起敲代码，效率绝对比自己一个人敲要高</li></ul><p>2、实例分析</p><p>主要说说沟通交流方面。</p><ul><li>齐民要试验php后台连接cpp编写的分配算法，于是直接跑到他的宿舍去，按照他要求的输出格式对代码进行修改，在有效的沟通交流之下，很快就可以改好了，比在QQ上一来一回的效率高到不知哪里去。</li><li>跟胡总的前后端配合，前端页面写完了，后台要接上来，比如分页什么的有问题了就得找下后台，界面布局有问题了又得找下前端，因此前后端之间的交流是必不可少的！</li><li>某个前端页面出现莫名其妙的bug，最底下有一大片空白的页面，关键是只有这个页面有这个问题，然后用浏览器自带的开发者工具查了半天也没发现，后来直接请教前端大佬，不用一会就解决了。所以有时候多跟经验丰富的同学交流是很有帮助的，会让你少走一些弯路。</li></ul><h2 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h2><ul><li>想认真学习软件工程这门课，选栋哥的课准是没错的</li><li>想水的可以考虑出门右转了，这个课注定不适合你…</li><li>万事开头难，不要轻言放弃，既然选择了hard模式，就请坚持下去</li><li>利用空余时间，提前简单了解git和github的使用，不让其成为团队协作的障碍</li><li>多与团队成员沟通交流，不要单打独斗，记住软工是一个team</li><li>要求有较强的自学能力，软工不会教你某一门具体的编程语言</li><li>学会learning by doing，不懂没关系，以做促学</li><li>善用Google、StackOverflow等网站，能解决你开发中面临的大部分问题</li><li>懂得合理安排时间，不要赶在deadline前才临门一脚</li><li>编码不是软工的全部，不要排斥写文档、写博客，用文字记录点滴是有益的</li></ul><h2 id="团队分析"><a href="#团队分析" class="headerlink" title="团队分析"></a>团队分析</h2><div class="table-container"><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:center">对应时期</th><th style="text-align:center">主要表现</th></tr></thead><tbody><tr><td style="text-align:center">萌芽</td><td style="text-align:center">组队</td><td style="text-align:center">虽然小组成员都是来自计2和计3，但是平常也没多少机会接触。所以组好队之后还是有一个熟悉与融合的过程。在此期间，每个人对自己在团队中所担负的职责、角色定位还不是很清楚。</td></tr><tr><td style="text-align:center">磨合</td><td style="text-align:center">选题</td><td style="text-align:center">在组队初期，我们小组的技能点就是往Android开发方向的，就想着在软工实践课能够开发出一款实用有情怀的app。在选题方面，一开始想过做一款为学校部门、社团服务的app，但是团队成员有着自己不同的想法，以致于出现了较大的意见分歧。后来，选题又改成了类似“赏金猎人”的东西。但是再后来，万万没想到，我们接手了导师互选系统的网页端项目。选题一改再改，团队也在此期间得到不断的磨合。</td></tr><tr><td style="text-align:center">规范</td><td style="text-align:center">alpha</td><td style="text-align:center">选题确定，需求确定，等一切都稳定了下来，大家开始慢慢地配合，慢慢明确了自己的角色和职责。开发、讨论、交流也慢慢变得规范起来，都能够遵守相应的规矩。</td></tr><tr><td style="text-align:center">创造</td><td style="text-align:center">beta</td><td style="text-align:center">构建之法中说，达到创造阶段的团队知道为何而战。哈哈，我们的目标一开始就很明确，是为了栋哥的自助餐而战的，因此大家在每个环节都努力做到最好。“高度自治，不需要领导的实时教诲和介入”，确实，PM通过在github上发布121个issues来计划整个项目，给每个人分配任务和功能点，大家都能够自觉主动地去完成。</td></tr></tbody></table></div><p>综上，我认为我们的团队可以算是达到了<code>创造</code>阶段！</p><h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><strong>题目</strong>：Open source software development should strive for even greater code maintainability（开源软件的发展需要有更好的代码可维护性）</p><p><strong>大意</strong>：对开源环境下源代码可维护性的研究结果进行探讨</p><p><strong>主旨</strong>：开源软件的发展关键在于软件发布之后的维护</p><p>文章指出，代码维护主要有以下两种：</p><ul><li><p>corrective maintenance：对已经存在的功能进行排错</p></li><li><p>perfective maintenance：为系统添加新的特性</p></li></ul><p>作者通过测量五款开源软件的可维护性指数（Maintainability Index，MI）来评价各个软件的可维护性，MI值越高说明软件的可维护性越好，并得出了以下结论：</p><ul><li>在实现相同功能的情况下，开源软件的代码质量要好于或至少等同于闭源软件的代码质量。</li><li>对于开源软件在不同版本可维护性上的表现（MI值波动明显），同时考虑到20%的代码产生80%的维护问题，因此对开源软件需要做更细致独立的分析。</li><li>随着时间的推移，开源软件的可维护性也会逐渐降低，因此需要考虑预防性维护（preventive maintenance）。</li></ul><blockquote><p>读完论文之后，发现代码的可维护性是十分重要的。回过头来再看自己编写的代码，主要分为三块，C++编写的分配算法，html写的前端界面，JavaScript编写的测试代码，这三部分代码的可维护性应该是逐渐降低的…主要原因还是在于对语言的掌握程度，掌握的不深入不能够灵活运用，很多时候仅仅只是为了完成一个功能而去编写代码，没有考虑到以后的扩展性以及维护性。但是说大泥球吧，应该也还不至于，至少在提出需求变更的时候，还能看得懂一个多月前写的代码，并进行相应的修改和扩展。</p></blockquote><h2 id="学会软工"><a href="#学会软工" class="headerlink" title="学会软工"></a>学会软工</h2><p><strong>1、研发出符合用户需求的软件</strong></p><p>毕设导师互选是每个高校都必须面临的问题，开发此系统是符合潜在的用户需求的。而且该系统以后可能会被用于数计学院的工作中。</p><p><strong>2、通过一系列工具，流程，团队合作，能够在预计的时间内发布 “足够好” 的软件</strong></p><p>我们团队有完整的项目规划，并且定时发布项目的进度。</p><div class="table-container"><table><thead><tr><th style="text-align:center">时间</th><th style="text-align:center">主题</th></tr></thead><tbody><tr><td style="text-align:center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2016-09-25 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td style="text-align:center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <a href="http://www.cnblogs.com/CSLaker/p/5907123.html" target="_blank" rel="noopener">团队选题报告</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td style="text-align:center">2016-10-16</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/5966396.html" target="_blank" rel="noopener">任务计划</a></td></tr><tr><td style="text-align:center">2016-10-22</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/5986566.html" target="_blank" rel="noopener">需求规格说明书</a></td></tr><tr><td style="text-align:center">2016-10-29</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6010248.html" target="_blank" rel="noopener">系统设计</a></td></tr><tr><td style="text-align:center">2016-11-07~18</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6045895.html" target="_blank" rel="noopener">Alpha版本十天冲刺集结令</a></td></tr><tr><td style="text-align:center">2016-11-19</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6079767.html" target="_blank" rel="noopener">Alpha版本项目测试</a></td></tr><tr><td style="text-align:center">2016-11-19</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6079668.html" target="_blank" rel="noopener">Alpha版本项目总结</a></td></tr><tr><td style="text-align:center">2016-11-24</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6099218.html" target="_blank" rel="noopener">Alpha版本之事后诸葛亮</a></td></tr><tr><td style="text-align:center">2016-12-03</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6129030.html" target="_blank" rel="noopener">Beta版本之冲刺计划及安排</a></td></tr><tr><td style="text-align:center">2016-12-08~16</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6160236.html" target="_blank" rel="noopener">Beta版本七天冲刺集结令</a></td></tr><tr><td style="text-align:center">2016-12-19</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6201024.html" target="_blank" rel="noopener">Beta版本项目测试</a></td></tr><tr><td style="text-align:center">2016-12-19</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6198527.html" target="_blank" rel="noopener">用户试用与调研报告</a></td></tr><tr><td style="text-align:center">2016-12-29</td><td style="text-align:center"><a href="http://www.cnblogs.com/CSLaker/p/6232572.html" target="_blank" rel="noopener">宣传推广方案</a></td></tr></tbody></table></div><p><strong>3、展现软件是可以维护和继续发展的</strong></p><p>github链接:<a href="https://github.com/Tutordistribution/Tutor-distribution" target="_blank" rel="noopener">点我跳转</a><br>仓库里有完整的软件需求说明书等文档，详细的commit记录以及issues，方便维护和继续发展。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016ACM区域赛青岛赛区总结</title>
      <link href="/posts/2016-acmicpc-qingdao-summary/"/>
      <url>/posts/2016-acmicpc-qingdao-summary/</url>
      
        <content type="html"><![CDATA[<p>这是今年我们队参加的最后一场比赛，被分配到了青岛赛区。</p><p><img src="https://tuchuang001.com/images/2017/09/03/IMG_20161112_135640_HDR.jpg" alt="2016ACM-ICPC·青岛赛区"></p><a id="more"></a><p>据说这个赛区有300+队伍参赛，其中不乏很多ACM圈内“偶像级”的大佬，如清华Deep Dark Fantasy队（杜教、cls、jcvb）、北师大的Q神等等，能够亲眼见到他们还是很开心的（乘机%%%，orz）。</p><p><img src="https://tuchuang001.com/images/2017/09/04/orz.jpg" alt="2016ACM-ICPC·青岛赛区"></p><p>比赛前夕，从福州坐绿皮火车，慢悠悠走了29个小时才到达青岛，再一次突破记录！</p><p>热身赛三道题，一人一道，结束后我们队排在前十。热身赛冲在这么前面，队友们纷纷说明天正式赛该掉RP了，orz。</p><p>第二天的正式赛，同样前期一人一道，还算顺利。</p><p>后来gy大佬在一个人在搞网络流，debug期间，又顺手开了一道KD树，一发AC，就这样我们冲到了银牌区！</p><p><img src="https://tuchuang001.com/images/2017/09/03/IMG_1977.jpg" alt="2016ACM-ICPC·青岛赛区"></p><p>比赛结束后，我被叫去排队领奖，期间瞄到了工作人员手里的榜单。</p><p>看来封榜后排名没有什么大的变化，我们队依然坚挺在银牌区。<br><img src="https://tuchuang001.com/images/2017/09/03/IMG_1984.jpg" alt="2016ACM-ICPC·青岛赛区"></p><hr><p>其实这场比赛对我来说，不仅仅是今年的最后一场比赛，而且应该也是自己参加的最后一场ACM-ICPC区域赛。</p><p><img src="https://tuchuang001.com/images/2017/09/03/icpc.png" alt="2016ACM-ICPC·青岛赛区"></p><p>大二第一次参加ACM-ICPC区域赛，在北京赛区遗憾打铁</p><p>一年后，天时地利人和，CCPC合肥赛区夺银、ICPC青岛赛区夺银</p><p>虽然热爱ACM，但是自己还是没办法<del>（没勇气）</del>把时间全投入在上面</p><p>明年，应该不能再留校集训了，得开始准备保研的事情</p><p>虽然退役了，但是对算法的追求不会停止</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016中国大学生程序设计竞赛总结</title>
      <link href="/posts/2016-ccpc-hefei-summary/"/>
      <url>/posts/2016-ccpc-hefei-summary/</url>
      
        <content type="html"><![CDATA[<p>　　最近事情比较多，所以这份比赛总结姗姗来迟。趁今晚有空，总结之。</p><p><img src="https://tuchuang001.com/images/2017/09/03/v2-0bb75c83026f90507717f269d3babb5b_r.jpg" alt="2016CCPC·安徽"></p><a id="more"></a><p><img src="https://tuchuang001.com/images/2017/09/03/v2-2979b38937126ae425f1d7912897fbad_r.jpg" alt="2016CCPC·安徽"></p><p>　　CCPC合肥比赛是在10.15-16两天，第一天热身赛有3题，题面是中文的（后来有人发clarification问正式赛是否也是中文题面，得到肯定的回复后，全场沸腾。果然是中国大学生程序设计竞赛，题面都用中文写，就不用带厚重的字典啦…）三道题目，刚好一人写一道热身，之后就测了下比赛环境，特别是$pc^2$的使用，我们队伍是第一次使用这个软件。在热身赛时，$pc^2$好像评测的特别慢，基本上是提交了半个小时之后才返回结果，如果正式赛也这样，那将大大影响发挥。还好，后来从志愿者那得知，正式赛会有人工评测，评测的速度将会提上去。</p><p><img src="https://tuchuang001.com/images/2017/08/25/76aba70ae16498d083c649f9cd84fe56.jpg" alt="2016CCPC·安徽"></p><p>　　第二天正式赛，这个就有点意思了，恰好遇上了更高级别的赛事——国际铁人三项比赛，导致我们的比赛从九点开始一再顺延，期间走到半路又折返回酒店休息，整个上午处在比较奔波折腾的状态，好在十一点多比赛顺利开始了。首先我负责登录系统，准备好编译器，然后开始找水题，由于是中文题面，迅速都扫了一遍，好像没发现特别水的题目。zt开了H题，不过由于种种原因卡住了，我跟gy讨论I题（之后看来，I题应该是最水的一道），也讨论了半个多小时之久。一个小时过去了，一道题都没过，zt让出机位给我敲I题，终于在71min时过了I题，算是吃了一颗定心丸。后来H题好像一直调不出来，zt心里就有点急了，于是换gy上机又重新写了一遍，终于跌跌撞撞在106min过了H题。在gy敲H题的时候，我跟zt在看过的最多的E题，应该是一个麻烦的递推，zt在推E的递推关系，我则在旁边辅助他。推完后，zt上机敲，测了几个样例就交了，然而返回了WA，我跟他检查了半天，他改了之后在177min时过了E题。然后，我跟gy说了A题的题意，是关于图论的一道判定性问题，说完题意之后，我顺口说了一句这道题可以用rand去跑（这也为后面埋下了伏笔…）不过嘛这显然不是正解，被gy给搁置在一边。本着不浪费机时的原则，gy就上机边想边敲。此时过得比较多的还有C题，是关于一个树上博弈的题目，虽然我在队内有负责博弈论，但是在树上的博弈我还是接触的比较少的。于是，先放下这题，又看了其他几道题，不过也基本上都没什么想法。到了封榜的时候，我们队只过了3道题，由于过题晚+罚时多，大约处于铁牌区。封榜后的前半个小时，A、C两道题毫无进展，此时我的心态也近乎崩溃，感觉这次比赛估计又得打铁了。大约还剩25min时，我又跟gy提了下A题rand的想法，于是gy迅速写完了rand的版本。我们先rand了10w次，返回TLE，于是改rand1w次，然后“情理之中，意料之外”地就过了…情理之中是指这道题是一道判定性问题，它的输出只有Yes和No，因此只要找到一个反例不满足题目的条件即可判No，所以采用随机的办法可以有很大的概率找到反例从而得出正确的答案（暑假训练赛的时候也遇到过一题判定性问题，那题的正解就是随机判定）。意料之外就不多说了…于是我们在284min过了A题。现在，我们手上还有一道完全没想法的C题（虽然我盯着样例已经研究看了一个小时了），zt表示要不把树上的博弈用树链剖分弄成线段，再去博弈。然而C题的博弈不仅有询问，还有修改操作，每次询问的树根又都不一样，数据规模又很大，我表示依然没办法处理。此时离比赛结束还有15min，突然间，可能是刷过博弈论专题带给我的“灵感”，一般博弈论都会往一个变量的奇偶性上去靠，而且数据规模很大，询问和修改操作只能在$\mathcal{O}(1)$或$\mathcal{O}(logn)$内处理出来，肯定这个处理不会太复杂。于是，我凭直觉猜了个结论，然后我们就马上上机敲了，zt写好建树部分，我则写博弈部分。写完后发现还剩不到3min，于是立马提交。回过神来，发现程序还没有编译，也没测样例。在等待$pc^2$返回结果的间隙，我们赶紧编译一下，还好没有编译错误。接着测了一发样例，都正确！我们在紧张地等待评测结果，最终返回了绿色的Yes！</p><p><img src="https://tuchuang001.com/images/2017/08/25/3a25e0c14549190bf65afd1abc39add1.png" alt=""></p><p><img src="https://tuchuang001.com/images/2017/08/25/359335c00de2364f2caf4160ec00dc9a.png" alt=""></p><p><img src="https://tuchuang001.com/images/2017/09/03/ccpc.jpg" alt="ccpc.jpg"></p><p>　　284min过A题，297min过C题，最后这几分钟，我们没有放弃，反而让我们如过山车般地从铁牌到银牌，这真是我打过最紧张刺激的比赛！后来，我们打趣说到，C题应该等299min再交，说不定还能拿个顽强拼搏奖（当然，这都是后话了…）</p><p><img src="https://tuchuang001.com/images/2017/08/25/e10731beb0b4cedc18e8cf54775624fa.jpg" alt="2016CCPC·安徽"></p><p>　　总结一下这场比赛，前期基本处于血崩状态，水题找的慢，找到了也被卡住很久，三道水题写了三个小时。前期失常的发挥特别影响心态以及中后期的发挥，好像这属于我们队的通病，出去打比赛经常这样。这次能够拿到银牌，除去运气成分来说，我觉得应该归功于暑假的训练，正因为暑假训练遇到过一题正解是随机算法的题目，才让我们更有底气去过A题，同时因为在暑假训练的时候刷过博弈论专题（只算是入门专题，没涉及到树上博弈），C题才能找准方向，得到的结论才会比较靠谱…</p><p>　　简而言之，比赛心态重要，题目见多识广也重要！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Build to Win!获得小黄衫的感想</title>
      <link href="/posts/build-to-win!-summary/"/>
      <url>/posts/build-to-win!-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-amp-背景"><a href="#前言-amp-背景" class="headerlink" title="前言&amp;背景"></a>前言&amp;背景</h2><p>从大一上C++课程开始，栋哥就开始安利他大三的软工实践课。<br>时间过得飞快，大学转眼就过去一半了，我也成为了一名大三汪~<br>本来以为软工的课程会如 邹欣老师 <a href="http://www.cnblogs.com/xinz/archive/2013/02/06/2908169.html" target="_blank" rel="noopener">微博上的软件工程</a> 这篇博文所展示的一般，又成为了大学生涯中的一门“水课”。<br>然而，栋哥说不会让我们失望的！在安利的时候，说会带来结合《构建之法》、采用“做中学”（learning by doing）、面向实战，理论和实践相结合的课程内容，满满干货！<br>不过嘛，当我第一次听到上面这些时，也没太在意，毕竟能学到什么还得实践了才知道。但是，当提到了《构建之法》的作者是邹欣老师时，突然觉得这个名字好熟悉。:)</p><a id="more"></a><center><img src="https://tuchuang001.com/images/2017/01/30/1018687-20161009234127124-894973760.jpg" width="45%" height="45%"></center><p>哈哈，没错！翻了翻我的微博关注列表，原来我早就关注了邹欣老师以及周筠老师。之前由于能在两位老师的微博里了解到IT行业的相关知识，所以就关注了。没想到原来这位微博上的“大V”微软研发经理还是一名软件工程的教师，更没想到他写的书会成为我这学期软工的辅助教材，想想就有点小激动呢！</p><h2 id="读《构建之法》的体会"><a href="#读《构建之法》的体会" class="headerlink" title="读《构建之法》的体会"></a>读《构建之法》的体会</h2><p>在软工的第二次作业中，栋哥就布置我们阅读《构建之法》的第3章——软件工程师的成长 和第8章——需求分析 来完成我们的结对编程项目。在最近的一次个人作业中，也布置阅读了相关章节。说来惭愧，目前《构建之法》整本书还没有读完，所以谈的体会可能还是比较片面的吧。<br>首先谈谈书的封面，个人比较喜欢简洁的风格，所以第一次看到这本书的封面时，简洁的封皮配上互相啮合的鲁班锁，简直大爱。对于书的风格，我觉得用“幽默风趣，有血有肉”来形容再恰当不过了。不同于国外翻译过来的教材（就比如说我们的主教材…），虽然经典，但是比较晦涩不接地气。同时，这本书采用了对话，举例等方式来讲解，特别是创造了王屋村软件学院、移山公司和阿超、小飞等人物使软工的内容不再枯燥乏味，跃然于纸上。目前从书中学会了需求分析中的NABCD模型以及个人开发流程（PSP）等实用的知识，并能够在实践中得到一定的应用。希望在接下来的阅读中，能够学习到更多有用的软工知识！</p><h2 id="获得小黄衫的感受"><a href="#获得小黄衫的感受" class="headerlink" title="获得小黄衫的感受"></a>获得小黄衫的感受</h2><p>很幸运到目前为止个人积分暂列第一 :)，达成成就 获得 Build to win 小黄衫一件！</p><center><img src="https://tuchuang001.com/images/2017/01/30/1018687-20161009232320642-2130939920.jpg" width="55%" height="55%"></center><center><img src="https://tuchuang001.com/images/2017/01/30/1018687-20161009232329642-2071081293.jpg" width="55%" height="55%"></center><p>据说拿到小黄衫，是拥有“黄色领骑衫”含义的一种优胜荣誉喔~ 但革命尚未成功，同志仍需努力！ XD</p><h2 id="进一步的计划"><a href="#进一步的计划" class="headerlink" title="进一步的计划"></a>进一步的计划</h2><ul><li>阅读完《构建之法》</li><li>定位自己在团队中的角色</li><li>提升个人的编程实力</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢栋哥开设的这门软工实践课，干货满满！<br>感谢邹欣老师以及周筠老师出版的《构建之法》这本书，将会有更多的学生受益！<br>感谢各位助教老师辛勤的工作，点评、统计分数也挺不容易的！<br>感谢我的小组 “我说的都队”，一起赶选题报告很开心！<br>感谢我的结对编程搭档 <a href="http://www.cnblogs.com/vvxyz/" target="_blank" rel="noopener">小VV</a> ,结对编程的感觉真好！<br>最后，感谢替我拍照的舍友 :)</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>结对编程之毕设导师智能匹配</title>
      <link href="/posts/pair-programming-tutor-distribution/"/>
      <url>/posts/pair-programming-tutor-distribution/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>编码实现一个毕设导师的智能匹配的程序</p><p>输入: </p><ol><li>30个老师（包含带学生数的要求的上限，单个数值，在[0,8]内）</li><li>100个学生（包含绩点信息），每个学生有5个导师志愿（志愿的导师可以重复但不能空缺）</li></ol><p>输出: </p><ol><li>导师和学生间的匹配信息（一个学生只能有一个确认导师，一个导师可以带少于等于其要求的学生数的学生） </li><li>未被分配到学生的导师</li><li>未被导师选中的学生</li></ol></blockquote><a id="more"></a><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><strong>学生角度:</strong><br>根据学生对导师喜爱的程度，将五个志愿按照优先级排序,优先考虑志愿靠前的导师<br>对于每个学生有 $student_{i}:choice_{1}&gt;choice_{2}&gt;choice_{3}&gt;choice_{4}&gt;choice_{5}$</p><p><strong>导师角度:</strong><br>由于输入数据只有 <code>绩点</code> 这一评价标准，故每个导师在所有选他的学生中优先考虑绩点高的<br>(后期可以根据学生的专业知识修养、兴趣方向（学生想从事哪方面的研究）、创新能力等等综合信息来形成评价标准）<br>对于每个导师有 $teacher_{i}:student_{1}&gt;student_{2}&gt;student_{3}&gt;…&gt;student_{n}$</p><p>由于导师的分配会因为学生的偏好造成导师志愿的分布不均匀，这可能会导致有些学生分配不到导师，或者有的导师没有分配到学生，这就需要一些算法对此加以控制以达到最优匹配。</p><h2 id="采用的算法"><a href="#采用的算法" class="headerlink" title="采用的算法"></a>采用的算法</h2><p>由于笔者有参加ACM竞赛，看到这个问题联想到图论中的 <strong>稳定婚姻问题(Stable marriage problem)</strong> 。查找了相关的文献资料后，发现导师分配问题是属于该问题的一个变形。而对于该问题，通常用 <code>Gale-Shapley</code> 算法来解决。</p><p><code>Gale-Shapley</code> 算法简称 <code>G-S</code> 算法，也被称为延迟接受算法。该算法由 Gale 和 Shapley 提出，他们研究学校申请与婚姻稳定的匹配问题，并用 G-S算法得到了稳定的匹配， 这种匹配是帕累托最优。该算法只需在信息完全且充分的情况下，选择的双方按照自己的偏好进行排序，且一方先进行选择即可得出最优稳定匹配。</p><p><code>Gale-Shapley</code> 算法的核心思想：<br>在信息对称且完全的情况下， 存在需要相互选择的集合 $T = \lbrace T_{1}, T_{2}, T_{3}, …, T_{m} \rbrace$ 与 $S = \lbrace S_{1}, S_{2}, S_{3}, …, S_{n} \rbrace$， 集合 $S$ 中的个体 $S_{i}$ 对 $T$ 中的个体存在偏好如 $S_{i} = \lbrace T_{2}, T_{1}, T_{5}, …, T_{m} \rbrace$，表示对于 $S_{i}$ 的第一选择为 $T_{2}$，第二选择为 $T_{1}$，第三选择为 $T_{5}$，依次类推。 $T$ 中个体 $T_{r}$ 对 $S$ 中的个体存在偏好 $T_{r} = \lbrace S_{6}, S_{3}, …, S_{n} \rbrace$。 让 $S$ 对 $T$ 做出选择，即发出信息（如申请学校或求婚）。 当 $T$ 接收信息的容量低于自己的需求量 $K$ 时，全部暂时接受。 当 $T$ 的接收信息容量超过自己需求量 $K$ 时，$T$ 根据自己的偏好从中进行选择，暂时接受其中处于偏好前面的 $K$ 个，拒绝其他。被拒绝个体根据自己的第二偏好进行选择，并发出信息。若第二偏好的 $T_{r}$ 未饱和，则暂时接受。若第二偏好的 $T_{r}$ 饱和， 则 $T_{r}$ 对包括上次选择的所有给自己发出信息的人按照偏好再次进行选择，并确定暂时接受的人和拒接的人。 被拒绝的人按照偏好顺序再次选择下一个偏好，依次类推……直到没有人剩下，整个匹配结束。 作为发出信息选择的一方占相对优势，被选择的一方占相对劣势。 但是随着选择次数的增多，稳定匹配时发出信息的一方会越处于偏好后方，而被选择的一方会越处于偏好前方。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>根据原始的 <code>Gale-Shapley</code> 算法, 我们稍加修改后即可适用于原问题。</p><p><strong>分配步骤：</strong></p><p>按照学生在数据中的顺序根据当前志愿分配导师，若导师的学生数未满则直接把此学生分配给该导师；否则将此学生和已分配给该导师的学生中绩点最低的那个学生比较，若是此学生的绩点低于绩点最低的那个学生，则进入下一轮分配（下一轮分配考虑此生的下一个志愿）；否则如果此学生的绩点高于绩点最低的那个学生，则将此生分配给该导师，绩点最低的那个学生则不再属于该导师，并将该学生的状态改为未分配。一直循环上述步骤，直到考虑了所有学生的所有志愿。</p><p><strong>流程图：</strong></p><center><img src="https://tuchuang001.com/images/2017/08/24/1018687-20160930141933891-1813292344.jpg" width="50%" height="50%"></center><p><strong>伪代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Matching &#123;</span><br><span class="line">    Initialize all s ∈ Student <span class="keyword">and</span> t ∈ Teacher to <span class="built_in">free</span></span><br><span class="line">    <span class="keyword">while</span> ∃ a <span class="built_in">free</span> Student s who still has a choice t to choose &#123;</span><br><span class="line">       t = first teacher on s' <span class="built_in">list</span> to whom s has <span class="keyword">not</span> yet chose</span><br><span class="line">       <span class="keyword">if</span> t is <span class="built_in">free</span></span><br><span class="line">            distribute(s, t)</span><br><span class="line">       <span class="keyword">else</span> some pair (s', t) already exists</span><br><span class="line">            <span class="keyword">if</span> t prefers s to s'</span><br><span class="line">                distribute(s, t)</span><br><span class="line">                <span class="built_in">set</span> s' to <span class="built_in">free</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                remain(s', t) </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">set</span> s to <span class="built_in">free</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现语言：<code>C++</code></p><p><strong>学生类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> student_id; <span class="comment">// 学生编号</span></span><br><span class="line">    <span class="keyword">int</span> teacher_id; <span class="comment">// 中选的导师编号</span></span><br><span class="line">    <span class="keyword">int</span> cur;        <span class="comment">// 当前分配进程正在考虑第cur个志愿</span></span><br><span class="line">    <span class="keyword">int</span> want[<span class="number">5</span>];    <span class="comment">// 五个志愿</span></span><br><span class="line">    <span class="keyword">float</span> point;    <span class="comment">// 绩点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>导师类</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> teacher_id; <span class="comment">// 导师编号</span></span><br><span class="line">    <span class="keyword">int</span> want_num;   <span class="comment">// 期望的学生数</span></span><br><span class="line">    <span class="keyword">int</span> chose_num;  <span class="comment">// 已中选的学生数</span></span><br><span class="line">    <span class="keyword">int</span> student_id[<span class="number">10</span>]; <span class="comment">// 中选的学生编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>分配系统</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributeSystem</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> student_number; <span class="comment">// 学生总人数</span></span><br><span class="line">        <span class="keyword">int</span> teacher_number; <span class="comment">// 导师总人数</span></span><br><span class="line">        Student* stu;</span><br><span class="line">        Teacher* tch;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数与析构函数</span></span><br><span class="line">        DistributeSystem() &#123;&#125;</span><br><span class="line">        DistributeSystem(<span class="keyword">int</span> stu_num, <span class="keyword">int</span> tch_num) &#123;&#125;</span><br><span class="line">        ~DistributeSystem() &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 随机生成导师信息</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">generate_teacher_information</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 随机生成学生信息</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">generate_student_information</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据导师编号返回他在数组中的下标</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_teacher_index</span><span class="params">(<span class="keyword">int</span> teacher_id)</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据学生编号返回他在数组中的下标</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_student_index</span><span class="params">(<span class="keyword">int</span> student_id)</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Gale–Shapley算法进行分配</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">distribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;Student&gt; Que; <span class="comment">//未分配到导师的学生队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; student_number; ++i) &#123;</span><br><span class="line">                Que.push(stu[i]); <span class="comment">// 初始都是未分配状态，都加进队列</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!Que.empty()) &#123;</span><br><span class="line">                Student&amp; s = stu[get_student_index(Que.front().student_id)];</span><br><span class="line">                Que.pop();</span><br><span class="line">                <span class="comment">// 考虑学生s的第cur个志愿（导师为t）</span></span><br><span class="line">                Teacher&amp; t = tch[get_teacher_index(s.want[s.cur++])];</span><br><span class="line">                <span class="keyword">if</span> (t.want_num &gt; t.chose_num) &#123; <span class="comment">// 如果导师t还有剩余名额，直接中选</span></span><br><span class="line">                    t.student_id[t.chose_num++] = s.student_id;</span><br><span class="line">                    s.teacher_id = t.teacher_id;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> min_stu_id = <span class="number">-1</span>; <span class="comment">// 导师t中绩点最低的学生编号</span></span><br><span class="line">                    <span class="keyword">int</span> pos = <span class="number">-1</span>; <span class="comment">// 以及他在导师的中选列表中的下标</span></span><br><span class="line">                    <span class="keyword">float</span> min_point = <span class="number">5.0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.chose_num; ++i) &#123; <span class="comment">// 在导师t中查找绩点最低的学生编号</span></span><br><span class="line">                        Student tmp = stu[get_student_index(t.student_id[i])];</span><br><span class="line">                        <span class="keyword">if</span> (min_point &gt; tmp.point) &#123;</span><br><span class="line">                            min_point = tmp.point;</span><br><span class="line">                            min_stu_id = tmp.student_id;</span><br><span class="line">                            pos = i;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果导师t不带学生 或者 学生s的绩点比导师t所有已经中选学生的最低绩点还低，那么学生t只好再等下轮</span></span><br><span class="line">                    <span class="keyword">if</span> (t.want_num == <span class="number">0</span> || s.point &lt; min_point) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s.cur &lt; <span class="number">5</span>) &#123; <span class="comment">// 如果五个志愿还没考虑完毕的话，放入队列中继续参与分配</span></span><br><span class="line">                            Que.push(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不然学生t就直接替换掉绩点最低的那个学生</span></span><br><span class="line">                        Student&amp; min_stu = stu[get_student_index(min_stu_id)];</span><br><span class="line">                        min_stu.teacher_id = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min_stu.cur &lt; <span class="number">5</span>) &#123; <span class="comment">// 被替换掉的学生再放入未分配的队列中去</span></span><br><span class="line">                            Que.push(min_stu);</span><br><span class="line">                        &#125;</span><br><span class="line">                        t.student_id[pos] = s.student_id;</span><br><span class="line">                        s.teacher_id = t.teacher_id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从导师角度查看分配结果</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get_teacher_result</span><span class="params">(<span class="keyword">bool</span> flag)</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从学生角度查看分配结果</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get_student_result</span><span class="params">(<span class="keyword">bool</span> flag)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>对于我们的代码，分配的结果概括起来大概是这样：</p><ul><li>分配导师的时候志愿的顺序很重要，只要绩点不是太低，且自己喜欢志愿顺序靠前，就会分配到自己喜欢的导师</li><li>分配的轮数越多，越是对导师有利（如果选这个导师的人比较多留下的都是绩点比较高的）</li></ul><h2 id="结果评估"><a href="#结果评估" class="headerlink" title="结果评估"></a>结果评估</h2><p>为了评估该算法的实际效果，笔者随机生成了 <code>10000</code> 个样本对其进行测试。</p><p><strong>样本约定：</strong></p><ul><li>导师的人数在 <code>30 ~ 100</code> 人之间</li><li>学生的人数为导师的 <code>1 ~ 4</code> 倍</li></ul><p>将 10000 个样本分为 10 组，每组 1000 个，得到的结果如下表所示：</p><p><strong>学生未分配率：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">样本组数</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均情况</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">&nbsp; &nbsp; &nbsp; 0.0000% &nbsp; &nbsp; &nbsp;</td><td style="text-align:center">&nbsp; &nbsp; &nbsp; 22.4806% &nbsp; &nbsp; &nbsp;</td><td style="text-align:center">&nbsp; &nbsp; &nbsp;1.5869%&nbsp; &nbsp; &nbsp;</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0.0000%</td><td style="text-align:center">16.9675%</td><td style="text-align:center">1.5230%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0.0000%</td><td style="text-align:center">20.1681%</td><td style="text-align:center">1.6781%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0.0000%</td><td style="text-align:center">18.6992%</td><td style="text-align:center">1.7076%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0.0000%</td><td style="text-align:center">18.2609%</td><td style="text-align:center">1.5168%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0.0000%</td><td style="text-align:center">28.0000%</td><td style="text-align:center">1.6612%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0.0000%</td><td style="text-align:center">18.7500%</td><td style="text-align:center">1.5338%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0.0000%</td><td style="text-align:center">18.0180%</td><td style="text-align:center">1.6950%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0.0000%</td><td style="text-align:center">21.1180%</td><td style="text-align:center">1.6605%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">0.0000%</td><td style="text-align:center">22.5131%</td><td style="text-align:center">1.7302%</td></tr><tr><td style="text-align:center">平均</td><td style="text-align:center">0.0000%</td><td style="text-align:center">20.4975%</td><td style="text-align:center">1.6293%</td></tr></tbody></table></div><p><strong>学生中选志愿顺序：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">样本组数</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">平均情况</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">&nbsp; &nbsp; &nbsp; 1.03030 &nbsp; &nbsp; &nbsp;</td><td style="text-align:center">&nbsp; &nbsp; &nbsp; 2.00000 &nbsp; &nbsp; &nbsp;</td><td style="text-align:center">&nbsp; &nbsp; &nbsp;1.43622&nbsp; &nbsp; &nbsp;</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1.05714</td><td style="text-align:center">2.08264</td><td style="text-align:center">1.42591</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1.01818</td><td style="text-align:center">2.01935</td><td style="text-align:center">1.43242</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1.02941</td><td style="text-align:center">2.07207</td><td style="text-align:center">1.43448</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">1.02857</td><td style="text-align:center">1.97177</td><td style="text-align:center">1.42840</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">1.04110</td><td style="text-align:center">2.14433</td><td style="text-align:center">1.43085</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">1.00000</td><td style="text-align:center">2.04717</td><td style="text-align:center">1.42317</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1.06796</td><td style="text-align:center">2.04819</td><td style="text-align:center">1.43239</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1.02041</td><td style="text-align:center">2.15789</td><td style="text-align:center">1.43456</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">1.02273</td><td style="text-align:center">2.03759</td><td style="text-align:center">1.43417</td></tr><tr><td style="text-align:center">平均</td><td style="text-align:center">1.03158</td><td style="text-align:center">2.05810</td><td style="text-align:center">1.43126</td></tr></tbody></table></div><p><strong>分析：</strong></p><p>从上面可以看出，该算法的总体效果非常好。<br>对于学生未分配率来说，在最好情况下，所有学生都能得到分配。而在最坏情况竟然达到<strong>20%</strong>左右，这个数据一开始令笔者较为吃惊！后来在调试的过程中，将最坏情况下的输入数据进行输出查看，发现基本上都是出现在  学生的数量为导师的3倍多到4倍左右 以及 导师所期望带的学生数较少 这种极限数据情况下。对于通常情况，基本上学生的未分配率保持在<strong>1.6%</strong>左右。另一方面，对于学生中选的志愿，最好情况能够保证在第一志愿即可录取，而最差情况下也能够第二志愿录取。当然，没中选的学生是没有统计到该数据当中的（因为落选了，中选志愿更无从谈起）。</p><h2 id="小结与感受"><a href="#小结与感受" class="headerlink" title="小结与感受"></a>小结与感受</h2><blockquote><p><strong>vvxyz</strong>:  总的来说这次作业抱了大腿，搭档是ACM的大神，这次编程的思路基本是按照搭档的思路走的，代码主要是搭档编写的，我们结对编程的时候，基本就是搭档是主力，我在旁边辅助，帮他纠正一些细节上的错误，改bug的时候帮助分析错误。这次结对编程的代码并没有很多难理解的地方，但是编程的过程中感受到了搭档强大清晰的逻辑思维以及扎实的c++基本功，这是值得我学习与思考的地方。</p><p><strong>orzyt</strong>:  其实本次作业一开始搭档是想用 <code>Java</code> 配合数据库来写的，但由于我平常都是用<code>C++</code>来写算法，因此搭档为了配合我，后来就订下用<code>C++</code>编写。这里对搭档说一声感谢！对于此次结对编程题目，很切合实际，因为上学期我们刚刚经历过学生选导师这一环节。然后我是把这次作业当做一道ACM算法题目来写的（栋哥不要打我…），但是嘛，这次不只是为了AC这么简单。为了代码的规范性，以及更容易维护，我将算法的主要功能都封装在<code>DistributeSystem</code>类中。然后不得不说的就是debug的过程！在结对编程的第一天，我将代码的整体框架编写完毕，本地测试了学生数=100，导师数=30，以及其他几组数据，查看结果基本上符合预期，就将代码推送到git上去了。第二天，为了更好地评估该算法的实际效果，于是我就随机生成了一万个测试样本（详情见第七节），然后基本上程序跑着跑着就奔溃了。于是开始了漫长的debug过程，花费了一个晚上，进行各种花式调试，最终发现是 程序不能正确处理 导师期望数为0 的这种情况！！吐血…总之，在此次结对编程中，从建模、查文献、实现算法、样本测试一步步走过来，收获还是挺大的！</p></blockquote><h2 id="结对过程的闪光点"><a href="#结对过程的闪光点" class="headerlink" title="结对过程的闪光点"></a>结对过程的闪光点</h2><ul><li>能够对原问题进行抽象建模</li><li>搭档之间相互支持鼓励，能够进行有效的沟通交流</li><li>懂得查找相关参考文献、学术论文等资料</li></ul><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p>点击查看：<a href="https://coding.net/u/orzyt/p/Distribute-System/git" target="_blank" rel="noopener">Distribute System</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>Wikipedia.  <strong>稳定婚姻问题(Stable marriage problem)</strong></li><li><p>D. Gale and L. S. Shapley.  <strong>College Admissions and the Stability of Marriage</strong></p></li><li><p>向 冰,刘文君.  <strong>硕士研究生与导师的双向选择的最优匹配</strong></p></li><li>刘汝佳, 陈锋.  <strong>算法竞赛入门经典—训练指南</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 结对编程 </tag>
            
            <tag> Gale-Shapley算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2015ACM区域赛及省赛总结</title>
      <link href="/posts/2015-acmicpc-beijing-summary/"/>
      <url>/posts/2015-acmicpc-beijing-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="2015ACM-ICPC亚洲区域赛（北京赛区）"><a href="#2015ACM-ICPC亚洲区域赛（北京赛区）" class="headerlink" title="2015ACM-ICPC亚洲区域赛（北京赛区）"></a>2015ACM-ICPC亚洲区域赛（北京赛区）</h2><p>　　首先是11月份的北京区域赛，有幸集训队能给予这次难得的机会让我们出去锻炼。第一次正式参加比赛，心情是比较复杂的，兴奋、忐忑、激动、不安等夹杂着。</p><p>　　第一天参加热身赛，由于没有熟悉的CodeBlocks，有点慌张，一开始的时间都花在应该用哪个IDE上，后面只好用相对友好的Geany来写代码。热身赛写了2道题，感觉发挥的中规中矩，之后稍微测了下hihoCoder的环境，没发现有什么特别的地方。</p><a id="more"></a><p>　　第二天正式比赛，我先负责登录，然后开始看题，刷榜后发现有人过了G题后，我和队友zt开始读G题，G题是给四块矩形选择其中三块，问这三块矩形能不能拼成更大的矩形。读完后队友zt开始推可能的组合情况，推完后上去敲，提交后WA，打印之后检查出判断条件写错了，后来再交还是WA，我跟他检查感觉没什么问题，无奈把题意跟另一个队友gy说了之后，他想了一会说可能是漏了一种情况，果然，加上去之后AC了！大概1个小时左右才过1题，这是很危险的。然后目光锁定在J，J此时过的人数也非常多，应该是签到题。队友gy说他看了第一遍题目后，没能理解题意。当我看完之后，也是一头雾水，只好又重新看了一遍，这时稍微理解了，题目是给一系列游戏操作（操作种类有3种），问得到顶级评价的次数最多有几次。然后我就按照自己的理解推样例，发现可以过，于是开始上机敲代码，提交后WA…，心想签到题不应该有坑才对，于是开始考虑各种边界情况，以为是边界没处理好的问题，然后修改了几次后，提交依旧是WA…这时离比赛开始已经过了2个多小时了，整个队的心情都是很沉重的，我只好让出机位给队友gy敲A题。A题队友敲的是线段树，写的有点冗长，写完开始调试，发现自己构造的数据过不了，然后不断地修改，队友zt在看其他可做的题，我在一旁在纸上写着J的代码，等队友gy思考不用机时的时候，我把纸上的代码交了一发，还是WA…内心是崩溃的…于是开始怀疑题目是不是看错了，因为这题题意不太好看懂，所以我跟另外两位队友无法就细节地方进行交流。我于是沉下心，把题目再读了一遍，发现那3种操作，有2种操作是要看成同一种的，知道之后马上把刚才那个充满“补丁”的代码全删了，然后只敲了短短几行就AC了。此时已经快接近封榜了，才把所谓的签到题做出来，真的是无地自容。然后队友gy依旧在敲A，队友zt跟我讲了下他刚才看的几道题的题意，听完后，都没有什么思路，于是封榜之后我跟队友gy都在看A，直到比赛结束还是没做出来。后来知道A只要二分就可以了，线段树有点小题大做了…</p><p>　　从北京赛区公布奖牌比例之后，知道拿牌希望渺茫，但是没想到会打得这么惨。第一次参加现场赛，暴露出了我们队很多问题，一方面我们心理素质不够硬，导致在卡题时不能够有效地应对，放下卡住的签到题去想其它更难的题又不甘心，不放下又陷入自己的思路之中无法自拔。另一方面我们的知识面还太窄，队友之间的讨论也很局限，很多题目看了没有思路，而且限于时间，三个人目前专注的方向基本上没有交叉，因此很多时候一道题只有一个人在想，这也是一个弊端。</p><p><img src="https://tuchuang001.com/images/2017/08/25/53319c68dd6a77ff06693a030f063f21.jpg" alt="北京大学邱德拔体育馆"></p><h2 id="2015第六届福建省大学生程序设计竞赛"><a href="#2015第六届福建省大学生程序设计竞赛" class="headerlink" title="2015第六届福建省大学生程序设计竞赛"></a>2015第六届福建省大学生程序设计竞赛</h2><p>　　北京区域赛结束到省赛之间，大概间隔一个月左右。在这期间，我们开始尝试做些个人训练，参加了一两场的Codeforces和BestCoder比赛，主要目的在于对前几题这种较简单的题能够快速准确的写出来。然后组队训练做了大概近3年的省赛题目，自我感觉还算良好。</p><p>　　对于12月的省赛，因为难度比区域赛来说肯定简单不少，再结合组队训练的结果来看，我们将目标订在了银奖。由于六级的原因，我们队热身赛只去了一个人，然后现场做出了3题（共5题），后来等队友都到齐后，在宾馆研究了剩下的2题，理论AK之后就去休息了，到此时，我们对省赛还是充满了信心。</p><p>　　第二天正式赛开始后，队友gy迅速看了下A，思路跟我讲了下，觉得可行，交了之后1Y。然后B发现是水的计算几何，队友zt分类讨论下，我上去敲代码，交了也1Y。在我敲B的时候，队友zt则在想C，并在纸上写好了C的代码，B一过，马上把机子让给他，敲完之后，C也1Y。此时离比赛开始还不到50min，3题都1次AC，我们队排在金牌区，开局十分顺利！然后我们把目光都投在J题，根据目前过题人数来看，应该也是一道简单题。J是一道类似博弈的题，我跟队友gy讨论下博弈的策略，觉得策略应该没错，于是上机敲了下，返回WA…然后我们又重新讨论下，再次提交，依然WA…然后队友zt也一起来想J题，按照他的策略交了一发，还是WA…，看着J题过题人数不断上升，我们却依然陷在了自己的思路之中，感觉这又是一场噩梦，从10点到12点这2个小时中，整个队伍都在想J题，明明那么多队过了，为什么我们无限WA…难道说题目又看错了？！我们对存疑的地方进行了提问，但是得到的回复却是我们理解的没错！无奈只好留队友gy一个人继续磕这题，我跟队友zt继续看其他题，我把E题大题跟队友zt说下，我们感觉是一道动态规划的题目，然后剩下的时间队友在敲E，我继续看其他题。敲完E后，发现样例过不了，我帮他检查了一下，发现转移方程是有后效性的，不能这样写。但是我们依旧认为这是道dp的题，队友zt继续考虑状态方程要怎么设计，于是打印代码，把机子让给了队友gy。J的进展依旧不顺利，在提交了十几次以后，封榜时我们终于过了J，这是我们过的第4道题目，距离第3道题目已经过了三个多小时…此时早已掉到铜牌区…我跟队友zt继续抢救E，但是发现不管怎样转移，都是有问题的，直到最后十几分钟，我开始换了一种思路，感觉是可行的（事后题解也确实是这种方法），但迫于时间，最终没有写成…</p><p>　　比赛结束之后，我们心情很沉重，没想到我们又死在了所谓的“签到题”上。虽然我们队伍在实验室做比赛可以做得相对不错，但是到了现场之后，我们卡题之后的心理素质问题依旧暴露无遗，仅有的一点实力也发挥不出来，真是可悲。</p><p>　　经过这两次的比赛，我觉得今后锻炼的方向不应该仅仅是知识的水平，编码的水平，更多的是心理素质要提高。心理素质不过硬，再有实力发挥不出来也无济于事。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Manacher算法</title>
      <link href="/posts/manacher-algorithm/"/>
      <url>/posts/manacher-algorithm/</url>
      
        <content type="html"><![CDATA[<p>首先用一个非常巧妙的方式，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 <code>#a#b#b#a#</code>， aba变成 <code>#a#b#a#</code>。为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如 $#a#b#a#。</p><p>下面以字符串 <code>12212321</code> 为例，经过上一步，变成了 s =  <code>$#1#2#2#1#2#3#2#1#</code> ;<br>然后用一个数组  p[i] 来记录以字符 S[i] 为中心的最长回文子串向左/右扩张的长度（包括 s[i] ），比如  s[i]  和  p[i]  的对应关系：  </p><div class="table-container"><table><thead><tr><th>s[i]</th><th>#</th><th>1</th><th>#</th><th>2</th><th>#</th><th>2</th><th>#</th><th>1</th><th>#</th><th>2</th><th>#</th><th>3</th><th>#</th><th>2</th><th>#</th><th>1</th><th>#</th></tr></thead><tbody><tr><td>p[i]</td><td>1</td><td>2</td><td>1</td><td>2</td><td>5</td><td>2</td><td>1</td><td>4</td><td>1</td><td>2</td><td>1</td><td>6</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></tbody></table></div><p><strong>(从上表可以看出，p[i]-1 正好是原字符串中回文串的总长度）</strong></p><a id="more"></a><p>那么怎么计算 p[i] 呢？该算法增加两个辅助变量 id 和 mx<br><strong><code>id</code> :   表示右边界最远的回文子串中心的位置</strong>  <em>(注:貌似很多blog说 id 表示最大回文子串中心的位置，我觉得是不对的）</em><br><strong><code>mx</code> : 则为 id+p[id]，也就是上述回文子串的右边界</strong>。  </p><hr><p>然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：</p><p><strong>如果 mx &gt; i，那么 p[i] &gt;= min(p[2 * id - i], mx - i) ，其中 i 与 j 关于 id 对称。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述结论可写成如下代码：</span></span><br><span class="line"><span class="comment">// 记 j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点。</span></span><br><span class="line"><span class="keyword">if</span> (mx - i &gt; P[j]) </span><br><span class="line">    P[i] = P[j];</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// P[j] &gt;= mx - i </span></span><br><span class="line">    P[i] = mx - i; <span class="comment">// P[i] &gt;= mx - i，取最小值，之后再匹配更新。</span></span><br></pre></td></tr></table></figure><p>(1) 当 <code>mx - i &gt; p[j]</code> 时，</p><p><img src="https://tuchuang001.com/images/2017/01/30/20151027204737400.png" alt="图1.  mx-i &gt; p[i]"></p><p>由 id 的定义知，红色线段的字符串是以 id 为中心的最长回文串!<br>同时， j  是  i  关于 id  的对称点，由于红色字符串是回文字符串，所以<strong>关于 j 对称的回文子串</strong> 和 <strong>关于 i 对称的回文子串</strong> 是<strong>完全一样的</strong>!!(即图中两段绿色的线条)<br>而满足 mx-i&gt;p[j] 时, 说明此时  j  的回文子串半径 <strong>小于</strong>  j  到  mx  对称的左端点的差，此时可以初始化 p[i] = p[j] 。  </p><p>(2) 当 <code>mx-i &lt;= p[j]</code> 时， </p><p><img src="https://tuchuang001.com/images/2017/01/30/20151027205757529.png" alt="图2.  mx-i &lt;= p[j]"></p><p>由于 mx-i&lt;=p[j] ,说明此时$j$的回文子串半径 大于或等于  j  到  mx  对称的左端点的差. <strong>在目前最长回文串（即红色所示）的范围内，关于  i  对称的回文串可能的长度为  mx-i </strong> , 此时可以初始化 p[i]=mx-i . 而对于红色范围之外的（即超过mx的字符），它是否关于  i  对称呢？ 因此，还需再对  p[i]  的回文子串半径进行进一步的增大!!</p><p>(3) 当  <code>mx&lt;=i</code> 时，<br>对于  mx&lt;=i   的情况，无法对  p[i] 做更多的假设，只能令  p[i] = 1 ，然后再去匹配了.</p><hr><p><strong>代码实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换字符串str， 比如将字符串 123 转换成 $#1#2#3#</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform</span> <span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    s[l++] = <span class="string">'$'</span>; s[l++] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">        s[l++] = str[i]; s[l++] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[l] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span> <span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    Transform(str);</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span> (p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; ++i) &#123;</span><br><span class="line">        p[i] = mx &gt; i ? min(p[<span class="number">2</span>*id-i], mx-i) : <span class="number">1</span>; <span class="comment">// 如上所述</span></span><br><span class="line">        <span class="keyword">while</span> (s[i+p[i]] == s[i-p[i]]) p[i]++; </span><br><span class="line">        <span class="comment">//以i为中心，p[i]为半径，查找是否还有可能构成回文的情况</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; mx) &#123; <span class="comment">// 更新最远的右边界</span></span><br><span class="line">            mx = i+p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, p[i]<span class="number">-1</span>); <span class="comment">// 答案即为所有的p[i]-1中的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Manacher </tag>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Trie字典树总结</title>
      <link href="/posts/trie-summary/"/>
      <url>/posts/trie-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="字典树概念"><a href="#字典树概念" class="headerlink" title="字典树概念"></a>字典树概念</h2><p>字典树——又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p><p>它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><a id="more"></a><p><img src="https://tuchuang001.com/images/2017/01/30/20151025214627066.png" alt="Trie"></p><p>有三种基本的性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；  </li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；  </li><li>每个节点的所有子节点包含的字符都不相同.  </li></ul><h2 id="字典树定义与操作"><a href="#字典树定义与操作" class="headerlink" title="字典树定义与操作"></a>字典树定义与操作</h2><p><strong>静态数组版（以一棵26个小写字母组成的Trie为例）：</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span>  </span><br><span class="line">    Trie* next[<span class="number">26</span>]; <span class="comment">// 指向26个儿子节点  </span></span><br><span class="line">    <span class="keyword">bool</span> flag; <span class="comment">// 从根节点到当前节点是否构成单词  </span></span><br><span class="line">...... <span class="comment">// 附加相关信息  </span></span><br><span class="line">&#125; node[MAX_N];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num; <span class="comment">// 当前分配的节点编号  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    num = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(node));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到字符c相对于'a'的编号  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">'a'</span>; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在Trie中插入字符串s  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;  </span><br><span class="line">    Trie* head = &amp;node[<span class="number">0</span>]; <span class="comment">// node[0]为根节点  </span></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123; <span class="comment">// 遍历字符串  </span></span><br><span class="line">        <span class="keyword">int</span> id = getid(*s++);  </span><br><span class="line">        <span class="keyword">if</span> ((head-&gt;next[id]) == <span class="literal">NULL</span>) <span class="comment">// 若该儿子不存在，则分配新的节点  </span></span><br><span class="line">            head-&gt;next[id] = &amp;node[++num];  </span><br><span class="line">        head = head-&gt;next[id]; <span class="comment">// 指针指向儿子节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">head-&gt;flag = <span class="literal">true</span>; <span class="comment">// 最后做上标记  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Trie中查找字符串s  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;  </span><br><span class="line">    Trie* head = &amp;node[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;  </span><br><span class="line">        <span class="keyword">int</span> id = getid(*s++);  </span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next[id] == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        head = head-&gt;next[id];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> head-&gt;flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态分配版：</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">'a'</span>; &#125;</span><br><span class="line">    <span class="function">Trie* <span class="title">newnode</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (Trie*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Trie)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Trie* root, <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">        Trie* head = root;</span><br><span class="line">        <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = getid(*s++);</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;next[id] == <span class="literal">NULL</span>)</span><br><span class="line">                head-&gt;next[id] = newnode();</span><br><span class="line">            head = head-&gt;next[id];</span><br><span class="line">            (head-&gt;cnt)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(Trie* root, <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">        Trie* head = root;</span><br><span class="line">        <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = getid(*s++);</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;next[id] == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(Trie* root)</span> </span>&#123;</span><br><span class="line">        Trie* head = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;next[i] != <span class="literal">NULL</span>) del(head-&gt;next[i]);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; trie;</span><br></pre></td></tr></table></figure><h2 id="字典树的应用"><a href="#字典树的应用" class="headerlink" title="字典树的应用"></a>字典树的应用</h2><p> 1) <code>串的快速检索</code><br> Q：给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。<br> A： 我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。  </p><p> 2) <code>“串”排序</code><br> Q：给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。<br> A：用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。  </p><p> 3) <code>最长公共前缀</code><br> A： 对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数。于是，问题就转化为公共祖先问题。  </p><h2 id="字典树的例题"><a href="#字典树的例题" class="headerlink" title="字典树的例题"></a>字典树的例题</h2><blockquote><p><a href="http://blog.csdn.net/xmzyt1996/article/details/49407595" target="_blank" rel="noopener">HDU 1251 统计难题</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49408063" target="_blank" rel="noopener">POJ 3630 Phone List</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49408175" target="_blank" rel="noopener">POJ 2503 Babelfish</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49408619" target="_blank" rel="noopener">HDU 1075 What Are You Talking About</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49409031" target="_blank" rel="noopener">HDU 1247 Hat’s Words</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49430881" target="_blank" rel="noopener">POJ 1056 IMMEDIATE DECODABILITY</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49431249" target="_blank" rel="noopener">HDU 3172 Virtual Friends</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49431613" target="_blank" rel="noopener">POJ 2001 Shortest Prefixes</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49432173" target="_blank" rel="noopener">POJ 1204 Word Puzzles</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49432673" target="_blank" rel="noopener">HDU 1800 Flying to the Mars</a><br><a href="http://blog.csdn.net/xmzyt1996/article/details/49432775" target="_blank" rel="noopener">HDU 1298 T9</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>素数筛法</title>
      <link href="/posts/seive-of-prime-numbers/"/>
      <url>/posts/seive-of-prime-numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="Eratosthenes筛法"><a href="#Eratosthenes筛法" class="headerlink" title="Eratosthenes筛法"></a>Eratosthenes筛法</h2><p>先用第一个质数2去筛，2留下，把2的倍数剔除掉。再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉。接下去用下一个素数5筛，把5留下，把5的倍数剔除掉。不断重复下去，最后剩下来的都是质数。 </p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断前N个质数  </span></span><br><span class="line"><span class="keyword">bool</span> isPrime[N];</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">2</span>], tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(isPrime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">        prime[tot++] = i;</span><br><span class="line">        <span class="comment">// 把 i 的倍数都筛掉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i*<span class="number">2</span>; j &lt;= N; j += i) &#123;</span><br><span class="line">            isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$\mathcal{O}(nloglogn)$</p><p>但是<code>Eratosthenes筛法</code>存在一个问题，就是一个合数有可能会被多个质因子筛去。比如<code>15</code>，既会被<code>3</code>筛一遍，又会被<code>5</code>筛一遍，所以该算法还有进一步的提升空间。</p><hr><h2 id="Euler筛法"><a href="#Euler筛法" class="headerlink" title="Euler筛法"></a>Euler筛法</h2><p>欧拉筛法是一种线性算法，保证每一个合数只被筛一次。比如<code>15</code>，现在只会被<code>3</code>筛掉，而不会被<code>5</code>再筛一遍。原因在于欧拉筛法只让每个合数被它最小的质因数筛掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isPrime[N];</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">2</span>], tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(isPrime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime[i]) prime[tot++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">        <span class="comment">//超过最大范围，跳出 </span></span><br><span class="line">        <span class="keyword">if</span> (i * prime[j] &gt; N) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//将倍数筛除 </span></span><br><span class="line">        isPrime[i * prime[j]] = <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//保证只筛到以prime[j]为最小质因数的数 </span></span><br><span class="line">        <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来做两点说明：</p><ul><li><p><strong>保证每个合数都会被筛掉</strong></p><p>不妨将合数$x$做质因数分解，得到$x = p_{1}^{k1}p_{2}^{k2}\dots p_{m}^{km}$，其中$p_{i}$都是质数，并按从小到大排列。</p><p>则合数$x$必然在 for循环枚举到 $i = p_{1}^{k1-1}p_{2}^{k2}\dots p_{m}^{km}$的时候，被质数$prime[j] = p_{1}$筛掉。</p></li><li><p><strong>保证每个合数只被筛一次</strong></p><p>假设存在另一个质因数$p_t$$(t\neq1)$也筛掉了$n$，那么此时$i$就应该等于$p_{1}^{k1}p_{2}^{k2}\dots p_{t}^{kt-1}\dots p_{m}^{km}$。</p><p>但注意到，$i$也被$p_1$整除，那么在内层for循环枚举$j$，当枚举到$prime[j] = p_1$时，便根据语句<code>i % prime[j] == 0</code>跳出内层循环，根本枚举不到$prime[j] = p_t$，让$p_t$筛掉$n$。</p></li></ul><p>时间复杂度：$\mathcal{O}(n)$</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
