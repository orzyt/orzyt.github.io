{"meta":{"title":"扬涛的博客","subtitle":"上善若水·大道至简","description":"嗨，你好！我是扬涛，计科学生一枚。博客主要用于记录自己学习过程中的收获与感悟。","author":"orzyt","url":"https://orzyt.cn"},"pages":[{"title":"对不起，你来到了没有知识的荒原 Oops...","date":"2018-11-10T11:47:16.899Z","updated":"2018-11-10T11:47:16.899Z","comments":false,"path":"404.html","permalink":"https://orzyt.cn/404.html","excerpt":"","text":"页面将在秒内自动跳转回首页 function countDown(secs, surl) { var jumpTo = document.getElementById('jumpTo'); jumpTo.innerHTML = secs; if (--secs > 0) { setTimeout(\"countDown(\" + secs + \",'\" + surl + \"')\", 1000); } else { location.href = surl; } } countDown(5,'/');"},{"title":"关于","date":"2019-02-07T14:11:30.665Z","updated":"2019-02-07T14:11:30.665Z","comments":true,"path":"about/index.html","permalink":"https://orzyt.cn/about/index.html","excerpt":"","text":"关于我 嗨，你好。我叫扬涛，目前为北航2018级计算机学院的研究生。研究方向为深度学习、计算机视觉。很高兴能在这儿遇见你，欢迎一起学习交流。 时间线"},{"title":"标签","date":"2018-11-10T11:47:16.935Z","updated":"2018-11-10T11:47:16.935Z","comments":true,"path":"tags/index.html","permalink":"https://orzyt.cn/tags/index.html","excerpt":"","text":""},{"title":"学习资源汇总","date":"2019-02-28T06:30:38.238Z","updated":"2019-02-28T06:30:38.238Z","comments":true,"path":"study/index.html","permalink":"https://orzyt.cn/study/index.html","excerpt":"","text":"数学基础 麻省理工公开课：线性代数 Linear Algebra Done Right [Solutions] 机器学习 CS229 Machine Learning CS229 课程讲义中文翻译 Coursera Machine Learning [notes] Machine Learning Foundations (機器學習基石) Machine Learning Techniques (機器學習技法) 深度学习 UFLDL Tutorial Neural networks and deep learning CS231n Convolutional Neural Networks for Visual Recognition CS231n Spring2017 课程视频 [slides] 贺完结！CS231n官方笔记授权翻译总集篇发布 Geoffrey Hinton：Neural Networks for Machine Learning fast.ai 深度学习课程 [lecture materials] Deep Learning Specialization [Coursera] [网易云课堂] 复旦邱锡鹏：《神经网络与深度学习》 深度学习(花书) [中文版] [英文版] [读书笔记] CS 20SI: Tensorflow for Deep Learning Research 强化学习 David Silver强化学习 [中文字幕视频] CS 294-112 深度强化学习 [中文字幕视频] 计算机视觉 CS131 Computer Vision: Foundations and Applications 教程 廖雪峰：Python教程 lijin-THU：中文 Python 笔记 其它 PaperWeekly 清华大学开源软件镜像站 TED 李飞飞：如何教计算机理解图片 Best Paper Awards in Computer Science (since 1996) Must Know Tips/Tricks in Deep Neural Networks Top 10 data mining algorithms in plain English Classification datasets results 3D Visualization of a Convolutional Neural Network"}],"posts":[{"title":"【论文笔记】迁移自适应学习综述","slug":"transfer-adaptation-learning","date":"2019-03-20T14:44:46.000Z","updated":"2019-03-22T09:00:27.217Z","comments":true,"path":"posts/transfer-adaptation-learning/","link":"","permalink":"https://orzyt.cn/posts/transfer-adaptation-learning/","excerpt":"论文题目：《Transfer Adaptation Learning: A Decade Survey》 论文作者：Lei Zhang 论文链接：http://cn.arxiv.org/pdf/1903.04687.pdf","text":"论文题目：《Transfer Adaptation Learning: A Decade Survey》 论文作者：Lei Zhang 论文链接：http://cn.arxiv.org/pdf/1903.04687.pdf 介绍在很多实际的情况中, 源域(source domain)和目标域(target domain)之间存在： 分布不匹配(distribution mismatch) 领域偏移(domain shift) 独立同分布(independent identical distribution, i.i.d)的假设不再满足! 迁移学习(transfer learning)假设源域与目标域拥有不同的联合概率分布 P(X_{source}, Y_{source}) \\neq P(X_{target}, Y_{target}) 领域自适应(domain adaptation)假设源域与目标域拥有不同的边缘概率分布, 但拥有相同的条件概率分布 P(X_{source}) \\neq P(X_{target}), P(Y_{source} | X_{source}) = P(Y_{target} | X_{target}) 实例权重调整自适应(Instance Re-weighting Adaptation)当训练集和测试集来自不同分布时, 这通常被称为采样选择偏差(sample selection bias)或者协方差偏移(covariant shift). 实例权重调整方法旨在通过非参数方式对跨域特征分布匹配直接推断出重采样的权重. 基于直觉的权重调整(Intuitive Weighting)直接对原始数据进行权重调整. 首次提出于NLP领域1, 主要的方法有著名的TrAdaBoost2. 基于核映射的权重调整(Kernel Mapping Based Weighting)将原始数据映射到高维空间(如,再生核希尔伯特空间RKHS)中进行权重调整. 分布匹配(Distribution Matching)主要思想是通过重新采样源数据的权重来匹配再生核希尔伯特空间中源数据和目标数据之间的均值. 主要有两种非参数统计量来衡量分布差异: 核均值匹配(kernel mean matching, KMM) \\begin{array}{l} {\\min \\limits_{\\beta}\\left\\|E_{x^{\\prime} \\sim P_{r}^{\\prime}}\\left[\\Phi\\left(x^{\\prime}\\right)\\right]-E_{x \\sim P_{r}}[\\beta(x) \\Phi(x)]\\right\\|} \\\\ {\\text {s.t.} \\quad \\beta(x) \\geq 0, E_{x \\sim P_{r}}[\\beta(x)]=1} \\end{array}Huang等人3首次提出通过调整源样本的$\\beta$权重系数, 使得带权源样本和目标样本的KMM最小. 最大均值差异(maximum mean discrepancy, MMD)45 d_{\\mathcal{H}}^{2}\\left(\\mathcal{D}_{s}, \\mathcal{D}_{t}\\right)=\\left\\|\\frac{1}{M} \\sum_{i=1}^{M} \\phi\\left(x_{i}^{s}\\right)-\\frac{1}{N} \\sum_{j=1}^{N} \\phi\\left(x_{j}^{t}\\right)\\right\\|_{\\mathcal{H}}^{2}weighted MMD6方法考虑了类别权重偏差. 样本选择(Sample Selection)主要方法有基于k-means聚类的KMapWeighted7, 基于MMD和$\\ell_{2,1}$-norm的TJM8等. 协同训练(Co-training Based Weighting)主要思想是假设数据集被表征为两个不同的视角, 使两个分类器独立地从每个视角中进行学习. 主要方法有CODA9, 以及基于GAN的RANN10等. 特征自适应(Feature Adaptation)特征自适应方法旨在寻找多源数据(multiple sources)的共同特征表示. 基于特征子空间(Feature Subspace-Based)该方法假设数据可以被低维线性子空间进行表示, 即低维的格拉斯曼流形(Grassmann manifold)被嵌入到高维数据中. 通常用PCA方法来构造该流形, 使得源域和目标域可以看成流形上的两个点, 并得到两者的测地线距离(geodesic flow). 基于流形的方法有SGF11和GFK12 基于子空间对齐的方法有SA13,SDA14和GTH15 基于特征变换(Feature Transformation-Based)特征变换方法旨在学习变换或投影矩阵,使得源域和目标域中的数据在某种分布度量准则下更接近. 基于投影(Projection-Based)该方法通过减少不同域之间的边缘分布和条件分布差异, 求解出最优的投影矩阵. 主要方法有: 基于边缘分布MMD的TCA16, 条件分布MMD的JDA17 基于布拉格曼散度(Bregman divergence)的TSL18 基于希尔伯特-施密特独立性(Hilbert-Schmidt Independence Criterion)19 基于度量(Metric-Based)该方法通过在带标签的源域中学习一个好的距离度量, 使得其能够应用于相关但不同的目标域中. 主要方法有: 基于一阶统计量的RTML20 基于二阶统计量的CORAL21 基于增强(Augmentation-Based)该方法假设数据的特征被分为三种类型:公共特征/源域特征/目标域特征. 主要方法有: 基于零填充(Zero Padding)的EasyAdapt(EA)22 基于生成式模型(Generative Model)23 基于特征重构(Feature Reconstruction-Based)主要方法有: 低秩重构(Low-rank Reconstruction)24 稀疏重构(Sparse Reconstruction)25 基于特征编码(Feature Coding-Based)主要方法有: 共享域字典(Domain-shared dictionary)26 指定域字典(Domain-specific dictionary)27 分类器自适应(Classifier Adaptation)分类器自适应旨在利用源域中带标签数据和目标域中少量带标签数据学习一个通用的分类器. 基于核分类器(Kernel Classifier-Based)主要方法有: 自适应支持向量机(adaptive support vector machine, ASVM)28 基于多核学习(multiple kernel learning, MKL)的域迁移分类器29 基于流形正则项(Manifold Regularizer-Based)主要方法有ARTL30,DMM31,MEDA32等. 基于贝叶斯分类器(Bayesian Classifier-Based)主要方法有核贝叶斯迁移学习KBTL33等. 深度网络自适应(Deep Network Adaptation)2014年, Yosinski等人34讨论了深度神经网络中不同层特征的可迁移特性. 基于边缘分布对齐(Marginal Alignment-Based)主要方法有: 深度域混淆DDC35 深度自适应网络DAN36 联合自适应网络JAN37, 同时提出了Joint MMD准则 基于条件分布对齐(Conditional Alignment-Based)主要方法有深度迁移网络DTN38 基于自动编码器(Autoencoder-Based)主要方法有边缘堆叠式降噪自动编码器mSDA39 对抗式自适应(Adversarial Adaptation)通过对抗目标(如,域判别器)来减少域间差异. 基于梯度转换(Gradient Reversal-Based)Ganin等人40首次提出可以通过添加一个简单的梯度转换层(gradient reversal layer, GRL)来实现领域自适应. 基于Minimax优化(Minimax Optimization-Based)Ajakan等人41首次结合分类损失和对抗目标, 提出了DANN方法. 其它方法还有: 对抗判别领域自适应ADDA42 条件领域对抗网络CDAN43 最大分类器差异MCD44 基于生成对抗网络(Generative Adversarial Net-Based)主要方法有: CyCADA45 Duplex GAN46 … 基准数据集 Office-31 (3DA) Office+Caltech-10 (4DA) MNIST+USPS Multi-PIE COIL-20 MSRC+VOC2007 IVLSC Cross-dataset Testbed Office HomeNEW ImageCLEF P-A-C-SNEW 参考文献 1. J. Jiang and C. Zhai, Instance weighting for domain adaptation in nlp, in ACL, 2007, pp. 264–271. &#8617; 2. W. Dai, Q. Yang, G. R. Xue, and Y. Yu, Boosting for transfer learning, in ICML, 2007, pp. 193–200. &#8617; 3. J. Huang, A. Smola, A. Gretton, K. Borgwardt, and B. Scholkopf, Correcting sample selection bias by unlabeled data, in NIPS, 2007, pp. 1–8. &#8617; 4. A. Gretton, K. Borgwardt, M. Rasch, B. Schoelkopf, and A. Smola, A kernel method for the two-sample-problem, in NIPS, 2006. &#8617; 5. A. Gretton, K. Borgwardt, M. Rasch, B. Scholkopf, and A. Smola, A kernel two-sample test, Journal of Machine Learning Research, pp. 723–773, 2012 &#8617; 6. H. Yan, Y. Ding, P. Li, Q. Wang, Y. Xu, and W. Zuo, Mind the class weight bias: Weighted maximum mean discrepancy for unsupervised domain adaptation, in CVPR, 2017, pp. 2272–2281 &#8617; 7. E. H. Zhong, W. Fan, J. Peng, K. Zhang, J. Ren, D. S. Turaga, and O. Verscheure, Cross domain distribution adaptation via kernel mapping, in ACM SIGKDD, 2009, pp. 1027–1036. &#8617; 8. M. Long, J. Wang, G. Ding, J. Sun, and P. S. Yu, Transfer joint matching for unsupervised domain adaptation, in CVPR, 2014, pp. 1410–1417. &#8617; 9. M. Chen, K. Q. Weinberger, and J. C. Blitzer, Co-training for domain adaptation, in NIPS, 2011. &#8617; 10. Q. Chen, Y. Liu, Z. Wang, I. Wassell, and K. Chetty, Re-weighted adversarial adaptation network for unsupervised domain adaptation, in CVPR, 2018, pp. 7976–7985. &#8617; 11. R. Gopalan, R. Li, and R. Chellappa, Domain adaptation for object recognition: An unsupervised approach, in ICCV, 2011, pp. 999–1006 &#8617; 12. B. Gong, Y. Shi, F. Sha, and K. Grauman, Geodesic flow kernel for unsupervised domain adaptation, in CVPR, 2012, pp. 2066–2073 &#8617; 13. B. Fernando, A. Habrard, M. Sebban, and T. Tuytelaars, Unsupervised visual domain adaptation using subspace alignment, in ICCV, 2013, pp. 2960–2967. &#8617; 14. B. Sun and K. Saenko, Subspace distribution alignment for unsupervised domain adaptation, in BMVC, 2015, pp. 24.1–24.10. &#8617; 15. J. Liu and L. Zhang, Optimal projection guided transfer hashing for image retrieval, in AAAI, 2018. &#8617; 16. S. J. Pan, I. W. Tsang, J. T. Kwok, and Q. Yang, Domain adaptation via transfer component analysis, IEEE Trans. Neural Networks, vol. 22, no. 2, p. 199, 2011 &#8617; 17. M. Long, J. Wang, G. Ding, J. Sun, and P. S. Yu, Transfer feature learning with joint distribution adaptation, in ICCV, 2014, pp. 2200–2207. &#8617; 18. S. Si, D. Tao, and B. Geng, Bregman divergence-based regularization for transfer subspace learning, IEEE Trans. Knowledge and Data Engineering, vol. 22, no. 7, pp. 929–942, 2010. &#8617; 19. A. Gretton, O. Bousquet, A. Smola, and B. Scholkopf, Measuring statistical dependence with hilbert-schmidt norms, in ALT, 2005. &#8617; 20. Z. Ding and Y. Fu, Robust transfer metric learning for image classification, IEEE Trans. Image Processing, vol. 26, no. 2, p. 660670, 2017. &#8617; 21. B. Sun, J. Feng, and K. Saenko, Return of frustratingly easy domain adaptation, in AAAI, 2016, pp. 153–171. &#8617; 22. H. Daume III, Frustratingly easy domain adaptation, in arXiv,2009. &#8617; 23. R. Volpi, P. Morerio, S. Savarese, and V. Murino, Adversarial feature augmentation for unsupervised domain adaptation, in CVPR, 2018, pp. 5495–5504. &#8617; 24. I. H. Jhuo, D. Liu, D. T. Lee, and S. F. Chang, Robust visual domain adaptation with low-rank reconstruction, in CVPR, 2012, pp. 2168–2175. &#8617; 25. L. Zhang, W. Zuo, and D. Zhang, Lsdt: Latent sparse domain transfer learning for visual adaptation, IEEE Trans. Image Processing, vol. 25, no. 3, pp. 1177–1191, 2016. &#8617; 26. S. Shekhar, V. Patel, H. Nguyen, and R. Chellappa, Generalized domain-adaptive dictionaries, in CVPR, 2013, pp. 361–368. &#8617; 27. F. Zhu and L. Shao, Weakly-supervised cross-domain dictionary learning for visual recognition, International Journal of Computer Vision, vol. 109, no. 1-2, pp. 42–59, 2014. &#8617; 28. J. Yang, R. Yan, and A. G. Hauptmann, Cross-domain video concept detection using adaptive svms, in ACM MM, 2007, pp. 188–197. &#8617; 29. L. Duan, I. Tsang, D. Xu, and S. Maybank, Domain transfer svm for video concept detection, in CVPR, 2009 &#8617; 30. M. Long, J. Wang, G. Ding, S. Pan, and P. Yu, Adaptation regularization: a general framework for transfer learning, IEEE Trans. Knowledge and Data Engineering, vol. 26, no. 5, p. 10761089, 2014. &#8617; 31. Y. Cao, M. Long, and J. Wang, Unsupervised domain adaptation with distribution matching machines, in AAAI, 2018 &#8617; 32. J. Wang, W. Feng, Y. Chen, H. Yu, M. Huang, and P. S. Yu, Visual domain adaptation with manifold embedded distribution alignment, 2018. &#8617; 33. M. Gonen and A. Margolin, Kernelized bayesian transfer learning, in AAAI, 2014, pp. 1831–1839. &#8617; 34. J. Yosinski, J. Clune, Y. Bengio, and H. Lipson, How transferable are features in deep neural networks, in NIPS, 2014. &#8617; 35. E. Tzeng, J. Hoffman, N. Zhang, K. Saenko, and T. Darrell, Deep domain confusion: Maximizing for domain invariance, arXiv, 2014 &#8617; 36. M. Long, Y. Cao, J. Wang, and M. I. Jordan, Learning transferable features with deep adaptation networks, in ICML, 2015, pp. 97–105. &#8617; 37. M. Long, H. Zhu, J. Wang, and M. Jordan, Deep transfer learning with joint adaptation networks, in ICML, 2017. &#8617; 38. X. Zhang, F. Yu, S. Wang, and S. Chang, Deep transfer network: Unsupervised domain adaptation, in arXiv, 2015. &#8617; 39. M. Chen, Z. Xu, K. Weinberger, and F. Sha, Marginalized denoising autoencoders for domain adaptation, in ICML, 2012 &#8617; 40. Y. Ganin and V. Lempitsky, Unsupervised domain adaptation by backpropagation, in arXiv, 2015. &#8617; 41. H. Ajakan, P. Germain, H. Larochelle, F. Laviolette, and M. Marchand, Domain-adversarial neural network, in arXiv, 2015 &#8617; 42. E. Tzeng, J. Hoffman, K. Saenko, and T. Darrell, Adversarial discriminative domain adaptation, in CVPR, 2017, pp. 7167–7176 &#8617; 43. M. Long, Z. Cao, J. Wang, and M. I. Jordan, Conditional adversarial domain adaptation, in NIPS, 2018. &#8617; 44. K. Saito, K. Watanabe, Y. Ushiku, and T. Harada, Maximum classifier discrepancy for unsupervised domain adaptation, in CVPR, 2018, pp. 3723–3732. &#8617; 45. J. Hoffman, E. Tzeng, T. Park, and J. Zhu, Cycada: Cycleconsistent adversarial domain adaptation, in ICML, 2018. &#8617; 46. L. Hu, M. Kan, S. Shan, and X. Chen, Duplex generative adversarial network for unsupervised domain adaptation, in CVPR, 2018, pp. 1498–1507. &#8617;","categories":[{"name":"迁移学习","slug":"迁移学习","permalink":"https://orzyt.cn/categories/迁移学习/"}],"tags":[{"name":"迁移学习","slug":"迁移学习","permalink":"https://orzyt.cn/tags/迁移学习/"},{"name":"领域自适应","slug":"领域自适应","permalink":"https://orzyt.cn/tags/领域自适应/"}]},{"title":"强化学习实践（二）：Gridworld","slug":"gridworld","date":"2019-03-13T11:31:33.000Z","updated":"2019-03-14T10:56:41.040Z","comments":true,"path":"posts/gridworld/","link":"","permalink":"https://orzyt.cn/posts/gridworld/","excerpt":"《Reinforcement Learning: An Introduction》在第三章中给出了一个简单的例子:Gridworld, 以帮助我们理解finite MDPs, 同时也求解了该问题的贝尔曼期望方程和贝尔曼最优方程. 本文简要说明如何进行编程求解.","text":"《Reinforcement Learning: An Introduction》在第三章中给出了一个简单的例子:Gridworld, 以帮助我们理解finite MDPs, 同时也求解了该问题的贝尔曼期望方程和贝尔曼最优方程. 本文简要说明如何进行编程求解. 问题 下图用一个矩形网格展示了一个简单finite MDP - Gridworld.网格中的每一格对应于environment的一个state.在每一格, 有四种可能的actions：上/下/左/右, 对应于agent往相应的方向移动一个单元格.使agent离开网格的actions会使得agent留在原来的位置, 但是会有一个值为-1的reward.除了那些使得agent离开state A和state B的action, 其他的actions对应的reward都是0.处在state A时, 所有的actions会有值为+10的reward, 并且agent会移动到state A&#39;.处在state B时, 所有的actions会有值为+5的reward, 并且agent会移动到state B&#39;. 元素 状态(State): 网格的坐标, 共 $5 \\times 5 = 25$ 个状态; 动作(Action): 上/下/左/右四种动作; 策略(Policy): $\\pi(a | s) = \\frac14 \\; \\text{for} \\; \\forall s \\in S, \\text{and} \\; \\forall \\; a \\in \\{↑,↓,←,→\\}$; 奖励(Reward): 如题所述; 折扣因子(Discount rate): $\\gamma \\in [0, 1]$, 本文采用 $\\gamma=0.9$. 目标 使用贝尔曼期望方程, 求解给定随机策略 $\\pi(a | s) = \\frac14$ 下的状态值函数. 使用贝尔曼最优方程, 求解最优状态值函数. 实现","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/categories/强化学习/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/tags/强化学习/"},{"name":"贝尔曼方程","slug":"贝尔曼方程","permalink":"https://orzyt.cn/tags/贝尔曼方程/"}]},{"title":"强化学习实践（一）：Tic-Tac-Toe","slug":"tic-tac-toe","date":"2019-03-08T10:55:54.000Z","updated":"2019-03-08T13:29:43.661Z","comments":true,"path":"posts/tic-tac-toe/","link":"","permalink":"https://orzyt.cn/posts/tic-tac-toe/","excerpt":"为了对强化学习的基本概念有一个直观的认识,《Reinforcement Learning: An Introduction》第一章给出了一个简单的例子：Tic-Tac-Toe游戏. 游戏规则游戏的规则很简单, 两位玩家在 3x3 的棋盘上轮流下棋, 一位打 X, 另一位打 O, 若棋盘的任意一行、任意一列、正反对角线上有三个相同的棋, 则执该棋的玩家获胜. 若棋盘下满仍没有决出胜负, 则平局.","text":"为了对强化学习的基本概念有一个直观的认识,《Reinforcement Learning: An Introduction》第一章给出了一个简单的例子：Tic-Tac-Toe游戏. 游戏规则游戏的规则很简单, 两位玩家在 3x3 的棋盘上轮流下棋, 一位打 X, 另一位打 O, 若棋盘的任意一行、任意一列、正反对角线上有三个相同的棋, 则执该棋的玩家获胜. 若棋盘下满仍没有决出胜负, 则平局. 我们尝试使用强化学习的方法来训练一个Agent, 使其能够在该游戏上表现出色(即Agent在任何情况下都不会输, 最多平局). 由于没有外部经验, 因此我们需要同时训练两个Agent进行上万轮的对弈来寻找最优策略. 注:下面的代码只给出部分关键实现过程, 完整代码见:tic_tac_toe.py. 版权归 @Shangtong Zhang 等人所有, 仅添加中文注释便于理解. 状态强化学习一个重要的概念就是——状态(State). 状态是指Agent在一个特定时刻从环境中所感知的信号. 在Tic-Tac-Toe游戏中, 状态即为 3*3 棋盘的布局. 定义一个State类用来表示状态. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class State: def __init__(self): '''状态初始化 棋盘使用 n * n 的数组进行表示 棋盘中的数字: 1代表先手, -1代表后手下, 0代表该位置无棋子 ''' # 该状态的数组表示 self.data = np.zeros((BOARD_ROWS, BOARD_COLS)) # 该状态下的胜利者 self.winner = None # 该状态的哈希值表示 self.state_hash = None # 该状态是否为终结状态 self.end = None def hash(self): '''计算状态的哈希值表示 Returns ------- int 状态的哈希值表示 ''' pass def is_end(self): '''判断当前状态是否为终结状态. 如果为终结状态, 同时判断胜利者是谁 Returns ------- bool 当前状态是否为终结状态 ''' pass def next_state(self, i, j, symbol): '''计算当前状态的后继状态 Parameters ---------- i : int 下一步动作的行坐标 j : int 下一步动作的列坐标 symbol : int 动作的执行者(1代表先手, -1代表后手) Returns ------- State 下一步棋盘的状态 ''' pass def print_state(self): '''打印状态信息 ''' pass 根据游戏规则我们知道, 每个格子仅有三种状态, 即先手(1), 后手(-1), 空(0), 那么该游戏的状态数上限仅有 $3^9=19683$ 个. 因此, 我们可以预处理出所有合法的棋盘状态, 供后面强化学习算法使用. 1all_states = get_all_states() AgentPlayer相关定义一个AgentPlayer类用来表示强化学习中和环境进行交互的智能体. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class AgentPlayer: def __init__(self, step_size=0.1, epsilon=0.1): '''Agent初始化 Parameters ---------- step_size : float, optional 更新步长 epsilon : float, optional 探索概率 ''' # 值函数 self.value = dict() # 值函数更新步长 self.step_size = step_size # Agent探索概率 self.epsilon = epsilon # Agent在一轮游戏中经历的所有状态 self.states = [] # 记录每个状态是否采取贪心策略 self.greedy = [] def reset(self): '''重置Agent的状态, 开启新一轮游戏 ''' pass def set_state(self, state): '''将当前棋盘状态加到Agent的状态列表 Parameters ---------- state : State 当前棋盘的状态 ''' pass def set_symbol(self, symbol): '''根据先后手, 初始化Agent的值函数 Parameters ---------- symbol : int 先手还是后手 ''' pass def backup(self): '''值函数迭代 ''' pass def act(self): '''根据状态采取动作 Returns ------- list 采取的动作 ''' pass def save_policy(self): '''保存策略 ''' pass def load_policy(self): '''加载策略 ''' pass 在AgentPlayer类中, 我们重点关注 set_symbol, backup, act 三个函数. 奖励Agent每次与环境进行交互的时候, 都会得到一个反馈信号称之为奖励(Reward). Agent的目标是最大化游戏过程中的奖励总和. 在 Tic-Tac-Toe 游戏中, 由于只有在游戏结束的时候才知道胜负, 故没有给出每一步显式的奖励, 而是直接评估状态的值函数(Value Function). 根据我们的先验知识, 可以对不同的状态设置不同的初始值函数. 对于导致游戏结束的终结状态, 可分为胜利/平局/失败三种情况, 相应的值函数为1.0/0.5/0.0. 而对于非终结状态, 可以简单地将状态的值函数设为0.5, 代表无法判断胜负. 12345678910111213141516171819202122def set_symbol(self, symbol): '''根据先后手, 初始化Agent的值函数 Parameters ---------- symbol : int 先手还是后手 ''' self.symbol = symbol for state_hash in all_states.keys(): (state, is_end) = all_states[state_hash] if is_end: # 终结状态 if state.winner == self.symbol: # 获胜 self.value[state_hash] = 1.0 elif state.winner == 0: # 平局 self.value[state_hash] = 0.5 else: # 失败 self.value[state_hash] = 0 else: # 非终结状态 self.value[state_hash] = 0.5 值函数迭代使用时序差分学习(Temporal-Difference Learning)方法进行值函数的更新: V \\left( S _ { t } \\right) \\leftarrow V \\left( S _ { t } \\right) + \\alpha \\left[ V \\left( S _ { t + 1 } \\right) - V \\left( S _ { t } \\right) \\right]123456789101112131415def backup(self): '''值函数迭代 ''' # 获取状态的哈希值表示 self.states = [state.hash() for state in self.states] # 逆序遍历所有的状态, 并进行值函数的更新 for i in reversed(range(len(self.states) - 1)): state = self.states[i] # TD误差 = V(s_&#123;t + 1&#125;) - V(s_&#123;t&#125;) td_error = self.greedy[i] * (self.value[self.states[i + 1]] - self.value[state]) # TD-Learning(时序差分学习)更新公式 self.value[state] += self.step_size * td_error 动作采用 $\\epsilon$-greedy 的贪心策略选择动作, 即有 $1 - \\epsilon$ 的概率选择后继状态值函数最大的动作, 有 $\\epsilon$ 概率进行随机选择动作. 1234567891011121314151617181920212223242526272829303132333435363738394041424344def act(self): '''根据状态采取动作 Returns ------- list 采取的动作 ''' # 获取当前状态 state = self.states[-1] # 下一步所有可能的状态 next_states = [] # 下一步所有可能的位置 next_positions = [] for i in range(BOARD_ROWS): for j in range(BOARD_COLS): # 当前棋盘位置上无棋子 if state.data[i, j] == 0: # 可行的位置 next_positions.append([i, j]) # 可行的状态 next_states.append(state.next_state(i, j, self.symbol).hash()) # 有epsilon概率采取随机动作 if np.random.rand() &lt; self.epsilon: action = next_positions[np.random.randint(len(next_positions))] action.append(self.symbol) self.greedy[-1] = False return action values = [] # 遍历下一步所有可能的状态和位置 for state_hash, pos in zip(next_states, next_positions): # 获取对应状态的值函数 values.append((self.value[state_hash], pos)) # 如果有多个状态的值函数相同,且都是最高的,shuffle则起到在这些状态中随机选择的作用 np.random.shuffle(values) # 按值函数从大到小排序 values.sort(key=lambda x: x[0], reverse=True) # 选取最优动作 action = values[0][1] action.append(self.symbol) return action HumanPlayer相关123456789101112131415161718192021222324252627class HumanPlayer: def __init__(self, **kwargs): self.symbol = None self.keys = ['q', 'w', 'e', 'a', 's', 'd', 'z', 'x', 'c'] self.state = None return def reset(self): return def set_state(self, state): self.state = state def set_symbol(self, symbol): self.symbol = symbol return def backup(self, _): return def act(self): self.state.print_state() key = input(\"Input your position:\") data = self.keys.index(key) i = data // int(BOARD_COLS) j = data % BOARD_COLS return [i, j, self.symbol] Agent训练1234567891011121314151617181920212223242526272829303132333435363738def train(epochs, print_every_n=500): '''对Agent进行训练 Parameters ---------- epochs : int 训练轮数 print_every_n : int, optional 每多少轮输出训练信息 ''' # 定义两个Agent player1 = AgentPlayer(epsilon=0.01) player2 = AgentPlayer(epsilon=0.01) # 定义判决器 game = Game(player1, player2) # 先手赢的次数 player1_win = 0.0 # 后手赢的次数 player2_win = 0.0 for i in range(1, epochs + 1): # 新的一轮游戏 game.reset() winner = game.play(print_state=False) if winner == 1: player1_win += 1 if winner == -1: player2_win += 1 # 打印各自的胜率 if i % print_every_n == 0: print('Epoch %d, player 1 winrate: %.02f, player 2 winrate: %.02f' % (i, player1_win / i, player2_win / i)) # 在每轮游戏结束后,对Agent进行学习 player1.backup() player2.backup() # 保存训练好的策略 player1.save_policy() player2.save_policy() Agent对弈经过充分的训练后, 两个Agent对弈的胜率应该都为0%. 即任何局面都只能打成平手, 没有一方可以胜过另一方. 1234567891011121314151617181920212223242526def compete(turns): '''将训练好的两个Agent进行对弈 Parameters ---------- turns : int 对弈轮数 ''' # 对弈的时候不进行动作的探索, 故epsilon设为0. player1 = AgentPlayer(epsilon=0) player2 = AgentPlayer(epsilon=0) game = Game(player1, player2) player1.load_policy() player2.load_policy() player1_win = 0.0 player2_win = 0.0 for _ in range(0, turns): game.reset() winner = game.play() if winner == 1: player1_win += 1 if winner == -1: player2_win += 1 print('%d turns, player 1 win %.02f, player 2 win %.02f' % (turns, player1_win / turns, player2_win / turns)) Human v.s. Agent1234567891011121314151617def play(): '''人类玩家和Agent进行对弈 ''' while True: player1 = HumanPlayer() player2 = AgentPlayer(epsilon=0) game = Game(player1, player2) player2.load_policy() winner = game.play() if winner == player2.symbol: print(\"失败!\") elif winner == player1.symbol: print(\"胜利!\") else: print(\"平局!\")","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/categories/强化学习/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/tags/强化学习/"}]},{"title":"强化学习（三）：动态规划","slug":"planning-by-dp","date":"2019-03-01T06:10:25.000Z","updated":"2019-03-13T12:07:10.945Z","comments":true,"path":"posts/planning-by-dp/","link":"","permalink":"https://orzyt.cn/posts/planning-by-dp/","excerpt":"在上一篇文章 强化学习（二）：马尔可夫决策过程 中, 我们介绍用来对强化学习问题进行建模的马尔可夫决策过程(Markov Decision Processes, MDPs). 由于MDPs的贝尔曼最优方程没有封闭解, 因此一般采用迭代的方法对其进行求解. 本文将介绍使用动态规划(Dynamic Programming)算法来求解MDPs.","text":"在上一篇文章 强化学习（二）：马尔可夫决策过程 中, 我们介绍用来对强化学习问题进行建模的马尔可夫决策过程(Markov Decision Processes, MDPs). 由于MDPs的贝尔曼最优方程没有封闭解, 因此一般采用迭代的方法对其进行求解. 本文将介绍使用动态规划(Dynamic Programming)算法来求解MDPs. 动态规划 动态(Dynamic): 问题中的时序部分 规划(Planning): 对问题进行优化 动态规划将问题分解为子问题, 从子问题的解中得到原始问题的解. 动态规划的性质 最优子结构(Optimal substructure) 应用最优性原则(Principle of optimality) 最优解可以从子问题的最优解中得到 重叠子问题(Overlapping subproblems) 相同的子问题出现多次 问题的解可以被缓存和复用 马尔可夫决策过程满足上面两种性质: 贝尔曼方程 给出了问题的递归分解表示, 值函数 存储和复用了问题的解. v_{\\pi}(s) = \\sum \\limits_{a \\in \\mathcal{A}} \\pi(a|s) (\\mathcal{R}_s^a + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a}v_{\\pi}(s')) 用动态规划进行Planning动态规划假设我们知道MDP的所有知识, 包括状态、行为、转移矩阵、奖励甚至策略等. 对于预测(Prediction)问题: 输入: MDP $&lt;\\mathcal{S}, \\mathcal{A}, \\mathcal{P}, \\mathcal{R}, \\gamma&gt;$ 和 策略 $\\pi$ MRP $&lt;\\mathcal{S}, \\mathcal{P}^{\\pi}, \\mathcal{R}^{\\pi}, \\gamma&gt;$ 输出: 值函数 $v_{\\pi}$ 对于控制(Control)问题: 输入: MDP $&lt;\\mathcal{S}, \\mathcal{A}, \\mathcal{P}, \\mathcal{R}, \\gamma&gt;$ 输出: 最优值函数 $v_{*}$ 最优策略 $\\pi_{*}$ 策略评估 问题: 评估一个给定的策略 $\\pi$求解: 对贝尔曼期望方程进行迭代, $v_1 \\to v_2 \\to \\dots \\to v_{\\pi}$ 通常使用同步备份(synchronous backups)方法: 对于第 $k+1$ 次迭代, 所有状态 $s$ 在第 $k+1$ 时刻的价值 $v_{k+1}(s)$ 用 $v_k(s’)$ 进行更新, 其中 $s’$ 是 $s$ 的后继状态. \\begin{aligned} v _ { k + 1 } ( s ) & = \\sum _ { a \\in \\mathcal { A } } \\pi ( a | s ) \\left( \\mathcal { R } _ { s } ^ { a } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { s s ^ { \\prime } } ^ { a } v _ { k } \\left( s ^ { \\prime } \\right) \\right) \\\\ \\mathbf { v } ^ { k + 1 } & = \\mathcal { R } ^ { \\pi } + \\gamma \\mathcal { P } ^ { \\pi } \\mathbf { v } ^ { k } \\end{aligned} 迭代策略评估算法: 迭代策略评估算法用来估计 $V \\approx v_{\\pi}$. 这里使用in-place版本, 即只保留一份 $v$ 数组, 没有新旧之分. 通常来说, 该方法也能收敛到 $v_{\\pi}$, 而且收敛速度可能更快. 终止条件: $\\max \\limits_ { s \\in \\mathcal{S} } \\left| v _ { k + 1 } ( s ) - v _ { k } ( s ) \\right|$ 小于给定的误差 $\\Delta$ 例子: Small Gridworld [代码] 策略改进让我们考虑一个确定性策略(即对于一个状态来说, 其采取的动作是确定的, 而不是考虑每个动作的概率) $a = \\pi(s)$. 我们可以通过贪心选择来改进策略 $\\pi$: \\pi ^ { \\prime } ( s ) = \\underset { a \\in \\mathcal { A } } { \\operatorname { argmax } } q _ { \\pi } ( s , a ) 即状态 $s$ 的新策略为令动作值函数 $q_{\\pi}(s, a)$ 取得最大值的动作. 相应地, 动作值函数 $q _ { \\pi } \\left( s , \\pi ^ { \\prime } ( s ) \\right)$ 得到了改进: q _ { \\pi } \\left( s , \\pi ^ { \\prime } ( s ) \\right) = \\max _ { a \\in \\mathcal { A } } q _ { \\pi } ( s , a ) \\geq q _ { \\pi } ( s , \\pi ( s ) ) = v _ { \\pi } ( s ) \\\\ {\\scriptsize 由于是确定性策略, 才会有 v_{\\pi}(s) = q_{\\pi}(s, \\pi(s))} \\tag{1}注: 确定性策略下的动作值函数 $q_{\\pi}(s, a)$ 为: \\begin{aligned} q _ { \\pi } ( s , a ) & = \\mathbb { E } \\left[ R _ { t + 1 } + \\gamma v _ { \\pi } \\left( S _ { t + 1 } \\right) | S _ { t } = s , A _ { t } = a \\right] \\\\ & = \\sum _ { s ^ { \\prime } , r } p \\left( s ^ { \\prime } , r | s , a \\right) \\left[ r + \\gamma v _ { \\pi } \\left( s ^ { \\prime } \\right) \\right] \\end{aligned} \\tag{2}从而, 值函数 $v _ { \\pi ^ { \\prime } } ( s )$ 也得到了改进: \\begin{aligned} v_\\pi(s) & \\le q_\\pi(s,\\pi^{'}(s)) {\\scriptsize //公式(1)} \\\\ &={\\Bbb E}[R_{t+1} + \\gamma v_\\pi(S_{t+1})|S_t=s, A_t=\\pi^{'}(s)] {\\scriptsize //公式(2)} \\\\ &={\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma v_\\pi(S_{t+1})|S_t=s]\\ {\\scriptsize //注意外层是在新策略 \\pi^{'} 下求期望} \\\\ & \\le {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma q_\\pi(S_{t+1},\\pi'(S_{t+1}))|S_t=s] {\\scriptsize //对状态S_{t+1}使用公式(1)} \\\\ &= {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma {\\Bbb E}_{\\pi'}\\left[ R_{t+2}+\\gamma v_{\\pi}\\left( S_{t+2}\\right) | S_{t+1}, A_{t+1}=\\pi^{'}(S_{t+1}) \\right] | S_t=s]\\\\ &= {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma R_{t+2}+\\gamma^2 v_{\\pi}\\left( S_{t+2} \\right)|S_t=s] {\\scriptsize //去掉括号内的期望} \\\\ & \\le {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma R_{t+2}+\\gamma ^2 q_\\pi(S_{t+2},\\pi'(S_{t+2}))|S_t=s] {\\scriptsize //对状态S_{t+2}使用公式(1)} \\\\ &= {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma R_{t+2}+\\gamma^2 {\\Bbb E}_{\\pi'}\\left( R_{t+3}+\\gamma v_{\\pi}\\left( S_{t+3} \\right) \\right)|S_t=s]\\\\ &= {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma R_{t+2}+\\gamma^2 R_{t+3}+\\gamma^3 v_{\\pi}\\left( S_{t+3} \\right)|S_t=s]\\\\ & \\vdots \\\\ & \\le {\\Bbb E}_{\\pi'}[R_{t+1}+\\gamma R_{t+2}+\\gamma^2 R_{t+3}+\\gamma^3 R_{t+4} + \\dots |S_t=s]\\\\ &=v_{\\pi^{'}}(s) \\\\ \\end{aligned}当改进停止时, 有如下等式: q _ { \\pi } \\left( s , \\pi ^ { \\prime } ( s ) \\right) = \\max _ { a \\in \\mathcal { A } } q _ { \\pi } ( s , a ) = q _ { \\pi } ( s , \\pi ( s ) ) = v _ { \\pi } ( s ) \\tag{3}可以说, 此时公式(3)满足了贝尔曼最优方程: v _ { \\pi } ( s ) = \\max _ { a \\in \\mathcal { A } } q _ { \\pi } ( s , a )从而, 对所有状态 $s$ 来说, 有$v_{\\pi}(s) = v_{*}(s)$, 即策略 $\\pi$ 改进到了最优策略. 策略迭代策略迭代给定一个策略 $\\pi$, 我们可以首先对策略进行评估, 然后根据值函数 $v_{\\pi}$ 进行贪心地改进策略. \\pi _ { 0 } \\stackrel { \\mathrm { E } } { \\longrightarrow } v _ { \\pi _ { 0 } } \\stackrel { \\mathrm { I } } { \\longrightarrow } \\pi _ { 1 } \\stackrel { \\mathrm { E } } { \\longrightarrow } v _ { \\pi _ { 1 } } \\stackrel { \\mathrm { I } } { \\longrightarrow } \\pi _ { 2 } \\stackrel { \\mathrm { E } } { \\longrightarrow } \\cdots \\stackrel { \\mathrm { I } } { \\longrightarrow } \\pi _ { * } \\stackrel { \\mathrm { E } } { \\longrightarrow } v _ { * }其中, $\\stackrel { \\mathrm { E } } { \\longrightarrow }$ 表示策略评估, $\\stackrel { \\mathrm { I } } { \\longrightarrow }$ 表示策略改进. 评估(Evaluate): v _ { \\pi } ( s ) = \\mathbb { E } \\left[ R _ { t + 1 } + \\gamma R _ { t + 2 } + \\ldots | S _ { t } = s \\right] 改进(Improve): \\pi^{'} = \\text{greedy}(v_{\\pi}) 由于每个策略都比前一个策略更优, 同时一个有限状态的马尔可夫决策过程(finite MDP)仅有有限个策略, 因此该过程一定能够在有限次的迭代中收敛到最优策略 $\\pi_{*}$ 和最优值函数 $v_{*}$. 策略迭代算法: 策略迭代算法分为: 初始化, 策略评估 以及 策略改进 三部分. 其中, 策略改进部分的终止条件为: 是否所有状态的策略不再发生变化. 例子: Jack’s Car Rental [代码] (先占个坑 , 等有时间把这个例子详细写下) 策略迭代求解结果: 图中纵坐标是位置 $1$ 的汽车数量, 横坐标是位置 $2$ 的汽车数量, 该问题共有 $21 \\times 21$ 个状态. 图中的等高线将状态划分为不同的区域, 区域内的数值代表相应的策略(正数代表从位置 $1$ 移往位置 $2$ 的汽车数量, 负数则往反方向移动). 策略迭代的扩展改良策略迭代策略评估并不需要真正的收敛到 $v_{\\pi}$. (比如在 Small Gridworld例子中, 迭代 $k=3$次 即可以得到最优策略.) 为此我们可以引进终止条件, 如: 值函数的 $\\epsilon$ -收敛 简单地迭代 $k$ 次便停止策略评估 或者每次迭代(即 $k=1$ )都对策略进行更新改进, 这种情况等价于值迭代(value iteration). 广义策略迭代广义策略迭代(Generalized Policy iteration，GPI)指代让策略评估(policy-evaluation)和策略改进(policyimprovement)过程进行交互的一般概念, 其不依赖于两个过程的粒度(granularity)和其他细节. 几乎所有强化学习方法都可以很好地被描述为GPI. 也就是说, 它们都具有可辨识的策略与值函数. 其中, 策略 $\\pi$ 通过相应的值函数 $v$ 进行改进, 而值函数 $V$ 总是趋向策略 $\\pi$ 的值函数 $v^{\\pi}$. 如下图所示, 值迭代策略迭代的一个缺点是它的每次迭代都涉及策略评估, 这本身就是一个需要对状态集进行多次扫描的耗时迭代计算. 而在值迭代的过程中, 并没有出现显式的策略, 并且中间过程的值函数可能也不和任何策略对应. 最优性原则一个最优策略可以被分解为两部分: 当前状态的最优动作 $A_{*}$ 后继状态 $S^{\\prime}$ 的最优策略 该原则的意思是说, 一个策略 $\\pi(a|s)$ 在状态 $s$ 取到最优值函数 $v_{\\pi}(s) = v_{*}(s)$ 当且仅当 对于所有从状态 $s$ 出发可到达的状态 $s^{\\prime}$, 策略 $\\pi$ 也能够在状态 $s^{\\prime}$ 取到最优值函数. 确定性值迭代如果我们已经知道子问题的最优解 $v_{*}(s^{\\prime})$, 那么状态 $s$ 的最优解可以通过向前看(lookahead)一步得到, 这称为值迭代(Value Iteration): v_{*}(s) \\gets \\max \\limits_{a \\in \\mathcal{A}} \\left( \\mathcal{R}_{s}^{a} + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a} v_{*}(s') \\right) 值迭代算法: 值迭代算法和策略迭代算法一样, 是用来估计最优策略 $\\pi_{*}$ 的, 它将策略评估和策略改进有效地结合在了一起. 同步动态规划算法总结 问题 贝尔曼方程 算法 预测(Prediction) 贝尔曼期望方程 迭代策略评估 控制(Control) 贝尔曼期望方程 + 贪心策略改进 策略迭代 控制(Control) 贝尔曼最优方程 值迭代 对于有 $m$ 个动作和 $n$ 个状态 的MDP来说, 每次迭代的时间复杂度如下: 函数 复杂度 $v_{\\pi}(s)$ or $v_{*}(s)$ $\\mathcal{O}(mn^2)$ $q_{\\pi}(s, a)$ or $q_{*}(s, a)$ $\\mathcal{O}(m^2n^2)$ 动态规划的扩展异步动态规划同步DP算法的主要缺点是每次迭代都需要对整个状态集进行扫描, 这对于状态数非常多的MDP来说耗费巨大. 而异步DP算法则将所有的状态独立地,以任意顺序进行备份, 并且每个状态的更新次数不一, 这可以显著地减少计算量. 为了保证算法的正确收敛, 异步动态规划算法必须保证所有状态都能够持续地被更新(continue to update the values of all the states), 也就是说在任何时刻任何状态都有可能被更新, 而不能忽略某个状态. 异步DP算法主要有三种简单的思想: 就地动态规划(In-place dynamic programming) 优先扫描(Prioritised sweeping) 实时动态规划(Real-time dynamic programming) 就地动态规划同步DP保留值函数的两个备份, $v_{new}$ 和 $v_{old}$ {\\color{red} {v_{new}(s)}} \\gets \\max \\limits_{a \\in \\mathcal{A}} \\left( \\mathcal{R}_{s}^{a} + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a} {\\color{red} {v_{old}(s')}} \\right)就地值迭代只保留值函数的一个备份. {\\color{red} {v(s)}} \\gets \\max \\limits_{a \\in \\mathcal{A}} \\left( \\mathcal{R}_{s}^{a} + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a} {\\color{red} {v(s')}} \\right) 优先扫描使用贝尔曼误差的大小来进行状态的选择: \\left| \\max _ { a \\in \\mathcal { A } } \\left( \\mathcal { R } _ { s } ^ { a } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { s s ^ { \\prime } } ^ { a } v \\left( s ^ { \\prime } \\right) \\right) - v ( s ) \\right| 仅备份有最大贝尔曼误差的状态 在每次备份后, 需要更新受到影响的状态(即备份状态的前驱状态)的贝尔曼误差 可以使用优先队列进行实现 实时动态规划 思想: 只使用和Agent相关的状态 使用Agent的经验来进行状态的选择 在每个时间步 $S_t, A_t, R_{t+1}$ 对状态 $S_t$ 进行备份 {\\color{red} {v \\left( S _ { t } \\right)}} \\gets \\max _ { a \\in \\mathcal { A } } \\left( \\mathcal { R } _ { {\\color{red}{S _ { t }}} } ^ { a } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { {\\color{red} {S _ { t }}} s ^ { \\prime }} ^ { a } {\\color{red} {v \\left( s ^ { \\prime } \\right)}} \\right) 全宽和采样备份全宽备份 DP使用全宽备份(full-width backups) 对于每次备份(不管同步还是异步) 每个后继状态和动作都会被考虑进去 需要知道MDP转移矩阵和奖励函数 对于大规模DP问题会遇到维数灾难 进行一次备份都太奢侈了 采样备份采样备份(Sample Backups)使用采样的奖励和采样的转移 $&lt; S , A , R , S ^ { \\prime } &gt;$ 来替代奖励函数 $\\mathcal{R}$ 和 转移矩阵 $\\mathcal{P}$. 采样备份的优点: Model-free: 不需要知道MDP的先验知识 通过采样缓解维数灾难 备份代价成为常量, 独立于状态数 $n = |\\mathcal{S}|$ 压缩映射关于上面的种种算法, 我们可能会有如下疑问: 值迭代是否会收敛到 $v_{*}$ ? 迭代策略评估是否会收敛到 $v_{\\pi}$ ? 策略迭代是否会收敛到 $v_{*}$ ? 解唯一吗 ? 算法收敛速度有多快 ? 为了解决这些问题, 需要引入压缩映射(contraction mapping)理论.可以参考: 如何证明迭代式策略评价、值迭代和策略迭代的收敛性？ (关于压缩映射理论有时间再补充, 先到这里吧…) 参考资料 Reinforcement learning: An introduction (second edition) 第四章 UCL Course on RL Lecture3: Planning by Dynamic Programming David Silver 增强学习——Lecture 3 动态规划 强化学习（三）用动态规划（DP）求解","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/categories/强化学习/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/tags/强化学习/"},{"name":"动态规划","slug":"动态规划","permalink":"https://orzyt.cn/tags/动态规划/"}]},{"title":"强化学习（二）：马尔可夫决策过程","slug":"markov-decision-processes","date":"2019-02-27T07:38:18.000Z","updated":"2019-03-13T12:07:14.581Z","comments":true,"path":"posts/markov-decision-processes/","link":"","permalink":"https://orzyt.cn/posts/markov-decision-processes/","excerpt":"在上一篇文章 强化学习（一）：强化学习简介 中, 我们介绍了强化学习的一些基本概念. 本文将介绍用来对强化学习问题进行建模的马尔可夫决策过程(Markov Decision Processes, MDPs).","text":"在上一篇文章 强化学习（一）：强化学习简介 中, 我们介绍了强化学习的一些基本概念. 本文将介绍用来对强化学习问题进行建模的马尔可夫决策过程(Markov Decision Processes, MDPs). 马尔可夫过程马尔可夫决策过程简介马尔可夫决策过程(Markov Decision Processes, MDPs)形式上用来描述强化学习中的环境. 其中,环境是完全可观测的(fully observable),即当前状态可以完全表征过程. 几乎所有的强化学习问题都能用MDPs来描述： 最优控制问题可以描述成连续MDPs; 部分观测环境可以转化成MDPs; 赌博机问题是只有一个状态的MDPs. 马尔可夫性质 马尔科夫性质(Markov Property)表明: 未来只与现在有关,而与过去无关. 状态转移矩阵对于一个马尔可夫状态$S$及其后继状态$S’$,其状态转移概率由下式定义: \\mathcal { P } _ { s s ^ { \\prime } } = \\mathbb { P } \\left[ S _ { t + 1 } = s ^ { \\prime } | S _ { t } = s \\right]状态转移矩阵(State Transition Matrix)$\\mathcal{P}$定义了从所有状态$S$转移到所有后继状态$S’$的概率. \\mathcal { P } = \\left[ \\begin{array} { c c c } { \\mathcal { P } _ { 11 } } & { \\dots } & { \\mathcal { P } _ { 1 n } } \\\\ { \\vdots } & { } & { } \\\\ { \\mathcal { P } _ { n 1 } } & { \\cdots } & { \\mathcal { P } _ { n n } } \\end{array} \\right]其中,$n$为状态个数,且矩阵的每行和为1. 马尔可夫过程马尔可夫过程(Markov Process)是一个无记忆的随机过程(memoryless random process). 即,随机状态$S_1, S_2, \\dots$序列具有马尔可夫性质. 马尔可夫过程(或马尔可夫链)是一个二元组$&lt;\\mathcal{S}, \\mathcal{P}&gt;$ $\\mathcal{S}$: (有限)状态集 $\\mathcal{P}$: 状态转移概率矩阵, $\\mathcal { P } _ { s s ^ { \\prime } } = \\mathbb { P } \\left[ S _ { t + 1 } = s ^ { \\prime } | S _ { t } = s \\right]$ 圆圈代表状态, 箭头代表状态之间的转移, 数值代表转移概率. 状态转移矩阵$\\mathcal{P}$如下: {\\mathcal P} =\\begin{bmatrix} & C1 & C2 & C3 & Pass & Pub & FB & Sleep\\\\ C1 & &0.5 & & & & 0.5 & \\\\ C2 & & & 0.8 & & & &0.2\\\\ C3 & & & & 0.6& 0.4& &\\\\ Pass & & & & & & &1.0\\\\ Pub &0.2 & 0.4& 0.4 & & & &\\\\ FB &0.1 & & & & & 0.9 &\\\\ Sleep & & & & & & &1.0 \\end{bmatrix} 马尔可夫奖励过程马尔可夫奖励过程(Markov Reward Process, MRP)是带有奖励的马尔可夫链. 马尔可夫奖励过程是一个四元组&lt;$\\mathcal{S}$, $\\mathcal{P}$, $\\mathcal{R}$, $\\mathcal{\\gamma}$&gt; $\\mathcal{S}$: (有限)状态集 $\\mathcal{P}$: 状态转移概率矩阵, $\\mathcal { P } _ { s s ^ { \\prime } } = \\mathbb { P } \\left[ S _ { t + 1 } = s ^ { \\prime } | S _ { t } = s \\right]$ $\\mathcal{R}$: 奖励函数, $\\mathcal { R } _ { s } = \\mathbb { E } \\left[ R _ { t + 1 } | S _ { t } = s \\right]$ $\\gamma$: 折扣因子, $\\gamma \\in [ 0,1 ]$ 回报 回报(Return) $G_t$ 是从时间 $t$ 开始的总折扣奖励. G _ { t } = R _ { t + 1 } + \\gamma R _ { t + 2 } + \\ldots = \\sum _ { k = 0 } ^ { \\infty } \\gamma ^ { k } R _ { t + k + 1 } 折扣因子 $\\gamma \\in [ 0,1 ]$ 表示未来的奖励在当前的价值. 由于未来的奖励充满不确定性, 因此需要乘上折扣因子; $\\gamma$ 接近 $0$ 表明更注重当前的奖励(myopic); $\\gamma$ 接近 $1$ 表明更具有远见(far-sighted). 值函数值函数(Value Function) $v(s)$ 表示一个状态 $s$ 的长期价值(long-term value). 一个马尔可夫奖励过程(MRP)的状态值函数 $v(s)$是从状态 $s$ 开始的期望回报. v ( s ) = \\mathbb { E } \\left[ G _ { t } | S _ { t } = s \\right] MRPs的贝尔曼方程值函数可以被分解为两部分: 立即奖励 $R_{t+1}$ 后继状态的折扣价值 $\\gamma v(S_{t+1})$ \\begin{aligned} v ( s ) & = \\mathbb { E } \\left[ G _ { t } | S _ { t } = s \\right] \\\\ & = \\mathbb { E } \\left[ R _ { t + 1 } + \\gamma R _ { t + 2 } + \\gamma ^ { 2 } R _ { t + 3 } + \\ldots | S _ { t } = s \\right] \\\\ & = \\mathbb { E } \\left[ R _ { t + 1 } + \\gamma \\left( R _ { t + 2 } + \\gamma R _ { t + 3 } + \\ldots \\right) | S _ { t } = s \\right] \\\\ & = \\mathbb { E } \\left[ R _ { t + 1 } + \\gamma G _ { t + 1 } | S _ { t } = s \\right] \\\\ & = \\mathbb { E } \\left[ R _ { t + 1 } | S _ { t } = s \\right] + \\mathbb { E } \\left[ \\gamma G _ { t + 1 } | S _ { t } = s \\right]\\\\ & = \\mathbb { E } \\left[ R _ { t + 1 } | S _ { t } = s \\right] + \\gamma v \\left( S _ { t + 1 } \\right)\\\\ & = \\mathbb { E } \\left[ R _ { t + 1 } + \\gamma v \\left( S _ { t + 1 } \\right) | S _ { t } = s \\right] \\end{aligned} \\tag{1} \\label{eq:mrp-bellman-equation}上式表明, $t$ 时刻的状态 $S_t$ 和 $t+1$ 时刻的状态 $S_{t+1}$ 的值函数之间满足递推关系. 该递推式也称为贝尔曼方程(Bellman Equation). 如果已知概率转移矩阵 $\\mathcal{P}$, 则可将公式\\eqref{eq:mrp-bellman-equation}变形为: v ( s ) = \\mathcal { R } _ { s } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { s s ^ { \\prime } } v \\left( s ^ { \\prime } \\right) \\tag{2} \\label{eq:mrp-bellman-equation-2}例子: 贝尔曼方程的矩阵形式: 可将公式\\eqref{eq:mrp-bellman-equation-2}改写为矩阵形式: v = \\mathcal { R } + \\gamma \\mathcal { P } v其中, $v$ 为一个列向量, 向量的元素为每个状态的值函数. \\left[ \\begin{array} { c } { v ( 1 ) } \\\\ { \\vdots } \\\\ { v ( n ) } \\end{array} \\right] = \\left[ \\begin{array} { c } { \\mathcal { R } _ { 1 } } \\\\ { \\vdots } \\\\ { \\mathcal { R } _ { n } } \\end{array} \\right] + \\gamma \\left[ \\begin{array} { c c c } { \\mathcal { P } _ { 11 } } & { \\ldots } & { \\mathcal { P } _ { 1 n } } \\\\ { \\vdots } & { } & { } \\\\ { \\mathcal { P } _ { n1 } } & { \\ldots } & { \\mathcal { P } _ { n n } } \\end{array} \\right] \\left[ \\begin{array} { c } { v ( 1 ) } \\\\ { \\vdots } \\\\ { v ( n ) } \\end{array} \\right]观测贝尔曼方程的矩阵形式, 可知其为线性方程, 可直接求解如下. \\begin{aligned} v & = \\mathcal { R } + \\gamma \\mathcal { P } v \\\\ ( I - \\gamma \\mathcal { P } ) v & = \\mathcal { R } \\\\ v & = ( I - \\gamma \\mathcal { P } ) ^ { - 1 } \\mathcal { R } \\end{aligned}计算复杂度为: $\\mathcal{O}(n^3)$. 因此, 只适合直接求解小规模的MRP问题. 对于大规模的MRP问题, 通常采取以下的迭代方法: 动态规划(Dynamic programming) 蒙特卡洛评估(Monte-Carlo evaluation) 时序差分学习(Temporal-Difference learning) 马尔可夫决策过程马尔可夫决策过程(Markov Decision Process, MDP)是带有决策的马尔可夫奖励过程. 马尔可夫决策过程是一个五元组&lt;$\\mathcal{S}$, $\\mathcal{A}$, $\\mathcal{P}$, $\\mathcal{R}$, $\\mathcal{\\gamma}$&gt; $\\mathcal{S}$: 有限的状态集 $\\mathcal{A}$: 有限的动作集 $\\mathcal{P}$: 状态转移概率矩阵, $\\mathcal { P } _ { s s ^ { \\prime } } ^ {a}= \\mathbb { P } \\left[ S _ { t + 1 } = s ^ { \\prime } | S _ { t } = s, A _ { t } = a \\right]$ $\\mathcal{R}$: 奖励函数, $\\mathcal { R } _ { s } ^ {a} = \\mathbb { E } \\left[ R _ { t + 1 } | S _ { t } = s, A _ { t } = a \\right]$ $\\gamma$: 折扣因子, $\\gamma \\in [ 0,1 ]$ 例子: 策略 策略(Policy) $\\pi$ 是给定状态的动作分布. \\pi ( a | s ) = \\mathbb { P } \\left[ A _ { t } = a | S _ { t } = s \\right] 策略完全决定智能体的行为; MDP策略值依赖于当前状态(无关历史); 策略是固定的(与时间无关). $A _ { t } \\sim \\pi ( \\cdot | S _ { t } ) , \\forall t &gt; 0$ 给定一个马尔可夫决策过程 $M = &lt;\\mathcal{S},\\mathcal{A}, \\mathcal{P}, \\mathcal{R}, \\mathcal{\\gamma}&gt;$ 和 一个策略 $\\pi$, 其可以转化为马尔可夫过程和马尔可夫奖励过程. 状态序列 $S_1, S_2, \\dots$ 是马尔科夫决策过程 $&lt;\\mathcal{S}, \\mathcal{P}^{\\pi}&gt;$. 状态和奖励序列 $S_1, R_2, S_2, \\dots$ 是马尔科夫奖励过程 $&lt;\\mathcal{S}, \\mathcal{P}^{\\pi}, \\mathcal{R}^{\\pi}, \\gamma&gt;$. 其中, \\mathcal{P}_{s,s'}^{\\pi} = \\sum \\limits_{a \\in \\mathcal{A}} \\pi (a | s) \\mathcal{P}_{ss'}^{a} \\mathcal{R}_{s}^{\\pi} = \\sum \\limits_{a \\in \\mathcal{A}} \\pi (a | s) \\mathcal{R}_{s}^{a} 值函数值函数(Value Function)可分为状态值函数(state-value function)和动作值函数(action-value function). MDP的状态值函数 $v_{\\pi}(s)$ 是从状态 $s$ 开始, 然后按照策略 $\\pi$ 决策所获得的期望回报. v_{\\pi}(s) = \\mathbb{E}_{\\pi} \\left[ G_t | S_t = s \\right]MDP的动作值函数 $q_{\\pi}(s, a)$ 是从状态 $s$ 开始, 采取动作 $a$, 然后按照策略 $\\pi$ 决策所获得的期望回报. q_{\\pi}(s, a) = \\mathbb{E}_{\\pi} \\left[ G_t | S_t = s, A_t = a \\right] 贝尔曼期望方程状态值函数可以被分解为两部分, 立即奖励 + 后继状态的折扣价值. v_{\\pi}(s) = \\mathbb{E}_{\\pi} \\left[ R_{t+1} + \\gamma v_{\\pi}(S_{t+1}) | S_t = s \\right]动作值函数也可以类似地分解. q_{\\pi}(s, a) = \\mathbb{E}_{\\pi} \\left[ R_{t+1} + \\gamma q_{\\pi}(S_{t+1}, A_{t+1}) | S_t = s, A_t = a \\right] 上图中, 空心圆圈代表状态, 实心圆圈代表动作. 在已知策略 $\\pi$ 的情况下, 状态值函数 $v_{\\pi}(s)$ 可以用动作值函数 $q_{\\pi}(s, a)$ 进行表示: v_{\\pi}(s) = \\sum \\limits_{a \\in \\mathcal{A}} \\pi(a | s) q_{\\pi}(s, a) \\tag{3} \\label{eq:mdp-state-value-function} 同理, 动作值函数 $q_{\\pi}(s, a)$ 也可以用状态值函数 $v_{\\pi}(s)$ 进行表示: q_{\\pi}(s, a) = \\mathcal{R}_{s}^{a} + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a}v_{\\pi}(s') \\tag{4} \\label{eq:mdp-action-value-function} 状态值函数的贝尔曼期望方程: 将公式\\eqref{eq:mdp-action-value-function}代入公式\\eqref{eq:mdp-state-value-function}中, 可得状态值函数的贝尔曼期望方程: v_{\\pi}(s) = \\sum \\limits_{a \\in \\mathcal{A}} \\pi (a | s) \\left( \\mathcal{R}_{s}^{a} + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a} v_{\\pi}(s') \\right) 动作值函数的贝尔曼期望方程: 将公式\\eqref{eq:mdp-state-value-function}代入公式\\eqref{eq:mdp-action-value-function}中, 可得动作值函数的贝尔曼期望方程: q_{\\pi}(s, a) = \\mathcal{R}_{s}^{a} + \\gamma \\sum \\limits_{s' \\in \\mathcal{S}} \\mathcal{P}_{ss'}^{a} \\sum \\limits_{a' \\in \\mathcal{A}} \\pi (a' | s') q_{\\pi}(s', a') 例子: 贝尔曼期望方程的矩阵形式: v_{\\pi} = \\mathcal{R}^{\\pi} + \\gamma \\mathcal{P}^{\\pi} v_{\\pi}可直接求解: v_{\\pi} = (I - \\gamma \\mathcal{P}^{\\pi})^{-1} \\mathcal{R}^{\\pi} 最优值函数 最优状态值函数(optimal state-value function) $v_{*}(s)$ 是所有策略中最大的值函数. v_{*}(s) = \\max \\limits_{\\pi}v_{\\pi}(s)最优动作值函数(optimal action-value function) $q_{*}(s, a)$ 是所有策略中最大的动作值函数. q_{*}(s, a) = \\max \\limits_{\\pi}q_{\\pi}(s, a) 最优值函数代表了MDP的最好性能. 当得知最优值函数时, MDP可被认为”已解决”. 例子: 例子: 注: 根据公式\\eqref{eq:mdp-state-value-function}, Pub动作的最优值应为 $q_{*} = +1 + (0.2 \\times 6 + 0.4 \\times 8 + 0.4 \\times 10) = 9.4$. 最优策略首先定义策略之间的偏序关系, 使得策略之间可以进行比较: \\pi \\geq \\pi ' \\quad \\text{if} \\quad v_{\\pi}(s) \\geq v_{\\pi '}(s) , \\forall s对于任意的MDP来说: 存在一个最优策略 $\\pi_{*}$, 使得 $\\pi_{*} \\geq \\pi, \\forall \\pi$ 所有的最优策略都能取得最优值函数 $v_{\\pi_{*}}(s) = v_{*}(s)$ 所有的最优策略都能取得最优动作值函数 $q_{\\pi_{*}}(s, a) = q_{*}(s, a)$ 寻找最优策略 一个最优策略可以通过最大化所有的 $q_{*}(s, a)$ 得到: \\pi_{*} \\left( a | s \\right) = \\left \\{ \\begin{array}{ll} 1 \\ {\\mathbb {if}} \\ a = \\operatorname*{argmax} \\limits_{a \\in \\mathcal{A}} \\ q_{*} \\left( s,a \\right) \\\\ 0 \\ {\\mathbb {otherwise}} \\end{array} \\right. 对于任意的MDP, 总存在确定的最优策略 如果我们知道 $q_{*}(s, a)$, 则可以立即得到最优策略 例子: 图中红色弧线表示每个状态的最优决策. 贝尔曼最优方程$v_{*}$可以通过贝尔曼最优方程递归得到: v_{*}(s) = \\max \\limits_{a} q_{*}(s, a) \\tag{5} \\label{eq:state-bellman-optimal-equation}与公式\\eqref{eq:mdp-state-value-function}的贝尔曼期望方程进行比较, 此时不再取均值, 而是取最大值. $q_{*}$与公式\\eqref{eq:mdp-action-value-function}类似: q _ { * } ( s , a ) = \\mathcal { R } _ { s } ^ { a } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { s s ^ { \\prime } } ^ { a } v _ { * } \\left( s ^ { \\prime } \\right) \\tag{6} \\label{eq:action-bellman-optimal-equation} 状态值函数的贝尔曼最优方程 将公式\\eqref{eq:action-bellman-optimal-equation}代入公式\\eqref{eq:state-bellman-optimal-equation}可得 $v_{*}$ 的贝尔曼最优方程: v _ { * } ( s ) = \\max _ { a } \\mathcal { R } _ { s } ^ { a } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { s s ^ { \\prime } } ^ { a } v _ { * } \\left( s ^ { \\prime } \\right) 动作值函数的贝尔曼最优方程 将公式\\eqref{eq:state-bellman-optimal-equation}代入公式\\eqref{eq:action-bellman-optimal-equation}可得 $q_{*}$ 的贝尔曼最优方程: q _ { * } ( s , a ) = \\mathcal { R } _ { s } ^ { a } + \\gamma \\sum _ { s ^ { \\prime } \\in \\mathcal { S } } \\mathcal { P } _ { s s ^ { \\prime } } ^ { a } \\max _ { a ^ { \\prime } } q _ { * } \\left( s ^ { \\prime } , a ^ { \\prime } \\right) 例子: 贝尔曼最优方程的求解贝尔曼最优方程不是线性的(因为有取$max$操作), 因此没有封闭解(Closed-form solution). 通常采用迭代求解方法: 值迭代(Value Iteration) 策略迭代(Policy Iteration) Q-Learning Sarsa MDP的扩展 无穷和连续的MDPs 部分可观测的MDPs 不折扣, 平均奖励MDPs 参考资料 Reinforcement learning: An introduction (second edition) 第三章 UCL Course on RL Lecture2: Markov Decision Processes","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/categories/强化学习/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/tags/强化学习/"},{"name":"马尔可夫决策过程","slug":"马尔可夫决策过程","permalink":"https://orzyt.cn/tags/马尔可夫决策过程/"}]},{"title":"强化学习（一）：强化学习简介","slug":"introduction-to-rl","date":"2019-02-25T14:56:13.000Z","updated":"2019-03-13T12:07:23.473Z","comments":true,"path":"posts/introduction-to-rl/","link":"","permalink":"https://orzyt.cn/posts/introduction-to-rl/","excerpt":"本文主要介绍强化学习中的一些基本概念.","text":"本文主要介绍强化学习中的一些基本概念. 强化学习的特征作为机器学习的一个分支，强化学习主要的特征为: 无监督,仅有奖励信号； 反馈有延迟,不是瞬时的; 时间是重要的(由于是时序数据,不是独立同分布的); Agent的动作会影响后续得到的数据; 强化学习的概念奖励奖励(Rewards) $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何. Agent的目标: 最大化累积奖励(maximise cumulative reward). 强化学习基于奖励假设(reward hypothesis). 奖励假设(Reward Hypothesis):所有强化学习任务的目标都可以被描述为最大化期望累积奖励. 序贯决策序贯决策(Sequential Decision Making)的目标: 选择合适的动作最大化将来的累积奖励. 动作可能会产生长期后果； 奖励会有延迟性; 牺牲立即回报可能会获得更多的长期回报. 智能体和环境 智能体(Agent)在每个时刻$t$会: 执行动作(Action)$A_t$; 接收观测(Observation)$O_t$; 接收标量奖励(Reward)$R_t$. 而环境(Environment)则会: 接收动作(Action)$A_t$; 产生观测(Observation)$O_{t+1}$; 产生标量奖励(Reward)$R_{t+1}$. 历史与状态 历史(History):由一系列观测,动作和奖励构成. H_t = O_1, R_1, A_1, \\dots, A_{t-1}, O_t, R_t下一步将发生什么取决于历史: 智能体选择的action; 环境选择的observations/rewards. 状态(State):用来决定接下来会发生什么的信息. 状态是历史的函数: S_t = f(H_t) 环境状态 环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见. 即使$S_{t}^{e}$可见,也可能包含不相关信息. 智能体状态 智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息. 可以写成历史的函数: $S_{t}^{a} = f(H_t)$ 信息状态信息状态(也称为马尔科夫状态): 包含历史中所有有用的信息. 马尔科夫状态表明: 未来只与现在有关,而与过去无关. 其中,环境状态$S_t^e$和历史$H_t$具有马尔科夫性质. Rat Example 假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击) 假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪) 假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知) 完全可观测环境完全可观测性(Full observability): 智能体可以直接观测到环境状态,即 O_t = S_t^a = S_t^e 智能体状态 = 环境状态 = 信息状态 实际上是马尔科夫决策过程(Markov Decision Process, MDP) 部分可观测环境部分可观测性(Partial observability): 智能体不能够直接观测到环境. 如,机器人不能通过摄像头得知自身的绝对位置. 智能体状态 $\\neq$ 环境状态 部分可观测马尔科夫决策过程(POMDP) 此时,智能体必须构建其自身的状态表示 $S_t^a$,比如: 完全的历史: $S_t^a = H_t$; 环境状态的置信度: $S _ { t } ^ { a } = \\left( \\mathbb { P } \\left[ S _ { t } ^ { e } = s ^ { 1 } \\right] , \\ldots , \\mathbb { P } \\left[ S _ { t } ^ { e } = s ^ { n } \\right] \\right)$; 循环神经网络: $S_t^a = \\sigma \\left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\\right)$ 智能体的构成智能体主要包含以下几种成分: 策略(Policy): 智能体的行为函数; 值函数(Value Function): 每个state或action的好坏; 模型(Model): 智能体对环境的表示. 策略 策略(Policy)是智能体的行为; 是状态到动作的映射; 确定性策略: $a = \\pi(s)$; 随机性策略: $\\pi(a|s) = \\mathbb{P} \\left[ A_{t} = a | S_{t} = s\\right]$ 值函数值函数(Value Function)是对于未来奖励的预测. 用于评价状态的好坏; 因此可以用来选择动作. v_{\\pi}(s) = \\mathbb{E}_{\\pi} \\left[ R_{t+1} + \\gamma R_{t+2} + \\gamma^2 R_{t+3} + \\dots | S_{t} = s \\right] 模型模型(Model)用来预测环境接下来会做什么. $\\mathcal{P}$: 预测下一个状态. \\mathcal{P}_{ss'}^{a} = \\mathbb{P} \\left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\\right] $\\mathcal{R}$: 预测下一个(立即)奖励. \\mathcal{R}_{s}^{a} = \\mathbb{E} \\left[ R_{t+1} | S_{t} = s, A_{t} = a\\right] Maze Example 策略表示: 箭头表示每个状态的策略 $\\pi(s)$. 值函数表示: 数值表示每个状态的值 $v_{\\pi}(s)$. 模型表示: 智能体可能对环境建立内部模型 网格布局表示转移模型 $\\mathcal{P}_{ss’}^{a}$; 数值表示每个状态的立即奖励 $\\mathcal{R}_{s}^{a}$. 智能体的分类按智能体的成分分类: 基于值函数(Value Based) 基于策略(Policy Based) 演员-评论家(Actor Critic) 或者按有无模型分类: 无模型(Model Free) 基于模型(Model Based) 强化学习的问题学习与规划强化学习 环境的初始状态未知; 智能体与环境进行交互; 智能体提升其策略. 规划 环境的模型已知; 智能体通过模型进行计算,无须与外部进行交互; 智能体提升其策略 探索和利用强化学习是一种试错(trial-and-error)学习. 智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励. 探索(Exploration): 从环境中寻找更多信息; 利用(Exploitation): 利用已知信息使奖励最大化. 探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果. 预测和控制 预测(Prediction): 对未来进行评估. 控制(Control): 最优化未来的结果. 参考资料 Reinforcement learning: An introduction (second edition) 第一章 UCL Course on RL Lecture1: Introduction to Reinforcement Learning","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/categories/强化学习/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://orzyt.cn/tags/强化学习/"}]},{"title":"LeetCode637 Average of Levels in Binary Tree","slug":"leetcode637-average-of-levels-in-binary-tree","date":"2019-02-08T09:23:30.000Z","updated":"2019-02-08T10:25:59.974Z","comments":true,"path":"posts/leetcode637-average-of-levels-in-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/","excerpt":"","text":"题目 LeetCode637 Average of Levels in Binary Tree 思路二叉树的层次遍历,使用空指针作为每层的分界. 代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; que.push(root); que.push(nullptr); double sum = 0, cnt = 0; vector&lt;double&gt; ret; while (!que.empty()) &#123; TreeNode* u = que.front(); que.pop(); if (u == nullptr) &#123; ret.push_back(sum / cnt); sum = cnt = 0; if (!que.empty()) que.push(nullptr); &#125; else &#123; sum += u-&gt;val; cnt++; if (u-&gt;left) que.push(u-&gt;left); if (u-&gt;right) que.push(u-&gt;right); &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode654 Maximum Binary Tree","slug":"leetcode654-maximum-binary-tree","date":"2019-02-08T09:23:30.000Z","updated":"2019-02-08T10:25:59.990Z","comments":true,"path":"posts/leetcode654-maximum-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode654-maximum-binary-tree/","excerpt":"","text":"题目 LeetCode654 Maximum Binary Tree 思路递归构造二叉搜索树,树的左右儿子都比父结点小. 代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* helper(vector&lt;int&gt;&amp; nums, int l, int r) &#123; TreeNode* node = new TreeNode(0); int num = nums[l], id = l; for (int i = l; i &lt;= r; ++i) &#123; if (num &lt; nums[i]) &#123; num = nums[i]; id = i; &#125; &#125; node-&gt;val = num; if (l &lt;= id - 1) node-&gt;left = helper(nums, l, id - 1); if (id + 1 &lt;= r) node-&gt;right = helper(nums, id + 1, r); return node; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; return helper(nums, 0, nums.size() - 1); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode657 Robot Return to Origin","slug":"leetcode657-robot-return-to-origin","date":"2019-02-08T09:23:30.000Z","updated":"2019-02-08T10:25:59.974Z","comments":true,"path":"posts/leetcode657-robot-return-to-origin/","link":"","permalink":"https://orzyt.cn/posts/leetcode657-robot-return-to-origin/","excerpt":"","text":"题目 LeetCode657 Robot Return to Origin 思路判断上和下,左和右的次数是否相同即可. 代码12345678class Solution &#123;public: bool judgeCircle(string moves) &#123; unordered_map&lt;char, int&gt; f; for (auto&amp; c: moves) f[c]++; return f['U'] == f['D'] &amp;&amp; f['L'] == f['R']; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode661 Image Smoother","slug":"leetcode661-image-smoother","date":"2019-02-08T09:23:30.000Z","updated":"2019-02-08T10:25:59.958Z","comments":true,"path":"posts/leetcode661-image-smoother/","link":"","permalink":"https://orzyt.cn/posts/leetcode661-image-smoother/","excerpt":"","text":"题目 LeetCode661 Image Smoother 思路按题意模拟即可. 代码12345678910111213141516171819202122class Solution &#123;public: const int dx[9] = &#123;-1, -1, -1, 0, 0, 0, 1, 1, 1&#125;; const int dy[9] = &#123;-1, 0, 1, -1, 0, 1, -1, 0, 1&#125;; vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n = M.size(), m = M[0].size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;()); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int sum = 0, cnt = 0; for (int k = 0; k &lt; 9; ++k) &#123; int x = i + dx[k], y = j + dy[k]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue; sum += M[x][y]; cnt++; &#125; ret[i].push_back(sum / cnt); &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode665 Non-decreasing Array","slug":"leetcode665-non-decreasing-array","date":"2019-02-08T09:23:30.000Z","updated":"2019-02-08T10:25:59.950Z","comments":true,"path":"posts/leetcode665-non-decreasing-array/","link":"","permalink":"https://orzyt.cn/posts/leetcode665-non-decreasing-array/","excerpt":"","text":"题目 LeetCode665 Non-decreasing Array 思路判断只修改一个数能否使得数组非递减. 首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$. 可行的情况有: $ r \\leq l $ $r == l + 1$ 且 满足下列情况之一 r 为最后一位 l位置的值 $ \\leq $ r + 1位置的值 l为首位 l-1位置的值 $ \\leq $ r 位置的值 代码123456789class Solution &#123;public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int siz = nums.size(), l = 0, r = siz - 1; while (l + 1 &lt; siz &amp;&amp; nums[l] &lt;= nums[l + 1]) l++; while (r &gt; 0 &amp;&amp; nums[r - 1] &lt;= nums[r]) r--; return r &lt;= l || (r == l + 1 &amp;&amp; ((nums[l] &lt;= nums[r + 1] || r == siz - 1) || (l == 0 || nums[l - 1] &lt;= nums[r]))); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode617 Merge Two Binary Trees","slug":"leetcode617-merge-two-binary-trees","date":"2019-02-08T09:02:05.000Z","updated":"2019-02-08T10:25:59.958Z","comments":true,"path":"posts/leetcode617-merge-two-binary-trees/","link":"","permalink":"https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/","excerpt":"","text":"题目 LeetCode617 Merge Two Binary Trees 思路二叉树的合并. 代码1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if (t1 &amp;&amp; t2) &#123; t1-&gt;val += t2-&gt;val; t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return t1; &#125; else return t1 ? t1 : t2; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode606 Construct String from Binary Tree","slug":"leetcode606-construct-string-from-binary-tree","date":"2019-02-08T09:01:50.000Z","updated":"2019-02-08T10:25:59.958Z","comments":true,"path":"posts/leetcode606-construct-string-from-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/","excerpt":"","text":"题目 LeetCode606 Construct String from Binary Tree 思路二叉树的简单遍历. 代码12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: string dfs(TreeNode* t) &#123; if (t == NULL) return \"\"; if (t-&gt;left == NULL &amp;&amp; t-&gt;right == NULL) return to_string(t-&gt;val); string ret = to_string(t-&gt;val) + \"(\" + dfs(t-&gt;left) + \")\"; if (t-&gt;right) ret += \"(\" + dfs(t-&gt;right) + \")\"; return ret; &#125; string tree2str(TreeNode* t) &#123; return dfs(t); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode599 Minimum Index Sum of Two Lists","slug":"leetcode599-minimum-index-sum-of-two-lists","date":"2019-02-08T09:01:34.000Z","updated":"2019-02-08T10:25:59.950Z","comments":true,"path":"posts/leetcode599-minimum-index-sum-of-two-lists/","link":"","permalink":"https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/","excerpt":"","text":"题目 LeetCode599 Minimum Index Sum of Two Lists 思路找出交集中下标和最小值. 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) &#123; vector&lt;string&gt; ans; int n = list1.size(), m = list2.size(); unordered_map&lt;string, int&gt; hs; for (int i = 0; i &lt; n; ++i) hs[list1[i]] = i; int minSum = INT_MAX; for (int i = 0; i &lt; m; ++i) &#123; if (hs.count(list2[i])) &#123; int j = hs[list2[i]]; if (i + j &lt; minSum) &#123; minSum = i + j; ans.clear(); ans.push_back(list2[i]); &#125; else if (i + j == minSum) &#123; ans.push_back(list2[i]); &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode38 Count and Say","slug":"leetcode38-count-and-say","date":"2019-02-08T09:00:37.000Z","updated":"2019-02-08T10:25:59.942Z","comments":true,"path":"posts/leetcode38-count-and-say/","link":"","permalink":"https://orzyt.cn/posts/leetcode38-count-and-say/","excerpt":"","text":"题目 LeetCode38 Count and Say 思路按照规则模拟即可. 代码1234567891011121314151617181920class Solution &#123;public: string countAndSay(int n) &#123; string s = \"1\", ans = s; while (--n) &#123; ans.clear(); int len = s.size(); for (int i = 0; i &lt; len; ++i) &#123; int count = 1; while (s[i] == s[i + 1] &amp;&amp; i + 1 &lt; len) &#123; count++; i++; &#125; ans += to_string(count) + s[i]; &#125; s = ans; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"【论文笔记】深度人脸识别综述","slug":"deep-face-recognition","date":"2019-01-22T06:04:24.000Z","updated":"2019-03-22T09:01:15.809Z","comments":true,"path":"posts/deep-face-recognition/","link":"","permalink":"https://orzyt.cn/posts/deep-face-recognition/","excerpt":"论文题目：《Deep Face Recognition: A Survey》 论文作者：Mei Wang, Weihong Deng 论文链接：http://cn.arxiv.org/pdf/1804.06655.pdf","text":"论文题目：《Deep Face Recognition: A Survey》 论文作者：Mei Wang, Weihong Deng 论文链接：http://cn.arxiv.org/pdf/1804.06655.pdf 随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace1首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。 概念和术语人脸系统一般包括三个部分： 人脸检测（face detection）：对于一幅图像，检测其中人脸的位置； 人脸对齐（face alignment）：根据人脸关键点，将人脸对齐到一个典型的角度； 人脸识别（face recognition）：包括人脸处理、人脸表示和人脸匹配部分。 训练集（training set）：用于训练系统的人脸集； 注册集（gallery set）：提前注册在系统中用于比对的标准人脸集； 测试集（probe set）：用于测试的人脸集。 人脸识别任务主要包括： 人脸认证（face identification）：为1:N的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为闭集（closed-set）和开集（open-set）问题。 人脸验证（face verification）：为1:1的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。 网络结构主流结构在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。 在2014年，DeepFace1首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet9在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface10从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace11使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace212作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。 AlexNet2：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术； VGGNet3：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层； GoogLeNet4：提出了inception module，对不同尺度的特征图进行混合； ResNet5：通过学习残差表示，使得训练更深网络成为可能； SENet6：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。 特殊结构 Light CNN7 bilinear CNN8 … 损失函数在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。 基于欧几里德距离 contrastive loss相关文献： 《Deep learning face representation by joint identification-verification》 《Deepid3: Face recognition with very deep neural networks》 DeepID系列使用的loss。 \\operatorname { Verif } \\left( f _ { i } , f _ { j } , y _ { i j } , \\theta _ { v e } \\right) = \\left\\{ \\begin{array} { l l } { \\frac { 1 } { 2 } \\left\\| f _ { i } - f _ { j } \\right\\| _ { 2 } ^ { 2 } } & { \\text { if } y _ { i j } = 1 } \\\\ { \\frac { 1 } { 2 } \\max \\left( 0 , m - \\left\\| f _ { i } - f _ { j } \\right\\| _ { 2 } \\right) ^ { 2 } } & { \\text { if } y _ { i j } = - 1 } \\end{array} \\right. triplet loss相关文献： 《Facenet: A unified embedding for face recognition and clustering》 \\mathcal{L} = \\sum _ { i } ^ { N } \\left[ \\left\\| f \\left( x _ { i } ^ { a } \\right) - f \\left( x _ { i } ^ { p } \\right) \\right\\| _ { 2 } ^ { 2 } - \\left\\| f \\left( x _ { i } ^ { a } \\right) - f \\left( x _ { i } ^ { n } \\right) \\right\\| _ { 2 } ^ { 2 } + \\alpha \\right] _ { + } center loss相关文献： 《A Discriminative Feature Learning Approach for Deep Face Recognition》 \\begin{aligned} \\mathcal { L } & = \\mathcal { L } _ { S } + \\lambda \\mathcal { L } _ { C } \\\\ & = - \\sum _ { i = 1 } ^ { m } \\log \\frac { e ^ { W _ { y _ { i } } ^ { T } \\boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \\sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \\boldsymbol { x } _ { i } + b _ { j } } } + \\frac { \\lambda } { 2 } \\sum _ { i = 1 } ^ { m } \\left\\| \\boldsymbol { x } _ { i } - \\boldsymbol { c } _ { y _ { i } } \\right\\| _ { 2 } ^ { 2 } \\end{aligned} range loss相关文献： 《Range loss for deep face recognition with long-tail》 \\mathcal { L } _ { R } = \\alpha \\mathcal { L } _ { R _ { i n t r a } } + \\beta \\mathcal { L } _ { R _ { i n t e r } } \\mathcal { L } _ { R _ { i n t r a } } = \\sum _ { i \\subseteq I } \\mathcal { L } _ { R _ { i n t r a }}^ { i } = \\sum _ { i \\subseteq I } \\frac { k } { \\sum _ { j = 1 } ^ { k } \\frac { 1 } { \\mathcal { D } _ { j } } } \\begin{aligned} \\mathcal { L } _ { R _ { \\text {inter} } } & = \\max \\left( m - \\mathcal { D } _ { C e n t e r } , 0 \\right) \\\\ & = \\max \\left( m - \\left\\| \\overline { x } _ { \\mathcal { Q } } - \\overline { x } _ { \\mathcal { R } } \\right\\| _ { 2 } ^ { 2 } , 0 \\right) \\end{aligned} \\mathcal { L } = \\mathcal { L } _ { M } + \\lambda \\mathcal { L } _ { R } = - \\sum _ { i = 1 } ^ { M } \\log \\frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \\sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \\lambda \\mathcal { L } _ { R } center-invariant loss相关文献： 《Deep face recognition with center invariant loss》 \\begin{aligned} L = & L _ { s } + \\gamma L _ { I } + \\lambda L _ { c } \\\\ = & - \\log \\left( \\frac { e ^ { \\mathbf { w } _ { y } ^ { T } \\mathbf { x } _ { i } + b _ { y } } } { \\sum _ { j = 1 } ^ { m } e ^ { \\mathbf { w } _ { j } ^ { T } \\mathbf { x } _ { i } + b _ { j } } } \\right) + \\frac { \\gamma } { 4 } \\left( \\left\\| \\mathbf { c } _ { y } \\right\\| _ { 2 } ^ { 2 } - \\frac { 1 } { m } \\sum _ { k = 1 } ^ { m } \\left\\| \\mathbf { c } _ { k } \\right\\| _ { 2 } ^ { 2 } \\right) ^ { 2 } \\\\ & + \\frac { \\lambda } { 2 } \\left\\| \\mathbf { x } _ { i } - \\mathbf { c } _ { y } \\right\\| ^ { 2 } \\end{aligned} 基于角度/余弦间隔 L-Softmax loss相关文献： 《Large-margin softmax loss for convolutional neural networks》 L _ { i } = - \\log \\left( \\frac { e ^ { \\left\\| \\boldsymbol { W } _ { y _ { i } } \\right\\| \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\psi \\left( \\theta _ { y _ { i } } \\right) } } { e ^ { \\left\\| \\boldsymbol { W } _ { y _ { i } } \\right\\| \\boldsymbol { w } \\left( \\theta _ { \\boldsymbol { y } _ { i } } \\right) } + \\sum _ { j \\neq y _ { i } } e ^ { \\left\\| \\boldsymbol { W } _ { j } \\right\\| \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\cos \\left( \\theta _ { j } \\right) } } \\right) \\psi ( \\theta ) = ( - 1 ) ^ { k } \\cos ( m \\theta ) - 2 k , \\quad \\theta \\in \\left[ \\frac { k \\pi } { m } , \\frac { ( k + 1 ) \\pi } { m } \\right] f _ { y _ { i } } = \\frac { \\lambda \\left\\| \\boldsymbol { W } _ { y _ { i } } \\right\\| \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\cos \\left( \\theta _ { y _ { i } } \\right) + \\left\\| \\boldsymbol { W } _ { y _ { i } } \\right\\| \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\psi \\left( \\theta _ { \\boldsymbol { y } _ { i } } \\right) } { 1 + \\lambda } A-Softmax loss相关文献： 《Sphereface: Deep hypersphere embedding for face recognition》 L _ { \\mathrm { ang } } = \\frac { 1 } { N } \\sum _ { i } - \\log \\left( \\frac { e ^ { \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\psi \\left( \\theta _ { y _ { i } , i } \\right) } } { e ^ { \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\psi \\left( \\theta _ { y _ { i } } , i \\right) } + \\sum _ { j \\neq y _ { i } } e ^ { \\left\\| \\boldsymbol { x } _ { i } \\right\\| \\cos \\left( \\theta _ { j , i } \\right) } } \\right) \\psi \\left( \\theta _ { y _ { i } , i } \\right) = ( - 1 ) ^ { k } \\cos \\left( m \\theta _ { y _ { i } , i } \\right) - 2 k \\theta _ { y _ { i } , i } \\in \\left[ \\frac { k \\pi } { m } , \\frac { ( k + 1 ) \\pi } { m } \\right] \\text { and } k \\in [ 0 , m - 1 ] AM-Softmax loss相关文献： 《Additive margin softmax for face verification》 \\begin{aligned} \\mathcal { L } _ { A M S } & = - \\frac { 1 } { n } \\sum _ { i = 1 } ^ { n } \\log \\frac { e ^ { s \\cdot \\left( \\cos \\theta _ { y _ { i } } - m \\right) } } { e ^ { s \\cdot \\left( \\cos \\theta _ { y _ { i } } - m \\right) } + \\sum _ { j = 1 , j \\neq y _ { i } } ^ { c } e ^ { s \\cdot c o s \\theta _ { j } } } \\\\ & = - \\frac { 1 } { n } \\sum _ { i = 1 } ^ { n } \\log \\frac { e ^ { s \\cdot \\left( W _ { y _ { i } } ^ { T } f _ { i } - m \\right) } } { e ^ { s \\cdot \\left( W _ { y _ { i } } ^ { T } \\boldsymbol { f } _ { i } - m \\right) } + \\sum _ { j = 1 , j \\neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \\boldsymbol { f } _ { i } } } \\end{aligned} CosFace相关文献： 《Cosface: Large margin cosine loss for deep face recognition》 L _ { l m c } = \\frac { 1 } { N } \\sum _ { i } - \\log \\frac { e ^ { s \\left( \\cos \\left( \\theta _ { y _ { i } , i } \\right) - m \\right) } } { e ^ { s \\left( \\cos \\left( \\theta _ { y _ { i } } , i \\right) - m \\right) } + \\sum _ { j \\neq y _ { i } } e ^ { s \\cos \\left( \\theta _ { j , i } \\right) } } \\begin{aligned} \\text { subject to } \\\\ W & = \\frac { W ^ { * } } { \\left\\| W ^ { * } \\right\\| } \\\\ x & = \\frac { x ^ { * } } { \\left\\| x ^ { * } \\right\\| } \\\\ \\cos \\left( \\theta _ { j } , i \\right) & = W _ { j } ^ { T } x _ { i } \\end{aligned} ArcFace相关文献： 《Arcface: Additive angular margin loss for deep face recognition》 L = - \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } \\log \\frac { e ^ { s \\left( \\cos \\left( \\theta _ { y _ { i } } + m \\right) \\right) } } { e ^ { s \\left( \\cos \\left( \\theta _ { y _ { i } } + m \\right) \\right) } + \\sum _ { j = 1 , j \\neq y _ { i } } ^ { n } e ^ { s \\cos \\theta _ { j } } } Softmax及其变种 L2-Softmax相关文献： 《L2-constrained softmax loss for discriminative face verification》 \\begin{array} { l l } { \\text { minimize } } & { - \\frac { 1 } { M } \\sum _ { i = 1 } ^ { M } \\log \\frac { e ^ { W _ { y _ { i } } ^ { T } f \\left( \\mathbf { x } _ { i } \\right) + b _ { y _ { i } } } } { \\sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \\left( \\mathbf { x } _ { i } \\right) + b _ { j } } } } \\\\ { \\text { subject to } } & { \\left\\| f \\left( \\mathbf { x } _ { i } \\right) \\right\\| _ { 2 } = \\alpha , \\forall i = 1,2 , \\ldots M } \\end{array} Normface相关文献： 《NormFace: L2 Hypersphere Embedding for Face Verification》 \\mathcal { L } _ { S' } = - \\frac { 1 } { m } \\sum _ { i = 1 } ^ { m } \\log \\frac { e ^ { s \\tilde { W } _ { y _ { i } } ^ { T } \\tilde { \\mathbf { f } } _ { i } } } { \\sum _ { j = 1 } ^ { n } e ^ { s \\tilde { W } _ { j } ^ { T } \\mathbf { f } _ { i } } } \\tilde { \\mathbf { x } } = \\frac { \\mathbf { x } } { \\| \\mathbf { x } \\| _ { 2 } } = \\frac { \\mathbf { x } } { \\sqrt { \\sum _ { i } \\mathbf { x } _ { i } ^ { 2 } + \\epsilon } } CoCo loss相关文献： 《Rethinking feature discrimination and polymerization for large-scale recognition》 \\mathcal { L } ^ { C O C O } \\left( \\boldsymbol { f } ^ { ( i ) } , \\boldsymbol { c } _ { k } \\right) = - \\sum _ { i \\in \\mathcal { B } , k } t _ { k } ^ { ( i ) } \\log p _ { k } ^ { ( i ) } = - \\sum _ { i \\in \\mathcal { B } } \\log p _ { l _ { i } } ^ { ( i ) } \\hat { \\boldsymbol { c } } _ { k } = \\frac { \\boldsymbol { c } _ { k } } { \\left\\| \\boldsymbol { c } _ { k } \\right\\| } , \\hat { \\boldsymbol { f } } ^ { ( i ) } = \\frac { \\alpha \\boldsymbol { f } ^ { ( i ) } } { \\left\\| \\boldsymbol { f } ^ { ( i ) } \\right\\| } , p _ { k } ^ { ( i ) } = \\frac { \\exp \\left( \\hat { \\boldsymbol { c } } _ { k } ^ { T } \\cdot \\hat { \\boldsymbol { f } } ^ { ( i ) } \\right) } { \\sum _ { m } \\exp \\left( \\hat { \\boldsymbol { c } } _ { m } ^ { T } \\cdot \\hat { \\boldsymbol { f } } ^ { ( i ) } \\right) } Ring loss相关文献： 《Ring loss: Convex feature normalization for face recognition》 L _ { R } = \\frac { \\lambda } { 2 m } \\sum _ { i = 1 } ^ { m } \\left( \\left\\| \\mathcal { F } \\left( \\mathbf { x } _ { i } \\right) \\right\\| _ { 2 } - R \\right) ^ { 2 } 参考文献 1. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. Deepface: Closing the gap to human-level performance in face verification. In CVPR, pages 1701–1708, 2014. &#8617; 2. A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In NIPS, pages 1097–1105, 2012. &#8617; 3. K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014. &#8617; 4. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. Going deeper with convolutions. In CVPR, 2015. &#8617; 5. K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. In CVPR, pages 770–778, 2016. &#8617; 6. J. Hu, L. Shen, and G. Sun. Squeeze-and-excitation networks. arXiv preprint arXiv:1709.01507, 2017. &#8617; 7. X. Wu, R. He, Z. Sun, and T. Tan. A light cnn for deep face representation with noisy labels. arXiv preprint arXiv:1511.02683, 2015. &#8617; 8. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. One-to-many face recognition with bilinear cnns. In WACV, pages 1–9. IEEE, 2016. &#8617; 9. F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A unified embedding for face recognition and clustering. In CVPR, pages 815–823, 2015. &#8617; 10. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. Deep face recognition. In BMVC, volume 1, page 6, 2015. &#8617; 11. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. Sphereface: Deep hypersphere embedding for face recognition. In CVPR, volume 1, 2017. &#8617; 12. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. Vggface2: A dataset for recognising faces across pose and age. arXiv preprint arXiv:1710.08092, 2017. &#8617;","categories":[{"name":"论文笔记","slug":"论文笔记","permalink":"https://orzyt.cn/categories/论文笔记/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://orzyt.cn/tags/深度学习/"},{"name":"人脸识别","slug":"人脸识别","permalink":"https://orzyt.cn/tags/人脸识别/"}]},{"title":"2018-2019学年研一上学期总结","slug":"2018-2019-fall-semester-summary","date":"2019-01-21T05:43:42.000Z","updated":"2019-01-22T06:49:10.651Z","comments":true,"path":"posts/2018-2019-fall-semester-summary/","link":"","permalink":"https://orzyt.cn/posts/2018-2019-fall-semester-summary/","excerpt":"本文暂未公开，请输入密码访问","text":"本文暂未公开，请输入密码访问 ∑(っ°Д°;)っ 密码错误！ No content to display! U2FsdGVkX1+5B0fhv81NFdvPM1sPb6IKK1J/34EzgPgjX1SZBlGUFiGcFVvVIrIWM+Mr/i/vf6TCJFcwFxl9SvN1BNRLImw8goxmULvjVJCznWNePw+3JoeGONmD1ukSMv2wDTYOa/KKCD7u+Q9+7myGAZEpwgEp53jq7d9p4TSj7oDzm22erfW/hyL5yQ8/sUz5AXMIPN4DMZ9ZlQTGPLS9ryMIN0gmiLPdZSMvtw5XyxXdR65XHs1mZ3wGP1NQyiQAnx+JCe57RzwsjGsboVZIL6cJ/uZJ4TL4idp2Q03Xdaht/cjLT8Cfz+la2dRtIAaNy35H+KHxUAKS5VMdkQRRZUFWHY0Mi/qSVtNsgU+kCisyyNOdawct0mte9TwbSmg/FSdgQk/Ttk4BlhJ/RVF69yo45Zh2d9RxczevTsFM7VCntpP7xVo0BkM2OlvrXX18GhQPFfYb/OvZ9aRZMGraAO843T/ap8FxqfYgoCUbbWlBfCm8O5A7711Fd8aXmoQRsYUMZG4ySCEV4GbiOGjh11pmr+5oOTi2DEvClMmhd38Ad0AGjh3A49w18iIXEw+WByuLaqw4dmGxiYOd7ZbcKgcbXFr3rNGWd1GA3SWrgLQoDOl9YsH/86Fdj/BB4tRIDKcp6PEU+SaaWw1bbe8gJxmZgC3jbJxHUf1FDR/JqXZ3CSx5Vocojp1inwk6nPOXZ2+7dwd4CjGZLp2Ow8YUVaj3uKK9L8yrnA5w89PLbnBcPwfhACjxtKY765/67VQIkpAHo1zKZUty8cSn5W6GC2x97tHontGQmFluyDEfzZ+09qDKtyQSApF+vSFzZNGOfYc/wdQeQeimI76mLGzZygD3K4eBKxCGY0aWhxN0AkjsqBAbzyk/qTc1lu+TAj+1zD3xZtMYRPZecIHgrYhgEtwxCR8miuNc/C11JJAhPahsWGzLvQ8nGhr3y5ym8TY6FXx0Yka7xwYMkH+nNpB+Vuaw/BlUJpjz4obFbG+ahQ2ZCB0hsVqepxUcyKweBrk3aBKS5NqcFeFxblg1eGM8tdblIBiF2w9T3TW3T+gDTNFy/VtiXB4Z+Pys0RgXfajltpaD9TdW7btFjA8C+VDv+t9NVOS0G0+jWApHzAZqTv+xUAwGO1JGZc+DzgjNQnD6pETo1uSYsqtzfwVu5/j81iB4FmdUbsOH92D7QvmByq3ImrUzp+cdly8W2oQGD/9FaZYcJHoOtYYyPJndzB8Bi3bDLxlpKy/tYq4lgfEvCzngwC3mZI1i/r1jkK19dwl9hj0Ra/MR3pFDIJBXkCzNsXPhs8/FGfog/frW/s+V/zlG9RglJW5q20SuNljlFmsGqoBD7AqaVrERfWYllrrbh8qXyc2Jgu1ygqIzIPtrJe2SpHTc6ySnpj7+lM+Uy/QcJpBuUOhbCnsXK+82fFRXhNv/YSxQhJ7SWtD5+2c0pHH0TsQTT69f6DwflWDmjqVZfWmZygiNpb7/DnRPhgrHQKA6WKTQiX3hsBx7r8gG75qbJhKIBOdO0I/X4vtCg+b0DznW1qTW0p9tP9rabqHChSI47ZdshLqT2nmKA361RM7SSMtKMrE0aFkAGvsJWC9mPiDs86+vQJexrpnH2cQpiV80XejzrGYVGzSUPyzgvOPqHTEieIPeyn985PCEVbGIMzYG/xJvp9moTnPMMdPwVCpsCi/cifHCUKZvYMCes96gnuak9tD1Fty5NaAsNaZ0VvlBWGiYMNilp7CSkrGixdF99knEwbeFAUniMQE7qNKfEuOvn9lcWv9YBeas/o/G0CTPSwJHxfIg+1aCuxauReW0ucIR9quvQD8DFLb3vAPgQoZYSVXR4bj0wCICcP34T/7mBMpHW+yzft/aeu0cHuk/KDkOSx3tPuHY+931DnKSKbqu6yzRLYD0c4mDdaFVn8a1r09Cybr/oDIwshUdvjtMQlb5w63ow1b9oP1SAF+x5Hn/wl3kM1Bdxkgk8WHFRPZK4fSWlQxf1s9TD3P67LhbyfIxz3KwADAAirMwtkKvqKDSPtqirxmUuVgvlWofPpLtqHpzeEImf+tis0J+jnHE1A9i1hSPqWI7RO5uk72WAUcyVI5diFcPg+o2rgyVuZsuB00wIzZaJKd5NS7zq/sYmDJbNnpe/Xg49o5mGrrg8lX9D+q0r1kNDJ0NiPudPrZGmuCqBlu9yVkr0/8hQvitn0i9pxoOXcwXZH33GtskD3wjJWCbXvELl3xProuVqitv5TEf9Ms/zJolXEgD6w11AAoBqbOEo8HWdRLx4drGDiwgE2sO3HjVWeIrjyKX7yklmO7GSNR1tYqKuSJL+0KrSTd8V16vc5DaewcVy2dTA8/cQrzwP71UR5cJYUVcDkwqWBZ8l3W8aJUHx5VzEVjvAmh8uDQsrx8JeU27iMXpdaKlqdr+m3aSv0+FxjJ1rLCA8lk/n1tulUfyuS6ylfJKjBo6jbdZHRrzipxrqoNjtvGEOTZAztg2/NMaazqHVE3dNSmsatlc+jW0CrNoki8exF/aRc5U2cQ08uqt6AX2kt6iczo1Pfo9MeqsRc38ylb7AzpiPnbx81mrmP+w7Ep9Aefv1ztejr4817SN+8IzEVcorEwjCy2JUruLeoA9H2uF9GZuNqFQmWs2wKi9XiOVJXPjs2JfJfQNj1I/y/4XOQg/4UZ1ecQ4v0II3ysL70MaJjJTEdQ9R4dDCJy7P61X/8Y0hIlQeuxFBUR817zLjZe+z3GPka6vJviOOzCDtDOurBa5ZcY+DLO7hMf6FEUEh0Q52Ol7O3poSOnLCre9nasuM83bOrPJ+mFvbs7skPgp4X4nKOIj4VT00CAKB/gvwQcMQjUOOEDEnbxZXHSNk+RQKkFglwB8UEV+LnBTWtkfs/VjuBatg4FmMy1c96ZF+jSQWDO5Aq+zcSVqjT2D1aT6GBm78aQC06+KYMzCzn+HhrqBt4Q5NbZb/80TvuAvkPmz3mhX9Q8L6GdRV4Oo1hggo4MAVGkbKEevmvhBt+Mmuzv+4Km/e3+skkH9rOVnBGLGBk2n4oTzEUPPzWZnTklboQ7vJevKr8t0A5Mo1vUOTPK12kQ5tueMjtlN/in7sknlc6En9M79E6DYvTAjwchXXz5F0Tuawk8Vu1psSVagjxOAc9mM/xPbCr3t1QVkYt7xwYkY1Fk67j0BWsVYS8cPl1aG15h+zUHMSCG4CGFEJFOtq2gy+Fn/FCtGaJDdfGoOAiNMbL5JlmqTvlSl/elkHzp6Sl10W3UP+08rDOI1l2JnZwn9YGG/jj+yeMP3johCj+Ia50OtlD6UhfDnuzTxrxiWpxDqItbf+zXDzV7igbiX0eZXNvnQMlqI92gcI+DD30JccnAexGNTw+enu5fKC9Q/tfSO30oTHHtl2pquRbYoph7gSwZUaJjj8HAeLYOI+pQwOeDAyl35/VeVTkEFeh81L7P2+WGgvhqhSM4YHPJctMlp00oqgYYNuJ0OCQEouaDh+4IFESdWT97uODUWPC0N/5tizL2l2CcY3Z3GDMeQIici1JfP3G+kEKZoNrfnREZTDHukbwL0hAEcm2u1QsA/A9xzcwI1IvcSRBkIdQ+U5jeoS04Suvmn5lNNJYPyPrIZrK2G1niOuusrMi+tOi/YgLUmJiZhhWmMEIthHmWhYYg8tDp8vNU95UOmW8inECT1S4G2J+6IpnLTlVjIB1DzT6f8AqmrIg2qly+/oe4g1xpoXhSpz+CgOyevEc4DOWyA5leip8g4J2frbdJWnT5Cpc5OnvTMNo94WLbd/+cuP0U8T+812LSxl/LRenW/tEtZcju/MMYc7QSCxSi5s4bXwg+3ATNNCghpcyk1djpwEltzsIjO1h94YNf9p3j/XEOkeUedMMWQOavsAQx3Zv/X2NBc8mr1KJR/qcIdKcwiXo+/lgW78Xo79D+AMyY6sbIc5bZk055I0qZJtGH71YY6yrL1ab9ob8ldN8XiC6fRLeM8ycVIsA4gF0/Mq/xOok4TBtux9jgrwGEeIe64hK5VWjxRKUheloMsXi3dCD4y9MJ0mf/HML5Zwz7p6NRF4OQEJ13AmD2+3FHa2UMvTSeXxrqnvDJ2DY0RCrV6KGTRSP8w7p5YgJzCfwcoDQ1tuHrevXH+rWc3uofZbs99kuwVU5o+TW4xyhWx+m4xJH4KPC6qVc7U0rYIfoGaxz7uIQt/oCSVc/I8ozocXvjTVqhboTlyZwAxNT2e0+gydATzX00eUw8sRXzOnG/iIpdyvnc/2xXICxi4hTvL4GFODMMHKQIUmgiLHthXf4e1DCuKWtWzMtwg4Z80AIg+oQwmF6qTeCmXHTMEOT6Tdzc7BO5bPuG33TcfoL47afzP5qlUs57l/ZiADN32TYsqtZjniRJyo7YrHVBXqW0eUeSQkWzv3XX0Q0NX9xZiR0CcK7eQ4MovLUdC4ZqFMRTf3p923pzMzIElje4kT6JieCF4Ej2KhHY8wB6eiGXms2JKr+IHUfR6a80GWaoMWyx0Gk/2i2Py4C/K3CqBeUkqy0CJDXR8ASpfXoiJ+qvcf0yuVZOSVcTdCaupPNuPdV7ejYXAbH17ZB4JsVJ1Y5wSmxEudNePOMqV/b08BqAsZfRFVIl4oLF0wH76tIrWrjKofONxlObINqTynknQh3iqViNjm5TMaDAlg+OPQwW9UyRV20OUhgMoePV9VrHiCe5xAaIKjAyLGt75gkXwqq3xioRZSGGkYhq+Bym9TbsMtqdo8bkOtCfHscuhu4mr6YX9yWE4v0qobTKm1xAwVMj9Xcr5mOtDTbZjGVxeIBlez9FX7H2V/finb75LqaN27SS4+QVDPwjTJAL7nO6Yre+4XA+cX2A1R0YDt7OPh4u3iCM3cw8gv9JRfWYGw41JEwE0yKENWJ0rSuDu3570Ki6mo4U6ensv+9bflZQ/cIyt/hk/DmA5p1RQq+nTVj9n8krqFFhBj2BHHxEpuNrCE41LP55baPLiDl6l//bA24mQWni2ALF/ADk1gzMUb066GN2k3LjE/riYiVIcGs4HGL8M2nfhQHlqqDadsy8ak61Zdprq5+1S+IyVwB3wYtHI+Y6AcalKYSZbMqBcqwZgyZA+iAHQKC8WLMGxi7l+51sgo6F5cEmB2PWqhEXHdwfbniBHXUoiY9uYUH1DY/Uz7/SOu8vHk7XcYOYxFADopG+wI1kC1EIz1OJ2mM/XU2dRYf0Vo/PgVJ/xJbNHclJZtxXRRMiuhk1u8BJUWO+dWrTFAig+3iCS4+5VvN21fctUu0R5o5Bc0RPlMNAixH5dXtKtSMNU26/cTBqNElFFWe8kg4FmN2rUVMx+yHTvtcxBP2aVuUK58elYzU2NkBSKNI08tqWON9SdXCJs3p0aasuf3k/6+PGwwWMM0o16d2gC61WhjgeYisq+br9J5qrenKRM2s7ivxXfftql1NUfdO8FgQBrRuccQ42oaLcExBME+SHWHiVJNKGX9dbmBA1Nrdh1JrkIw4sLgAwcXNA3ej9YtVqi6cKPvFqsZxgZGTdZekGLIGI/mQD70gVj9Gu505W1iZw/E3oPruknI5Uq8V/yohJ+z8MI0yhQnygzeRZh/6jNTr9bawdQkGYPHRsKmK9Qd0dtyVkh1jWeICTq2+IAmHqvqQGg/yWQj7IchzVsiDy/LNpuU11TmrfjzFa+Zpw/Av4SgHBCq62Oy6pnqmrmNmVIt006uv3AUQd1cqJN8zIxTfcRJaD0UMFPry+2S6y9rFcF7ktJ52U6RCJgOMyJ8fO0ESr8atrmc84fhuRSfsAVutO1zRv1YtUeMDmOva4t4hug5Qs5GSsXGEp/gCIH2kOUmTINI9qmgs1qt1/c7PxPOE7OGs6rJdR1jjYd90e0Jc7VnjlCJtHSOwdRZy6tb13ceiPw7s4hBson5hQpDCA0GdWkp6VhPI/n6Z4j0KTy3dxrJkRBKZPyI1P7QqGoKBSwYdOBhK3qOJGtVwuq+Q9mXTYgNJlJZdIP7bqCTxOSRTIF/uiXyC0PmZERTQse5u1MTs7j2oFb0TTo0JwYjreuD83bngUfgiEQjB+r0ZotC2WGxKYnbrrQdze8YvPM3secFKiGpoHOFTz1Qgff5Hp0BvRnFMlHjx3cSVWYoHUqC+3Dyu5dhqJaeEWfwxwIi7sCIwNcsqI8y2HIUNz23zcQUJTp/k/rz1SV6rT9GRYIHGDSIWVqWQ+iD0VDnYQbqRuoNbLWjLSrRYVAincoHyKw9RKK7FjpodTYa3BdketYtJ1KttjYAJ+bUqoPftao8pRqY/wsfh6kDbbHIy3uqfP25z5EAPs6/RQr5PHfcZrQsqP3Z3mDk32//y/aHZ+eafYmeBe14Ndy4ns/h4sD0/7CiteCkcwba0XL812j7rN4cprtOIpK5w4bXd1gqdkmYWVCE9YzoY8BTlwlwi9E7A/lbfGgFSDXt0G/jXHaEYXi2gP1ljclPMRzMqyPz4U4tehd0B1l6CDm8sjuxAIwOBW2eTJ6v6lzhuJ8tiPPtzUTioGBlMocQ+fpZ9/hiRttTdST/gRPzBGmT3TlhYA835NEJkZvxEs+LeeiYNsbDPgn9a/BUNQlYEUUg2GztatKUEDMcCL6Ir74fpCI+SdFJNQ1yRSilKAX2q5rp4hQtgwPdgbpc6VCq596CvJV9U8bz3UFqQptURWdK4QfAJJUxxZTJterX780vnzhNVw6ljyAKWyKT6S3kdpLA3Ob9sOFIuZDw4T3MPiwHKFG3XfZLqisyWJIHLDMg7wN0WPOlsNKBHyJrGM5IxYkAtLtkmC2J6r4fi0MNG+cgoOpDjPP1w9iZhCyv7Mc/cb9aXDSFiRgCYgtqdawOX2fKApC5RzMT9JMkJN0+SG1udFaNM5pX+YqfW0K+masJmdoQNOH+jDuntbJm4HhzepRAIiEtMIX05L6KYsteU1Pb6OAYWfi02Yp8lBVqednhrysztTWfiNZGu/Mzw7ny+UmfE8KwQdbOiOGyL5WqxpH6FRe8esW7g8RalO/32vR5QeisuykUXMYOXcpJWp+Gv7MIlqmcVhwojs54uBV/GX1wLTJgUh573yOvPrsdmNOxxI69eGjIoTT7rYXCAbTYqMhLfxiIjiAnM7r/hWfU/zqo7IW102lRU/Uo+iD42Kme6LqUWA+PEbwM1C41SSQ/zBb+j1KIIUMenaIepqMvO2xvlE5IaqFumcRKu4nIi48fUOx3qu1F3En7aPDwRawOecGUsyzZaSUhuNMlFnC4Psj8YLW9vrKZqeSzkWvC+hhA1HmMfDYdJX8+gyPrN7VWmK+V4AFgouuG9WaKVk0OEx+pTWklQSd6kPxFYxXXdbtpIFIzzP5YtDhi0I/pV7TPg2ckDXnp8N4uCRott0YgxuB1LKJ4/m+4aiaghaGua+egOj/Gf0zdrxS4M2qGfaxT0V1Qq8cZ5wK2W1GyPt4pNUWoil3Qx1jJdwj/9++hBedtYSIi66Igu1H40HWhhrFPTqKX1n5Pe3mOmWL7M+brRcSlS6smSN8t8yIQyfCnMsu1ZfjKpKafyGuuICUpr8kKNkLkO3KN0PgikuWLl6hIVJ/GjqXZCiySnfEPatwOrt6xEm9YauEo5wg02aqrM+NMgqgoqoE8A/lApLnn6svkibIdQu/cRK1gQ+qewmBNCEiE34SDi8/YTNv5q6M4ZSb5ECQ6PNMzGLzICbM/ODl5RUOxMpLl4N1m5ci4mm4O30NF0D7w6f9e0Tf8fjHH/IzXDcpILTfRQU0fwFLCelHAIY2D2ns3WNbaeuJucnaQZgMkRWYtYXgh/cH+kMBip/K+kNnXakIOth5L1/RXqXdcbj3xtYzRUqd4T3760mkxpxHHYOiip1+t/+eqfc7yV1NQw2kPHJCBTBJnAElLEWk/Eq9emL4208KNab8dm7SAES3aHZGqSmnxUaN4eW3s3tzShp2LECXDcWHVwR69ypjZ5Gu1O/PaH/FMIaDzHJrVqEyBYSAU+SZQkE3K2t6jtiFczDjYOji3YYWOD+Klx46eYoSunS1CdxRIU8ze9oxMr/EI2zovLM6wsFFsDzh7PN7Y+ySARjYXSWIRVOuDyod2Y9BYG54rKysQCMcG9yd87+RU8i6ymqm+A8E6b1bA8kKnTuikYIVtkuC9bVesj/VEaCSCSyoXAbdErlKXwvK1pPS5gyzAcb+IzLIgeWz3NWFBEHabmE7CS1WLkomr1GjgaaiThWACE2Kq5Qg6T2CW7Acn9DUg2Hcahw1cmI/PewOT0Resjb+UUKAmAYHLcN4I/nrhOcNxbzKLXvz+tpv3z4rD4kCmNKOf5ZP3CckkvvHX65mF2zqe/1G9ASm62J+aSQpFnCIGf5qsSFF4a+TTbkqvyNb26JeFrcgfK59PDfbHS9UHxevbCOOmZ1z5vPNY4t8YI3E6z/lBT8fceqTokWqP8ptiosVvOWAX8gMEHrhWuUCzyjQEzvpflLXXUvxJoVkkEjsjBxmKc3xkDiTBCPTN3oG5v9Pe+w6sbFk2XyYxW6B+TCZ5ULSAZE1VlLFtvxY3YgNzsF30NfNNmIq7yyxOX0lB//P2PRmkJusEOCtflNCObzFqwBKOxRYi3OnmsOMgmLzrJlcmiTqs9gaGUpC0kImtABMOzL4sNK/9Zy7SU6knBI2l0D0tisaucdXmn8ddxaq/2dLno3OW0x0cO6ZFXIZqy53yscH+kJducaDOUsjxi9k7+h8I7y2gjDbeVI5F7HbRr3QB7IqEopuHt8v7gy26VARhWbhnrf/6QBD3P2FOoj7ekg9rpdSk3Oz5eNhcDmUTkH5tZa0bb+ETCbRtKgbdjnkVWITQpyumhyYtIjqL3sZWrRjrMGQ5FbJR+YDSLiyVAN6mwRBAXTv/Hc5RTXl83W/Qq7PLGxFV0DRRjiZn/YmxWkw1+3+CfHKiH4dpJs3yX966FwFFoY90c8799QsZM8yv1+7yGrmLuoYtgx0KURJAcnVewacLcpOjhHm9O1yzS+mx7I7xocFOUrL6oPjjTG7z6FRvi3NdzHLT/8LGdAyRUByqqy2uCLT7wKTYRxZDrRYKtZKx8wNJcPKVRw/sLX8gbye2uGkl4In9f9bZM6PKXDnnwD1+isuFeztcZu9ORxqQTW6dTg5Vb2EFBNzJ2MVtvctea1iH5xz1+vyhE1itSOTQkbGYjE+K58WlbYL39Ui2S+ObOs8WEKdMyEyLOnb7Ul+4zbe9zpPFkyUEIH4IDTQ7fQh4fmEuXaoVjH/ggXdMzPxMAN6rcu0sjxssJgDOLrHDXVEKyEeE65uIN+9s0xmkqFHmodOmbnniWB3R+amMaRnfQeNnIEvDack6W+fA2k4vG69PQX1Inoboa398+C/AWYg1F/gWwgKmxFG0ZbSY+NuZweDgOYUOAANml5E/wgIb61aYBI67AgBHWCMDKwg5tYNrV4z+BbKXLjSBXbXxwapVWdtOSK+0iv67YA78FXwzQPmWLnn6seVLG6fFSaCPe9NeXQ4C2VGcbOUq1zqCFR9Gie6dA2MxEHtC7PBuJbp9TrhnpDt7zBhwXgWUQGZzmY27fgdiZohAKq5n4SWZnjkGP/zhj3UcshSEByWKrkmOCbMJMOZR6KYpRPl50az5R9pKL0Xdym/b3B1fNJo0WhiDO/a1EO9AN1EF3Q19dSAMUpXxniyRkIXRPrjV508ODPVeN1/53QMMnuM/0xOsOaGSlR1rbtdm/15XKnlmdgDff+wykOLg718/lQ5HlESy4xyHizrcrSF+xNeDgYn2YvNgq5Hom53Bdy3LYaVNNfLVRqGilFhD5C1zbS4ChvlXFsSrgmoS5fjY1Cg4nih5WIJCUZbclIR6JHL7buzZeD41vbefWBNfOC8mWMQ34FnIVrz6iwaV8HwXuKHGizHNLpd0dfjXkC25kb1PvQLQYVv1AI6Al7mEVLF9m8MvN/ISZbwiUId0pN7yfQ2pIUIGyyaSpH021SgPMG2Wlr3ns1hsNGhQawqwvzfRghjqR94t+/v1MDgMXq85CJy4EN20aVgDxZ3OOOaZtP1EvRBkmeFzUVvlCNNpwLzUzi0ow9hXS1mW6kRK3xl/4rFh7rrCI1JNMEPUlmeqVMAmMKw0Pdl3uuyql1uD3VBdVbWGASN5ZC/AVWFIjXYvRUeCDLzJYP4D7trlw9XBGZv3tpLfOuSH4vYRaYNUEb3xlcCwpWiU4FYjjhYIqa+YMXPTOpcwdEEjVoKjVQ2KWtvAgvuGwbhKE4V8XpI+2nxw43rxs0Q9wNpkPQVrV4L0PUUsCqOhJ2XiFkK+MxlZJecB5MXf2i3RQgoiaSB460GEnBAmjKFcTtaewt9TNZbiNStRT7fRXNUHbT1uAKkqBJH4tiEW1pD7QH+3dZkwuEH7sMhls7FChKnyrM6mmCbfPfHpXjUyaPA8d5kWVHsknWiLDcql6wniw9A4LbduVZzet9+h7Ze9vpjQY7hlwyL40HFVVjowCpgqqBBMtYCYGzPLe0ku20EjnjRGe9yY34r2lobo3bG3HzjbVmvmV1U3DryWUE65u8+LVUpjrS1AWi+GsDbLapFWSIiYZyRoSKdJUJu1FoWO7zpNfnhoecUrBpmOIkOyI0JMV5oAqzu3jK9Cc6QQDS5+p5BqAqhYFpPUep2Cr90tiTNu5hmAXlJJ0mZLgij1yhSefvN5S6IdabmlVH/29m9d/hVkH/SwvXYhDXlIBL39BThCeJGaBJHBAL6xyHvC3tv2HQ7QbQOXjvHJIuIhKPI5QP8t23CJJACUbSsfHSk/DGRkgzM7S44DdW5fji9H3I8zkvmGXj7jSahR2YpMQJo42/TnXTuoPpxbA1+SwIzEN0KywBmLMXfcWuMpuVdftSCiInntIs5g5M4Pomi0GStMV5+rX7xzPHCeDyJv5RV4053NoCJew921ku/mB/5hEh49d8/NB96lJ311S0mYYretH+1c3FfVqEUjDeDL+4f//sFU1hbfL0YLiGninb5r8DIqgmyXuQLoT1cVJoSNrWieibYY6ODR+VfVhrWQofwfnl5+0OA5RLf+h6uJUr/S2JnCIxzek48TH5GUJWfCWysfONhXF4EOEWLRCfeFUx0M6LEpOjoJO0wjOH22A6oJDzAZgxOynQNCV6VrGj4m9JTHILfzq102UBBXageKBGXrLh98la+bPySGmvzZr8gmz4jWiP9X/bR7nmGYsK2S75do+6JMRqLrVarOrwkj5PnRWyDynHuVFgikoQMDIZqXPRLDzjZPL5YR726O0BN88C/ESYOjqapyvsdo0OS2DZ6Ii+Tm3IqxXQ7jFx/VijqhKPpGpkT5Hz9RiIeHNm3stFdfL4jnWR3ecuSHDEd+RfrwVPuTYIrLRXqYrVLcWlbcd/bWrZ7HAJdAqwAa83rWPms7k/LJu5aQ7GwCIuAx8GMownih0ainD1R1IqcX1dIx/aFUyeZQIL55XkoFaNGQ4cpOJo1hiaLy5/W4gZmm7Ti7un8zR2sTljixyughmAwTGYquml+FhXJd1wrbQUdIIySx5xyNNfPxsVdpJgxgJGGZ1wMSZ0ATm9hW5yiPZEaJMvW5xnxDNJ9pyRPZcty25t4WKxyKIkh/rfyFhBLXCgrnXlb45RhcvU8/GiMlE4o9sbE6EL0M/f1aNgYSfuzw0Ui/EI2gj4LafJESJ1e/yxdUv7Sfwaq+TwS/1srLI4Ski6sxkNG8Il/BZ0Uxos5XTtw+adgtJWki0bkaCIww0ebiPfb6ajRpcxdgum70g/NdSjArqcZfPcPbHQU1kGUX7uq9f2kY75c4zSFeOx1bOjxj9ljnXOKMBTUzm5dyoid+Swk8fdKiBWgy79jaOVcxrWn0QtaZYxCuMLkmWeRfXfwKVukdp18Jly+RrPLqiZmFyI9F9jeIT/6FCULKt7oVCxPoayHbimQqJenQtjyglTov2hYwf1HTahzHXCQIGsQe3F8EL6kZDDdNWUiSAL0hQhc5vv16w/u0o3ukT0XUgNt/nqYUP+jGFnAZQGpZBbJgfRo3kqo+1Y0djAkojPt6h2XjSWvhsRV/F2b+My7e6UHAyTWUuW2JqyNf5ToL8bVi/IEEx9JixZzq/eK47JMFmlTIRlsW8PFAVEM3C805HK0GBKZSD5wLvoh04lkqN124ziqxQwpf87S8jIwdXzcgJurXfE2IWY2XqcA6rM7pYMSXNRMRv8KeeBTyi3TN55zPVpS0+KJt4YBRtix3AbRy8NQc4pUyHNdcojgp48IKG1N79Ru4WrKNgl96LewJJ3rxznA7cQhJ0aILA8T6o5EO3GGluWwIpRDSDorXn4UA+WNAsHDLIDOzi+XUfdx23AGu1utIIzxVj9OUzONlSMZl/SyDwBvhiF+/vQPpf+hjQS93RmOxtP1OVaJHHbxvR/5wiJI/85B5qg1U8t3/Fytna1BXqJBZe8w48x07ssc/H6l7521uXgYJQQjRtxrFl1+vhDsGHGtYwTQjm863ckwAVoBZryb3y1qMj2+HRh3mZfcV26zUdSGIHxw0ovgM/ymkePrQ4ciHkmQE9vD1Lc1271wXHkS/AYPpcRraghr4/g8nfYx3fEvZJuvRc3O/ePlXy2T+Ej3Owglma1iyvMKmAzbmZAnFL11IR9Z1tLqNE7Jv58ZB3zifzs/HzTlJYUGiqAsPAgfbr/xkZbduUNPMAuwRWNMOn9us9Dlfqxwf2bCOnyHPExDDGy1S31VMD38ISyGaWGcKW2p4X3Oty/JAYJ1kqGUaEIc7ERP1k2ya+nithNB2hWoGCy7IT7xQGdwbh2S06CIEGIb++E2UEgWO0K9FiwBum3bBPz3iTU+HRG3ARW+5xNDfUaz//7ALg/X16CYGeKJNxm1dg/tjOhu8YsomfXzbkZSBTipjB4azmjJIRu5YMCGstnSNMMtgUKdp4rhjhM3QNRsp+ALB0Q6W1eUcX820V5jVjy2OCpWkJR6HKt7WRvef9zqrm3BkbboLhqeI7h9v8dWPazEi9yu2sJrr3pEhLlMryee+jDm/GLiZ45lLR7X2UnX4bbGQtr5F6899Zj1fy9/zFolZrD/jYCemkCUwG5tYr1isP5lCZs+Ic8tPsfQDU0r0/tuZs9MucZM17oIsq0hm8J3HmsCOWCHimU5wQLyB8hmasUf73GhaGRPoHetq2Q1N4ABbqci1OVnnrJtSkhsnbvmtznsE6x/+xSo74G6UkWcCqbmIYxdxMEJleJAVMWcFuvHktmkeY6wUGb1yi5dW6gFP1VbE465enfvk0qbLRgL1POBsy76NWyKpe89+YIdQAs/Rkzj1TXuA4PLObESgE5exXHd1FMpFFCybkgSm0ssF3NJMt00ujDpmgCIVHsCygsX4VDMfzbFArvoRaivZxmojTTKYcwwHprZb/6PWnNC+IAp4RkCUM4qEOEvcFgpUE+tsnoIeZ8nkSOR3wD5x4RZ5IlpFMuI1jkX+0i3QHYuYyGnInftCfHxGLbHiXMR9vouCjKRmhHxvq9uLo66fJm41ooC0j7EFjR9Ird1y+TfWeImqrQhIFRnTJvoRxYxQL1Sa2SAn84IPO/OkP0xcSXeE/5LxuCB9cra7cQXDsTw3JHR/JzLKBkn2K8s+ASN2KZtSTslyui3xhvwlR2HzsSSRTr4a4IAGqHtRNJ3HDQNTnd+UU3OrNuHAmdz2+a7WovU0q6yVyT+aGkQw3NmHSuUcQaXH3vlDsbTGG+gbqoEJNrCzfn76RjFFuRNPVSZ6BYZzUhn2k7t4AQX0Wj3hNUaZ2BThsCrBskH4z2e3FGPYaLDVlierjLdWYaIrBBcgWAGmluoobAJA94ffGMCALV3tDnOEhegaygDDTwK5Wek09V1GWYSOTvoiMjZ0ZlTxle4kwCJm4d6nmbBPx/gJXm8NlOGMRxljm/iZ8pXUJuEqj5cqzVpL62l1WPNKacykDkf1OrSDSrEaaof1C3L8LUqXq1oB54iU0mtNyRqDkzDl0VObKa818K+jMigg321rOk09LuuMOnN7pFenM6sIkVADBMiKu7web1g6Q4ir6ENGGKR+jlvXW6NZh23Ja+iDyo9/qYExBQTj3i2MbfNGlf5RnoAwsALrWGkchO5KZ4IE9ndVRfAKqNnimJEUsd4+KhlOPm6gHRnRUxZ0LuEbc+5TnL2e9nzW4FJqNv96nyVP82Dbj9pgf4vFoU10PjFgqqK62+8L9eVULYNqytObZjx2zZIFhdfVLpQqnNw0gJhiGtm0CqjJ36WU7gxDEn8yYKtClY3/VZoblsZ07BYXY908f9BQO6Su8Zbl2B7fJ40uwR96WtEcqCxjaA/7yHmxsbCmaBHBMnOVaz6VVMIRda1yXs7h2vk1uR8TOSJ7XwZaqhW1N2gG6PBi71/GS0SrnwcolcGZENorb/S3oxZ4rop2yTWDzRza3qcmm2G8D0777PsSVx5z4WtH/jDe+8I6zQDhfatiEYAhh2WdCzfav3EMnGtqKf25XPbWKXiEFuugnwv21sXr44QuXVID/euYGDe4d10U/0fPoKm7SMQKswXVWk7HKd2ucNjDuEFTnHCmDP+zJkP5Nb1byZXoNgKYfECbmVZN3kUIa0V3OAhcCL+iH4F9j2dbG2hfqHrxQhs5A/g+ArYF27yxZFp6Tf7U21XlzC+gCubxx0jTOkIE838y4bYUb5GlTJyuo2pUJTc/7Opuk3p5qEHF4qXol8uqVOTIpaxTLVNb4g0/oL6k5r4cLTUCJHNMcyuUPu7zPI9zhuA0CqhjVMT23oIp7lVss/cDoAE3EzZvypltbufXPA9YV+it8wq8BEKfNSQ5pd62T+GLK9Pf6kR9x/osepVeH5ryeAkGJdfqUdj8OGwxP44S83EvYyAgNJ6FuVY3XXe2Ly7s/ojE4LCO4+DaSVizg5+ZqW8E0+ZH567gbWGBqteq3joPIujgQWg/ROAVUNOe/JukcCcW0oMnHS5FdWhuOv3rWNxT8zR1+mRGElnm50aCcZGgY6NrMRujHPS7GDVvMq71sCrfpm8NWeQitb7IzBT9ov1BQZbn8YYG552oGA/9TUhHHr7M3ouybYgAVEGR1wluB/gxEPMuQPuFktAmsHm7XzmNq6Tvyizo2Bhhf16mpXo48Oyc140KhRawX4bGuMS26XY3rbuzEtEytNJRqGh4eFchOeWnjBPPrUa+MADpekvc73efIS2+8oZ4JR+ppwlKpK2bSLydYy+sMoxBu8Y2b4w3exKwkoCUJWGuocseF0DVPcUNfq0sRvfSPwP8Q5Z9I6URJyZPuuz6aqXc2F2q5sVqAyZI0lzATchjtmkiqCiX5p7lNdEItkH3WC4zTBkzr2z5goA+LA9yKZ8ZBWk5PlS2nAp7yAAelKdqGfGHvIRYnNaH1uF2L9p0flwCBps3VnotJdnRX/zoc668iTkiEA9axU0FdZ6yikqzOdRQ7grPGOT3JuwDNFf9KpPCAIPXBdFsJmIGmndp3uJVufG4ql/v4sYzoxevQslEYe8GSqLGSZpXjQ5ALzFa4BSmz56Fh0hpY9EbfhEbvgX6n+AcV2mcFCNl7gIYL4Ykit2z4bSXD6DWGtwLNoXt/SWdjBb3lq9ig29V+J7/1oFQj984zx61yNvhFcMF1b5+3lgjzrTCA1diX1bGvmwXez7mOsAM6jqRS7q0VLGnjuF/LM9NtB0mRFT4eAf2jVI+kHJE2nbRZAfZoX8eWbotAR11b9lyJa1rX7UVKNF/IRDeFx3p0yxjVyQhsHWi4YO9IUx5VFCrsAlK9JPc4gOTab4NOtcoVNCW9uuoxh01weuyVF2HH+hFyepd1wiZcvmYRmO6rrPnLpdzjy5XGBjaQMvuQhPwMsyQtQWT2JNEdzCxgqpIBDQ2xntl7YOdEsbggfq+MFWAoDU0VB5jVGlDlefiDaaKa2pnYvXkCMHrGcY3P47qIecHdne2XUMsFn2DGjcF4IonNYB2eH1QecHqqHvKUQb6cJpe1YPItIJ0nwCpO/nyGlYDYnXvW2Y1xSsXMRDYWZN2T7sRcaE0Qq2cEigzoC7sEXJIJ3abkiVHQwTO4+Xy5zcealpiXS1A4wPrKYs7RTdu/gDtxUkjHyTY/XVJZZ5RJ5h1+XgesdNvF6qUqA2nDfJpunPn+x/9I9SojPj4QoObXLDMKfq93r/cbva+FFyPjkdmshScXrGOm2ku4iAn6Z1BChK5LauJTcwzIVxqlcvjLy6bgnj8DB4EzvqiPNKK4bu8qOQc82LwVqc93WMbaTm9V+ik8S0/A/tSMzTpPnEeeZkfuIpUsF+5lBzONNYDLbIWsix2PE3lxgYtBEA9coGrv7m91PpQ+GITkHNt9hJQ2TGrd4sXvMrNF3XEetzXw2So5g+Po4jthIJIskGT4x/82loEFXGtGyF0Il/O/lQSDA5jpHlXBb5m2K+gyLlDMocXXfCKyjQl6aXfS65vXO2NvAWKyWqhq+tFIUsxHtL5p4SQ4y0nr0TlOykzefEppr1ImYFSELR5gxpk7M9QIurjulN0qcwKUvv1ls5HTM9itx89w1/FTwGRLWMngxT/omxcUVsrGCqY4ahhF37XhEN5+qPSqX0tlII1863wSpGKjPN1g+RxPKBlW2TSy9d68umB6XBrscWs9aMYtX0dSYB4ItCi7mWY28HXjTS0rIYhF1c4DCxpD241FeF/KP0NW9teLePesGU4QFwcSmddaVx/YYntFWNMIN1jEI6VFp3hbWMpZT0gIw/nloA83j86zfikTec8TebHeO0LU7UgJlr6gKj41/byvXLGXaQd5+5C35CFa85/nJOd4NVWjwHUWoGhFq7Q/lDKU73/9qaqOo5dhizLnCm/KGaFc9bRWyopQQN+tkSfk5oAC54SEZu2QTCu/TUWgdDA3mObLBzRhyA0mymNiyGNxFPfY+/Yf6BNpFloyCe8xL06WiFlpn5ci1GY9LgN8qxdqhlplPvMYrovRSis4mvtGbnupj30DmrlxBNJ2aqZ7W0Yatud6a2tYSss7Hnq1gedjzHRx7zNsfXvyuu54WqrQrkiuU9ztIYWrGn0ssSzNJNrbbTrKF20wtvihK+wqTcurMEKqZYpvA/6OjK27tnEu+Q0p8Q+0ELtfwIWocFpFvcwBoPSgNZske60Vnpc5v5Ym+nDQbhonID0lZTHPLEyKM14nREA5Tqmzu6e4ZGc089OAo+dLXOP/1cwDHdrNd6pzF2d3vGiYueZSPWOxvVfbLq6uQFu47w+CQ1srmBz1g2+MYsdCqCkt2Wtg+nqq3EFtO5FOgFte3Vj/j6j97EBex7R112GOW8gpz+cusUTiIr8l47XQCSL0v047tIVJxuNz1FjiAjARCUTwvm+gAFs200c8Jz3YSgk5kmaEDpInrxUK6OXjmURaRgtvlK0lTeY22SVp16cwHR/4Qp0UqgLoSi+//vGcuS1HCXhJnSr0SQmgxgP4MU6lrki+AEp5C9Pe/zddzLZKUoemT44BWWVcBp03BKxhAiRSVnl3NymJDdQKqgck/JgGB7bnqLkj/vNrtrHRTacpnZX31CHe72iwqJI6Ql4P0dBEXnVQpmOfb52cqk707FAV+VJo8PC59GFkXVk04pRZlY3zJbZLO2dRqsiKG0XoQVWIlJ/VLfxMGx78XiXjReFb0Yo1Ykn49GMAzeTvMDFjHVzfKvqeIXjs83CTmRjnKAL/dzELptaQzo07xbb4KDzSFCN6FmgT0QLR4Er8S6voMrD4EA8l6+XjkUPz/hK58kvWd52a3kTmyRC0iZ57HQAUMTKD+qX++BtJEiq0rgpvk3EGC71FarOVUlZBL+1RnlIDDrDNzLPy677avBx4RkxfvgUpeNTy2RowX21H1pQYgCNvrseHvL49qctJem3lbPCGp1M/4Dp/dIiJOH8o4HsS0+kYZflXj1kpi24z77T2QuBA+DS//vOaZCmk9NL96XbMcVwiQIP85KavNnSYNBMWor0dd0ya3I5tDn4z1li65+HhxybhTI0VmD2h8DysFqEBrxSQg1ucmcZzrCM7l1i2Q4H9qtrQ7rJ/dH0mQvof60k6Q+JF2oFherPVcCDkAzPogcafycuJSXzQT7lhO7DZm1TBhmMXgDe2F62hXhIG7DedBwVBstHkN6GuRVmH2BRALWHVFkX3NGbZ1Un9hBvPWMzf1GNW0dCZv1Ztk+lNQ3yYxVmcQM57Y1ZzQWGyjJLd+npELt7PBqWtWTkca5YfUTWbds35a1gdqKKqwiC4ZqJOQMuUJJ7P5c6VQkLjb6wqubqKKWxP3f3N+wyJeF5ZNDNXSaj8oWVOpTZmiTOBPJ/SC5fO9c7/KC82nzN+76gtfQiKoAaeNoOtl19ie9WB6UrCP4JzsHVPYe2rUogkipZkBO3rjEw11z+/v2rlVu9z4jqgaNb+6gtL75d/afyZ6geWU73s2ZYGHEGg0wCi5t1INvsomYhKZJKd+/B869X2D1bFn7CXwOr54KvB820O00bGipmeZAIuRSoOkV3+gqrkmlhYcQ9AE/aHORNtfMeDvp5E8Z9Y9cRa2t89wI5m7ZY7nmuZf/bosuz9nu52l+Wmj0qe9pcHwzBA2MetIuEmysgpAtL/FyV0MV7qlrpgBimarUKvXncFPgz5vlY7f7AvdF4zObX2JOIpfPmZQ7xQ1ob0RtDlJ+5q6O44oPj3xncWKoK8ADZx8fWYCSzLDah3coAf/nxAivkyehOg04qmIWHjtX6E3znc6aGVO1espMXDt3/jLsnDvUhC5gWj+VC1f/7OGPQBAH8aasqVq/NSmrd4DTmiYZEQ0MRV0UgqBQ6remkQJZPMDSVnkfkyBdQqNrOXB/FqybICnBxVA+LQedv/FBvJXW7eNdd53zkFKUJdeiPK/rdHkmPqtWeKVx3z1Lg8y9CmWYVQX6zGsSQlYcngVyNxhuX7VbOQFBqR4EHC1XJ503Z7EKHcBVOYuDqCP17MmdwzNr9h1bIqGLjYNSdo2HG1I9H0/f+10FEiOKk1tzOL63YJQ0Q0waiwh8iC1Ls3SYVaP3MdUpS9MrvCK8ph7H0jscHJYa/ACbu5s7IR4tZpbnbd66cHxt9/dpRa6FFdzqIu/+CfJys2gqFf9VXHynoL7KkB1Lbr6+7ObsLSjo8ALjZYe6hZxA6GP0JdR/pG0r04PobJYMjzA4vYeNhwXlHbe4T1JpNDQAR+RTd08+vDVd0t6S6yqA0Swn/2CuevWIxIPzUeVRJRbNUZBlOnhWsFYe2jjuC6bSw2h8tQrLpGXwEMM4S2nSDV67jqWyjNq5yTqj+7DqXV31ZZ2CtlxBqvWOnXOBgnfGkKwyIqIQ7T096KB6DYSAFMOQdYuWvzjhXxysbKTN2Lx1A1POINjK1/Wi1PhJCDY5CuAOBufCG04ytzgFzxkovcmKfZWE7lKdM0d2hRjhg4xcBc3yIlvhWydcMKM50+E4EJ+AWiK9s6v7lWe3FuRoqtqlTUqb/Pp/QEgZpPfR5402sSMvD+qGhIi4pyE/yxbxKD58JlaJJGOQ3HshSArSMil73323Md/ZqsFHzXAFaJlEcjammNWNNeXx4EGyzvLC+TphELfOzmTd/YvHBKkgmrTUFOTJFzCh/F1W3AZrC08k0nUGub9WfPhnbO6+o73DZT1c7Y2XJp4XbJpdOyObmUJ8vTkOLp5b/G421nuReeFKxEcC2wT0h1CASzfoqUMAHI03qHNZwpqDlTbpH2vIavrYxP6EjLce78Da6nfh3v/edRXRKQKQDLcf+l3Bp6ZrzmtMqtNh+/6hTcbF6UmfcwZdesTbeQJSMVZil0nZwai300eFVvxrfEWe2mGRMTltjLX5IKxgqL3owjDWy9EClHuaqdzU1Dd1DV8qIBWJssHdSypf8yia5aT8NUzdfnaDUFS9IW8PxXOkj9tfZ67hl8SyE4uwRTlZ4JxyPxD29e//qfysi3E4CEtRNnQYgMgwsvcylDu7bYcRfSSkQyOwPntJ8upsF5YoL+nBxa3kzDYnJtBVx7MODX7tFiGGyXDc0gNUi0S8xRwGbXR5epdRSB2woXjt/NDfi9g52avEQmTcXf/6qLn7R0Qrf63LmWQ/xu/Y1cgNljF1ZMLVZbNc2DWqPIgq9Hln7/RfKf3Go8gDkNmtUKqugy4uOAJwNF2hHPw391gAceMmk8g3P85gH4k2bwLZxnOJtQp07Q7u0C47JnY725UCt5RSgrCvK1bNIzMreAN30JTZIFbRMWg7BlGPNId/gE+5Tl6oLWBbRKJJH6iBAJdcGTGW/QjRyXWiL+5xYLMuMXwFrWoTeZYCQXIFc+FCRg+mKB+H9B7VJ7hXFalJpVDOAuyA8IWix58UJLHKqgvaCtUjovrDYtL5V1GW36yX6Ft2ORcSbY56tOjWsPQ2tRZDkcUXCrkbTahQShoovnbkwbxWRrVaswk/7r5rIHZcO7wFpHTht8unOYd3VeGH0jsQdclPq0/SU/W0Xnv2NZ1X8Pg6YoSkh9YiRCY45t9RJnjW3acwbqRe64fmi8jlRHPPiydwVh6HdeJFmgVjF+uGl4jvXlyHBU5Rtv4I+CWQoEQHi/c/TcpmkdCp2/9K6Uk0TozJPHVBmddQkrbwt383V7e3RkVOnOKjP/gQCEuSe7e5FjHtqFuRgabnkW/pcbSXs8ZR8H/xGtesBUp69FoG6q18DbaCb/PYS0kzTc5U81t9LgwkPPWrdKp4GLimm5CJxq+4UfsgYMAepy3l0RoaZi1u+7DJpoerC8WpXOqVsHa2xQDEFtpjnGe3lL2c2HzLFEQfh/EfSKh9/yIQjx0g29z+PCveTBRFHrn9RX7uSN/rL1Xg/401RvTLRm4ujIvMQgUcAJcJ19TCIWlwIxNGGUxLTMPdDhGo30N8qxKMn6oJOck+CKdmBd2CkYHnh+ApnNCdUazRXliisj2gaPSH7heNitcl0nBEvgI9oApPfbZAI11wcZ9aylZpyf9+zxO2X9Q1yVwIPR1ilJzIQbV2ThKYQo7u1r6dyZEJDX+4aLR20f2l7aTzrjzlpdcyFLA7DQeouQ2AbthDS3EoWdUmIuFtF4+zTjvmlVKQvcr4qp5IIGHWyQqSN9PEhl8WfVBqmV/sr6whU2H9WA7+mVUKj5hiWAJ6TXtfkyzv4YNQ9g3lLI/DSEOHTFYwD0o1sheaTpM3JULIkEK1EmtOtCqIn6V37cazRQydMJYffmBukYU2R0eY7X8410l/X0f48C9qYu8zGEeeXpws00BCWoJNFBWj4NU6iM3fZfueFqy5djneMwiu8qx/v8irXqPAudzibMUzb6fxeA2kYNrFlXERMXnmFKjf5UgCXIl9KCxn1guKp88tE0tps7y6WE9yaF5W4IkBplZ64eT/bt6THpTnm9crHM2Q0HAGZ8bMtXz4TXumWabMBxmwKHKXRMBn7JRcMHa8OatQIY9qtOSxyT+u0XeMn0Xy4Nw8rL+bbvch076Km1v+vqgfaMQrZQpwN98I5VgFBzi2BhtHQq6o2fCFLmViahhfIZ68jmDH+w3eKdJX9jxyHhEwXeUif4j8mwRVO3t+FMxnKARuE2gM47NxkXEhrzWeO43raPra2U/F1yt/bKNw//L5NpumM/PAe8XCN69K12whpzUzWAeMT1U4fi9l8JoFp+KmauN6UZm34n98Ja0PdYOWOcRJ4rEjJXO4UxidQyHrJPbrC6DpSCwkvjS0oao8hTquMlZ/8oKch6weeu09/fUUpssP/Uewu+0y041wplaGOTvZjdPIoQa92IyOMkq7HLJrcs7jknlib1z5Mxg4hs62H0CRUbbTKImqU3Uzb9Q7NteNyeSBHpLZTbtuwDW5GTeNE2587g6OuQAMNCqQBz/3dHzoIhAyvYIHTYE48HVh6LAzH1P/yARm1mJDaYKVKt8yTAGFLpdouRTSDDP9NHki2AiHf9GPEMEgBdpA5hro9nQT1Q/k5z6yvrEKTcqanf6nDn8N+Mx/+n4qc+935Mkbfiy8528Ksq1gIPOAZ3zAoHvVcEBQaSQHcLA5hCSCm1/93tPR8xXXGUZigrvM8nAdpWjzPVGPkFmrDtItYT6cUiCatrJNAA+1Uo25s9JUojnSGrWFUPQQAYuJF1larAoo7PZZKaQCm+u2a6j50Hx1BEnGF2SK2co9I+h3Rmymvw+LEnNX6CX23/hOmcJG4pjSBgs5bsnzoXpgyHpEDFkVP4VSI/RLxmCYsQDeC9F5SZEMF45DuJB10bipnvN5ey3EaTgzng0f7jyC4VrdpsTsvq9KkTuR7Nu5KVSLpEChAQawJ++Hcw7vxzNWSOBl9Q3hQkOmZIdx3tl7h4dNYXKadJmS2gwf+kSXIftvkEjlPqRkQ8L+HZ7apPdL3IhqIkcCU1SXmCxNyQLzZGKPjd1o01iWrI+j83Jlva5gJcJSBKfNjG5fin79CF7apFRQOp3MTiK1K0NiHb4xOMnQwpgi17GKMDOiI4UckFRWfk7uDbQyPWh3o46uJAuNBuqKQLdnXZRtdL03l5NwlAspNnAVhow4ywaGMq8JaAnYyAFFQzXMlcdCO2mJPYMI0ubG8Ks6KXNhex3KNkdBW7dtPYtP6vAWQsNWy8iBmHEvYBj/KEPq3VvEdwV0ci3hE7/MYfSq7GpHm+xyQqfNrEffhQHPM1fo3J+s0ZZamIXP6skZseF8MtPXee6zV2AFAsQVrjgocbBwugYhU1q/NEa3AjHUeYIepzxw9+HB2ZigbJP/cbl1EWasWF8GXOoX3ZAzqb452ZqTBEP5Qvbl/AtOK7nWGNEfyaNT9+aQWpGkJjf9dZ9pikaWP6GPlLL6LUgwYzLiCUeV3KYR3u8/6c3pQWxwtFmEfF/0Unr7kpzHTpTrbEpWjVsY4N1QaLD/QYAkd1jQIrTQpk9ZBZ6gmgVBPcOPeTG1Xkva1JKJXqCGOLSz3amIwDMWW9Ipm+3SPtlYnMsMia8//iFMdIz/FXdTRKVn8K2HzexneYG8F4VGV2pAm/uXFCZc4WfEQkjJLAIe2BFfdiGh3VFeoN/N3oGE5oIVQfO3NrmdaMo88/mX5Ezy0aULvWHLra4Q4Y4NUf931tWm0aSSArpUCa84z2e4jLnpHq7H7VAxx3uryl904Qp4MhZ8WHrnMCeai7wNG3NgLy7BKHfgY9pdUpwJh5EBLhuiW7rt528I41ar+GDy9QB1Vysgpok56aJqaixDEw13LruIHPU/ol+wq4qEjhE4GcU5et/cQ3R43vTb0PF+XtuPfDf3bkMynurRd/WDKc/Nc/vW3o5U2avvaI/ZfieabaGswyE1cjT2/NWcJuWt8YEi8I8kqgHNjGKngptYmjbGAUWPEgy4unfsWd1t4iZzS185bq7tfssGIRmeyC3Ri+1KLEijSkgFO6aDXwvOCDaUGvxG+4zMWT9JXhLpegAMGYbeVy3flX14RTW1nNAEFhA392wvIw+EXIF4sEWIT8CptDANRj2C7N6FYDRhY1ev0NP2YeIbnJoGIqSBeSipczkt4w3mDjQjubpDOgjiejXsztYcnjUz93G+uS/34EUVgGZQAQeK030SV8IXp7DXwp2fz2cDDtkw2EensUw6eihNWqJ+puVvcYl2tEBYz7HHENjTUC1mqqMg29mPsn8KfJCBVgqJAIhbKQe4zvI5eApE+/HJMkotERKRo0WrWXiW6wNW9smfIN28rb359aF2QHFzA2OamIa88jE/3GzPOY0kLbecnk3t++MsQ8S5LStKwqB/iK8ZtTZ7QacfjLNVrW1CAzYubipqnq7dWhYIUjVSqgry5/oQQw9M8hEsjWzvXzp8vzxbYCfWRoasqdJhRXQsOYY3guPmy1E7cAgPKZNCMlHqvKuCMmYlkpp3EC77Yp7RC9pEwdS3QbN9iEU+DqS+xsQnJB1RKb9/zHafbZL8TGJu6Q5gYe1hF+IXs72eV13qWs4J5IPFQ0NGznXnBnSlDbanI4DG8E0dRMAPzfqoNxllqcoEuMF98ITQiDUOlnTB0XrFP7/tdw7i8vs1oin5dQg8ny6TJrII/4KkTQhFDm8t/v6N3+1X3iRYuG1IyL+TZ2pMFwhz1rsJAtrGxDcv5FzqznuHH7Y/EpQOSSQut5xTHl5TWp3t4ETSKQsw2FtQ35Cz7MfX9S8BZyAA8/izLCxamwgDF6TZytlkll74fOEAi9QntM3Dhe7L6YcraKfq6LWl+P/PI9D4QtFCY3ubPM0KibyWc/LNUTwC12V236vXvcxAOi5d2BU42ZS7N2ycidHQg0EcxOXM8AV/N3ydo6i5IHS7aSh8NhxpsAKNV6yEg7ydWwGdG3f42fgvFPtbaMMkQRJ/Y0jAL77YfV/ekShsSdz4kc8G2ktc5G7tTEyyGTO5C/aC6jQJS/IUbvBfLamp+7kxOHtCbjZsRARcEEjplFq1WsV+V3pgk+KYEwWNVaqnZUrZxQjgTMPn4QwZbHuk1CW68tSoa9deOD0s1HnqX816U0dmPElSYOfBQ8pjDNTAkx3ovxTPAysqyFAa55bGXp2HunBPI0o3a8hdQyrJbiY8orJS1aPvbvjkIK3WSt4zZ4gtDkd7Rba5qszTRbTu4kTRqwMY7fV1AcvX2unq4xg5RzGWCLwE73n1b71DT8dQQc27J/SIcUVnncU2oRD1BID2x+XOZPj1THQ4P9CsW2NiIZGwbt06YOiemhvSlYOgBEnTczbAUGGHcUofgzFkWkLi3SaWi2VjRF4Dktx35lFYI7WWf0YDYphtMUmZg+lCaHlngMfvh+9DcybchfTVDwH1tvMBRYz+CYyktMZYSog65GKL5GN0iDdlG0eGNr8qD9PIn5Ue5q3IViCjjaovo/p/7NQq3uPD7Z5aXoGdIsQM8T+nSKNrr5dkd5JP0AU9wvIOZ7zrsdT4fZOUx39OfCKZNujYgmAK1GaO6a5fLbWstEUBq4Fi/0pwU9EDDf8nbP+vmrHoZn2GjtFTjAC7YVZfY+4juht4AKS/88jSnggX0Ucjpt6cVQOYKuVJgQaZax9v3+8lxcO/mOa42smixXiU48s/3UYO/uCKggNoFTvl5I0saHP3vNDTXslHXBpwUdJxuK+i9WZ1K5gm/gY9Qm60ePdSa/pNrxsDN/DsMLlR3YC1e5GrJS8f48yBgNRNsVpgJ7lh414agoKtNpQXRcItmte9/FZCk+Uv/8HF7g9RlwLUJr8UqG6UoyO0s2/8sS7C5+142839yEHbMmB5KB9uBipfNh/m6iyo1IqNon7S2NFqaQTtXGvOXVdqctuFJCPYrSa6V8zzP2PtDEabW/bdvtxx+sSagmaGXqIZjMChGvLc74B1BzlteQJxIER22WLWdreRLxMrUkjR6fUgmrapV6hrxqW2DTs2Gounua+22VlQNbLwXREYDVfBF/nYvVVr8IaZ8QeXAUuuyduIOPHU32fDXrXmIYWNbBHKeHNDKxjAiI9ecF6cKF7//8e9tAUn1NQvwpl7brL/7mgsC0lGQlUTbsxk8p8Sj2faH+3Lqumb5OFRcDfTIcxtUnsMyzInOT50H/Y+bjZSgBF8AoQ+uiztxK667bqGAit7LXrC+UWo5CNEfFJJaK6RMUaviOX+isjPk0rvPQA+dTWZC/rbY6jvXv+cE9iXZYMXvpR753l6DxTh8nIpm19CwQewpmhcjzLjyhqd9ZH9Ju+eEmb9x/p+rq1h7L4LI3wB09+FNFki3T9kxdPhlROTRKjmGf4fmf1QotbKCHW1ZfoWDZePVKXs4m49PTbKs1gfbnaN/CkJfvXURmoxXqLyVkrFPAqJLK/Qq5YTMEpsUGQtbmF7mClKeicZtrbaF+QowNCjYlWSqIQf3bCUVxBSHXQY6btuJLffGDAmtVRK1JW1yXXmzGSfH9iaINSMeUd+aTGjYkjPuYCfo2MJY8h0SsKgpScImUlAsRJF9RwEx4HL7EzcuKvdyXrwIuuIgC1SolUjUvFgbaFG+BLXzH5XwPxRwyITWD0PUDmZiwsRmDuxPRfuLZzWO6U12g5C05+fZtw0Dv622u+7MdjJGrBE4YUKN34ilr6NKDIUalioomw4kCs950yQssIaGHSii38TqW5L6qLrqS8IzISTXr33sfEwWSmR+TN4s3OTNKsYaB3+liePdetsWRX/3InFEbiSkIjyP+bFlPom/cShYO9ecU8ssYJdoKnUQl8wB3j2C4xOYyCQzYJf9U8erqnUh++nyiNLPoqjNpjn6DhOX3W8PNECr+1//wtm1SEf+scZq9oUoPTsEwftuB43V1jdGhdAb4BsqKCLdWFuQVEKorqo+OkmWneZHfPEUomARdghuLDWt+Xxk9Y94iOZlm79xuFuVaKnw6+v8gentsda60LecL35VrC4rSXxLe+cnoiTpnYa70jeTPDDXHmmK/ZtmrN5FifxQhwDVVEy2nbM0PLffPf7c1hGmvOTnZMCYwyKBzS/yrr20+teNPOy280z1JymkgufZRMMq0Wr69KnppVn8jdOKx11uFPsBrlvfnmfeDmnnqU2nhBdp+VIDSF4qs0xP3dO9NOaaiQYmb75Dbhf7jGk70mEurN9/thjzGn2EoKGtBpg8yfDvu4DGDm9fVrJGJ1QyripwAVUJjVrtUqdt9IMuSbyAQpmATiiKSZLJZ2vucXxhDtSGUXrI7n94ScNbuY7gaaibtZvSg23L3wtQdgh1XODnuePIPUgpAuPU4R2S/TO4lVolQ0APkwNDG9UFJb/04t/SQnVCeAzM+IXE+Q/5uVf3vfzzqzEDWKJqImNv9SYL/Fnrhc3sZmrI6l+mLoN8U9LxjDS10EQHzJEtNn+hkbyT9Sp3vql8dZsy+AzRopSvS0/TrKARBvGfotyQzfOwquoazfobHriP/KWmWGctGA60VFIMmmZXrzw25bwpMy1mVZtXPZQO/BDYAhP7IKKY/io6jCjTcuLnmqojQhqFBqph4oOSIpg2bPbNlSnmwbwPhGXNzEQn+OF37mpvS7LR6nEr/8RTOke2VzN2aW332OuO11f+DYy7/H3CFzMY0aHKHqMc5Z5mAcoA2QJBEs/LiirPHEOtG2cz08QSrQ7rClKLWvEHtB4sxNrXCnCyfGJ7pdvOwxdymwRrKaB6FU55XtoFJQ/btK4dHxsSmLFUVDGK61bHUe6wbQG8vLZMOEyBcdF+vtociPleCtjr+OWlKCwdfqdZ3iYO/7Bh35L383cBjXnNazlpHgoXCOKkQ6Do2E5+xjfQlKmGx2gLDNm85nBilaBdq/z/E8M0BYT9UIlAIlA66n4fJrdWjWtWxzTVR2iP7mne9yW4KhyKr+arJs4VLnY9U05OqT2H8RdON1oQCYIUiJZzi9zit3XHNBG2DFlXcnk00EIkYFz++JcnU7aAw1Pl0421og0tGdwKYjNxLUVkFcvMBZUZgOffD/iYKC7JBWoymytgJEOa2cz+e5LS+DicILPagJbdntwS44b9xVY0eQzxL3vFMt9ZGstvu53ENE9ZNEpvz4BJTxP8SLfkvPZotKfSvLNxXZKmXaYMXA5Ht3iZNF8dkAjmq+jBecy/7jJAKCb4uw1hIfmDQEq8ADrlIFn5FQOwWY/c+euyS4G8DH4S0YuVRBR3q6rtdgYT44L7Trl91U23EhPxYMtDQWuo4oxQZKG/UWcg/BN2NL+norFDNMc4SFZZhudEm6rSfH9dPBBCZsvzu0v45Ark3hVpZpiK1bdHF6gRIClZK1fbEZR0yOgtFul5x2PioBtoS3N9AZGfa30IRIxZ7+GrBIVB9rDYZxl4SiUe0B8WqaBGtLf2sEB1BF76nk3JC/1RHxLLLzxdMUJnUUl4RrKh++6UTeemfZlQ0qJY7KBDKRhofV+iuenbMw4QLesPrJlTnOABBb4oDi/gM54N4RG6ore+8a/SwFlUA1TmSJ2YWaYQ90YmOZPnenwK+DDIU/OAQBfugfIaD2CTmHVDFoPjlmQjWBtRqJre1NHoULd8g2MVbmorakwDCByBZYxPPsnvJlJhbeOT//RYmQWqgEW29IAVyr4UjjTElB4GAujhOkg6AajYtW3aJYSMfXyp+vHNb8ZBs0cJfLC+VWhqNyyjLJ5Nac/HxQAmzya2s8uyGgj/qkLaTaNjSD2KHDElxE6dTSgvRbGiz8dMLSDy1O+ygz7djeYeDEsAtLcPHzko+WrL/rgKfRdlzzLL59uK+A6u+wX8KJCbJvG/C32AxR7NRrUtvqIldvegm8hx++0isodXSDTRFveoLiqf5XuQwetdvieNQwUuZOuvj9puX36/B51C2ftfgu8JD1eLnoXIswCrou2P4oHjSV1hGoG+PFtja5PP3tCaiSv4b69skEKxAsudymVrfoQL4BiLKxlhtB/S504pGRp5HC2UOViok7dBvv9WDrYtpo4poDRIuiBEl5uwiCGOuaVvMxOUBrMpTHLRUley/CaEn8sx0auoZKst5fPQDlLk9wNwDu6ui0gBJGbO+jzlsrRc33+1LKp7mlF5f87N8h4WG7VTz9h37Rt85wmGK2kqb6aGYOIZTrV3Y4cdI98HG9lsCwo96hBS+8nUekWqCiWNv4d+OcnU2WkyJSMYEUiwl3u5pbGITFov6pbrkaAO1TwZQ80Ts53z6H+uU8yrp3hRaL6GJyLIMd5clxCxqyaecgGutDv+E8aYgPTExxZjWpMJvsySw/wEMM8vSRnlH1BXKzBc46LhERpQNOEztnOkczJM8EH7Bxkc38/DWcv+M4A5sRMPfGcwBzfNEuQQh4zocTEehKAbKZlHpaVa3NPDdJ75tHAGkBTQdosD2yU/UkryRkLuDI/94SnscZv2fcyv7+N8/ef7UOGiW9kqGk8vTn5mOteiKd0Ha+AMACi4aEVI+8/UqjN0KtBgdeA1NKu7Up30Lyfnx9yV6DcLNBeaLFLux7ecyXZ+y6qquHpu2pFf+N29oupvVTDtdo2a9B24djWLoLLnHUu//7QpXiL7yjECFiDV4Gpq+zPW9i7VFJzrtYrk8in91PmA65Ef4JjnFGRKjMlUvRASanA1WBlNl3CBA7+A/3lSoO1PoR0ZNcFKcLwJYPTyJkjT2ryPQ0locXcQHmrs9A5Ry1Bes3Z0ss1fl48DQujzataHdUC3nAD0+s5aE7O1oOYfJlfIzc+ZBz2awsmoAfl66j0PuGDrOveZCpiyOsUjpxkcGHPcaPQbDI=","categories":[{"name":"随笔","slug":"随笔","permalink":"https://orzyt.cn/categories/随笔/"}],"tags":[{"name":"研究生学习","slug":"研究生学习","permalink":"https://orzyt.cn/tags/研究生学习/"}]},{"title":"浅谈支持向量机的推导","slug":"svm","date":"2018-12-19T16:00:00.000Z","updated":"2019-03-13T11:40:08.825Z","comments":true,"path":"posts/svm/","link":"","permalink":"https://orzyt.cn/posts/svm/","excerpt":"","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"支持向量机","slug":"支持向量机","permalink":"https://orzyt.cn/tags/支持向量机/"},{"name":"SVM","slug":"SVM","permalink":"https://orzyt.cn/tags/SVM/"}]},{"title":"LeetCode575 Distribute Candies","slug":"leetcode575-distribute-candies","date":"2018-01-14T05:21:28.000Z","updated":"2019-02-08T10:26:00.494Z","comments":true,"path":"posts/leetcode575-distribute-candies/","link":"","permalink":"https://orzyt.cn/posts/leetcode575-distribute-candies/","excerpt":"","text":"描述Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 样例123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. 1234Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. The sister has two different kinds of candies, the brother has only one kind of candies. 思路有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少 首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。 最终的答案为二者取最小值。 代码12345678class Solution &#123;public: int distributeCandies(vector&lt;int&gt;&amp; candies) &#123; unordered_map&lt;int, int&gt; count; for(int x: candies) count[x]++; return min(count.size(), candies.size() / 2); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希表","slug":"哈希表","permalink":"https://orzyt.cn/tags/哈希表/"}]},{"title":"LeetCode566 Reshape the Matrix","slug":"leetcode566-reshape-the-matrix","date":"2018-01-14T05:03:19.000Z","updated":"2019-02-08T10:26:00.386Z","comments":true,"path":"posts/leetcode566-reshape-the-matrix/","link":"","permalink":"https://orzyt.cn/posts/leetcode566-reshape-the-matrix/","excerpt":"","text":"描述In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Note: The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. 样例123456789Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. 12345678910Input: nums = [[1,2], [3,4]]r = 2, c = 4Output: [[1,2], [3,4]]Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix. 思路给定一个二维数组，模拟 MATLAB 中 reshape 函数的操作，若无法完成，则输出原数组 题中要求元素以row-traversing顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \\% c$) 利用这一关系，可以得到从原数组$nums$（$n$行$m$列）reshape成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \\% c] = nums[i / m][i \\% m]$ 代码123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123; int n = nums.size(), m = nums[0].size(); // 元素数量不匹配，reshape失败 if (n * m != r * c) return nums; // 初始化二维vector vector&lt;vector&lt;int&gt;&gt; vec(r, vector&lt;int&gt;(c)); for (int i = 0; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m]; return vec; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode563 Binary Tree Tilt","slug":"leetcode563-binary-tree-tilt","date":"2018-01-14T04:51:07.000Z","updated":"2019-02-08T10:26:00.486Z","comments":true,"path":"posts/leetcode563-binary-tree-tilt/","link":"","permalink":"https://orzyt.cn/posts/leetcode563-binary-tree-tilt/","excerpt":"描述Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt.","text":"描述Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. Note: The sum of node values in any subtree won’t exceed the range of 32-bit integer. All the tilt values won’t exceed the range of 32-bit integer. 样例12345678910Input: 1 / \\ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 思路求二叉树的倾斜度。 一个节点的倾斜度是指：该节点 左子树所有节点值之和 与 右子树所有节点值之和 的 绝对差值 一棵树的倾斜度是指：该棵树所有节点的倾斜度之和 对二叉树dfs一遍即可求出答案 代码1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int ans = 0; // 以root为根的子树所有节点值之和 int dfs(TreeNode* root) &#123; if (root == NULL) return 0; int lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right); // 添加节点root的倾斜度 ans += abs(lsum - rsum); return lsum + rsum + root-&gt;val; &#125; int findTilt(TreeNode* root) &#123; dfs(root); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://orzyt.cn/tags/二叉树/"}]},{"title":"LeetCode561 Array Partition I","slug":"leetcode561-array-partition-i","date":"2018-01-14T04:31:32.000Z","updated":"2019-02-08T10:26:00.398Z","comments":true,"path":"posts/leetcode561-array-partition-i/","link":"","permalink":"https://orzyt.cn/posts/leetcode561-array-partition-i/","excerpt":"描述Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000].","text":"描述Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 样例123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). 思路将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。 贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。 可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。 代码123456789class Solution &#123;public: int arrayPairSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int ans = 0; for (int i = 0; i &lt; nums.size(); i += 2) ans += nums[i]; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"贪心","slug":"贪心","permalink":"https://orzyt.cn/tags/贪心/"},{"name":"greedy","slug":"greedy","permalink":"https://orzyt.cn/tags/greedy/"}]},{"title":"LeetCode557 Reverse Words in a String III","slug":"leetcode557-reverse-words-in-a-string-iii","date":"2018-01-14T04:17:22.000Z","updated":"2019-02-08T10:26:00.278Z","comments":true,"path":"posts/leetcode557-reverse-words-in-a-string-iii/","link":"","permalink":"https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/","excerpt":"描述Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Note: In the string, each word is separated by single space and there will not be any extra space in the string.","text":"描述Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Note: In the string, each word is separated by single space and there will not be any extra space in the string. 样例1234Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 思路将句子中的单词翻转（单词之间以空格隔开） 模拟一下，记录每个单词的起始位置和长度，然后翻转即可 代码12345678910111213141516171819202122class Solution &#123;public: // 字符串翻转函数 string rev(string s) &#123; int l = 0, r = s.size() - 1; while (l &lt; r) swap(s[l++], s[r--]); return s; &#125; string reverseWords(string s) &#123; string str; // 变量p记录单词起始位置 for (int i = 0, p = 0; i &lt; s.size(); ++i) &#123; if (s[i] == ' ') &#123; str += rev(s.substr(p, i - p)) + ' '; p = i + 1; &#125; // 特判字符串末尾 if (i == s.size() - 1) str += rev(s.substr(p)); &#125; return str; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"ssh本地端口转发的应用","slug":"ssh-port-forwarding","date":"2018-01-13T07:34:17.000Z","updated":"2019-02-28T11:11:15.375Z","comments":true,"path":"posts/ssh-port-forwarding/","link":"","permalink":"https://orzyt.cn/posts/ssh-port-forwarding/","excerpt":"SSH有三种端口转发模式，本地端口转发(Local Port Forwarding)，远程端口转发(Remote Port Forwarding)以及动态端口转发(Dynamic Port Forwarding)。本文只简单介绍本地端口转发，用于实现本机访问远程服务器上的jupyter notebook、TensorBoard等服务。","text":"SSH有三种端口转发模式，本地端口转发(Local Port Forwarding)，远程端口转发(Remote Port Forwarding)以及动态端口转发(Dynamic Port Forwarding)。本文只简单介绍本地端口转发，用于实现本机访问远程服务器上的jupyter notebook、TensorBoard等服务。 什么是本地端口转发？所谓本地端口转发，就是将发送到本地端口的请求，转发到目标端口。这样，就可以通过访问本地端口，来访问目标端口的服务。 12345678$ ssh -hunknown option -- husage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command] 需要用到的命令是ssh -L address user@hostname 其中，address的具体语法为 [bind_address:]port:host:hostport ，即 [本地主机地址:]本地端口:目标地址:目标端口 应用场景 — 以 jupyter notebook 为例由于服务器上一般是没有安装桌面的，所以像jupyter notebook、TensorBoard等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。 首先，在服务器上运行jupyter notebook 会发现有一个黄色的 warning: No web browser found: could not locate runnable browser. (说明服务器上是无法打开的) 然后，我们记下端口号（8008）以及 token（链接中?token=后面一长串的字符，用于登录认证） 接着，执行以下命令进行本地端口转发 1234# f: 后台执行命令# N: 不进行实际连接，而仅做端口转发# 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress 最后，在本机打开地址localhost:本地端口号 输入token后即可访问服务器上的 jupyter notebook","categories":[{"name":"教程","slug":"教程","permalink":"https://orzyt.cn/categories/教程/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://orzyt.cn/tags/ssh/"},{"name":"端口转发","slug":"端口转发","permalink":"https://orzyt.cn/tags/端口转发/"},{"name":"jupyter notebook","slug":"jupyter-notebook","permalink":"https://orzyt.cn/tags/jupyter-notebook/"},{"name":"tensorboard","slug":"tensorboard","permalink":"https://orzyt.cn/tags/tensorboard/"}]},{"title":"简化ssh连接服务器流程","slug":"ssh-login","date":"2018-01-13T03:02:26.000Z","updated":"2019-02-28T11:11:29.583Z","comments":true,"path":"posts/ssh-login/","link":"","permalink":"https://orzyt.cn/posts/ssh-login/","excerpt":"登录远程服务器一般采用ssh（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。","text":"登录远程服务器一般采用ssh（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。 生成 ssh key在本机的终端中执行命令 ssh-keygen ，然后根据提示操作即可在目录（默认为~/.ssh）中生成id_rsa（私钥） 和 id_rsa.pub（公钥）文件。 添加 ssh config 文件根据下列内容，修改（或新建）本机中的~/.ssh/config 文件 1234Host fastlogin # 随便取个名字，用于登录 HostName xxx.xxx.xxx.xxx # 主机地址 User username # 用户名 Port 1234 # 端口号 向服务器中添加公钥12# [此命令在本机中执行]：将公钥文件上传到服务器的用户目录scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/ 12# [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 快速登录配置好之后，只需执行下列命令即可快速登录服务器 12# fastlogin 为之前在ssh config中定义的名字ssh fastlogin scp 远程拷贝文件现在，如果想要复制本机的文件到服务器上，可以更加简便 1scp 本机源地址 fastlogin:服务器目标地址","categories":[{"name":"教程","slug":"教程","permalink":"https://orzyt.cn/categories/教程/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://orzyt.cn/tags/ssh/"},{"name":"scp","slug":"scp","permalink":"https://orzyt.cn/tags/scp/"}]},{"title":"常用软件更换国内镜像源","slug":"change-mirrors","date":"2018-01-13T02:45:51.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/change-mirrors/","link":"","permalink":"https://orzyt.cn/posts/change-mirrors/","excerpt":"由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。 以下基于Ubuntu系统介绍相应的换源方式。 pip修改（或新建）文件：~/.pip/pip.conf，添加以下内容： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple","text":"由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。 以下基于Ubuntu系统介绍相应的换源方式。 pip修改（或新建）文件：~/.pip/pip.conf，添加以下内容： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple npm在终端中运行下列命令： 1npm config set registry https://registry.npm.taobao.org anaconda在终端中运行下列命令： 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes","categories":[{"name":"教程","slug":"教程","permalink":"https://orzyt.cn/categories/教程/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://orzyt.cn/tags/pip/"},{"name":"npm","slug":"npm","permalink":"https://orzyt.cn/tags/npm/"},{"name":"anaconda","slug":"anaconda","permalink":"https://orzyt.cn/tags/anaconda/"},{"name":"镜像源","slug":"镜像源","permalink":"https://orzyt.cn/tags/镜像源/"}]},{"title":"LeetCode543 Diameter of Binary Tree","slug":"leetcode543-diameter-of-binary-tree","date":"2018-01-09T05:14:50.000Z","updated":"2019-02-08T10:26:00.262Z","comments":true,"path":"posts/leetcode543-diameter-of-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode543-diameter-of-binary-tree/","excerpt":"描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them.","text":"描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. 样例12345678910Input:Given a binary tree 1 / \\ 2 3 / \\ 4 5 Output:Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. 思路求二叉树的直径 普通树的直径需要两遍DFS，而二叉树因为结构特殊只需一次DFS即可 假设二叉树中共有$n$个节点，第$i$个节点的左子树树高为$l_i$，右子树树高为$r_i$，则以第$i$个节点为子树的直径$d_i = l_i + r_i $，最终整棵二叉树的直径$D = max\\{d_i | i=1..n\\}$ 代码12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: int ans;public: int dfs(TreeNode* u, int dep) &#123; if (u == NULL) return dep - 1; // 递归求解左子树深度及右子树深度 int l = dfs(u-&gt;left, dep + 1), r = dfs(u-&gt;right, dep + 1); // 因为当前深度是相对于root来说的，如果相对于u来说，其左右子树树高需要减去u的深度 // 即 d = l - dep + r - dep = l + r - 2 * dep ans = max(ans, l + r - 2 * dep); return max(l, r); &#125; int diameterOfBinaryTree(TreeNode* root) &#123; ans = 0; dfs(root, 0); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode541 Reverse String II","slug":"leetcode541-reverse-string-ii","date":"2018-01-09T05:04:49.000Z","updated":"2019-02-08T10:26:00.358Z","comments":true,"path":"posts/leetcode541-reverse-string-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode541-reverse-string-ii/","excerpt":"描述Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000]","text":"描述Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] 样例12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; 思路给一个字符串和一个整数$k$，需要每$2k$个字符就把前$k$个字符翻转，如果少于$k$个字符就都翻转，如果多等于$k$个而于少于$2k$个字符，就翻转前$k$个而剩下的不变。 按题意模拟一下即可… 代码1234567891011class Solution &#123;public: void rev(string&amp; s, int l, int r) &#123; while (l &lt; r) swap(s[l++], s[r--]); &#125; string reverseStr(string s, int k) &#123; int siz = s.size(); for (int i = 0; i &lt; siz; i += 2*k) rev(s, i, min(i + k - 1, siz - 1)); return s; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode530 Minimum Absolute Difference in BST","slug":"leetcode530-minimum-absolute-difference-in-bst","date":"2018-01-09T04:50:30.000Z","updated":"2019-02-08T10:26:00.190Z","comments":true,"path":"posts/leetcode530-minimum-absolute-difference-in-bst/","link":"","permalink":"https://orzyt.cn/posts/leetcode530-minimum-absolute-difference-in-bst/","excerpt":"描述Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.","text":"描述Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes. 样例12345678910111213Input: 1 \\ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). 思路求节点为非负整数的二叉搜索树中，任意两个节点绝对差值的最小值。 根据二叉搜索树的性质，对其进行中序遍历即可得到一个有序（从小到大）的结果。由于结果是有序的，因此只需要考虑相邻两个元素之间的差值来获得最小值。 比如对如下的二叉搜索树进行中序遍历，得到 [3, 5, 7, 8, 10] 12345 5 / \\3 8 / \\ 7 10 然后答案即为相邻元素的最小差值，ans = min {5-3, 7-5, 8-7, 10-8} = 1 代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: int ans, pre;public: void inOrder(TreeNode* root) &#123; if (root == NULL) return ; inOrder(root-&gt;left); ans = min(ans, root-&gt;val - pre); pre = root-&gt;val; inOrder(root-&gt;right); &#125; int getMinimumDifference(TreeNode* root) &#123; ans = INT_MAX; pre = -0x3f3f3f3f; // 记录中序遍历时当前节点的前驱 inOrder(root); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"BST","slug":"BST","permalink":"https://orzyt.cn/tags/BST/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://orzyt.cn/tags/二叉搜索树/"}]},{"title":"LeetCode155 Min Stack","slug":"leetcode155-min-stack","date":"2018-01-02T04:47:09.000Z","updated":"2019-02-08T10:26:00.438Z","comments":true,"path":"posts/leetcode155-min-stack/","link":"","permalink":"https://orzyt.cn/posts/leetcode155-min-stack/","excerpt":"描述Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. getMin() — Retrieve the minimum element in the stack.","text":"描述Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. getMin() — Retrieve the minimum element in the stack. 样例12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 思路模拟一个栈，在常数时间内支持进栈push、出栈pop、输出栈顶元素top、输出栈内最小元素getMin四种操作 我们知道，普通的栈对于前三种操作已经是常数时间了，但是如何实现常数时间内找到栈内最小元素呢？ 可能一开始会想，不是可以$\\mathcal{O}(1)$维护一个栈内最小元素的下标吗？getMin的时候直接根据下标输出不就好了 emm…是这样的没错。但是，一旦最小元素出栈后，我们就得找出栈内第二小元素来更新下标 这个该怎么处理呢，肯定不能把栈遍历一遍啊（时间复杂度不满足要求… 其实，只要维护一个单调栈即可（非严格单调递减），单调栈的栈顶就是原栈中最小的元素 其中stack A为原栈，stack B为辅助栈，# 表示栈底方向 1234567891011121314151617181920stack A: # | 10 | // 元素10进栈stack B: # | 10 | // 当前最小元素为10stack A: # | 10 | 12 | // 元素12进栈stack B: # | 10 | // 由于维护的是单调递减栈，当前最小元素仍然为10stack A: # | 10 | 12 | 9 | // 元素9进栈stack B: # | 10 | 9 | // 满足单调栈，当前最小元素更新为9stack A: # | 10 | 12 | 9 | 14 | // 元素14进栈stack B: # | 10 | 9 | // 不满足单调栈，当前最小元素仍为9stack A: # | 10 | 12 | 9 | // 元素14出栈stack B: # | 10 | 9 | // 不影响辅助栈，当前最小元素仍为9stack A: # | 10 | 12 | // 元素9出栈stack B: # | 10 | // 辅助栈栈顶的9同时出栈，当前最小元素更新为10stack A: # | 10 | // 元素12出栈stack B: # | 10 | // 不影响辅助栈，当前最小元素仍为10 代码12345678910111213141516171819202122232425262728293031323334353637383940class MinStack &#123;private: stack&lt;int&gt; a, b;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; // 原栈进栈的同时，看满不满足辅助栈的单调性质 if (b.empty() || x &lt;= getMin()) b.push(x); a.push(x); &#125; void pop() &#123; // 原栈出栈的同时，看影不影响辅助栈的栈顶 if (a.top() == getMin()) b.pop(); a.pop(); &#125; int top() &#123; // 输出原栈的栈顶元素 return a.top(); &#125; int getMin() &#123; // 输出辅助栈栈顶元素，即为原栈中的最小元素 return b.top(); &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"栈","slug":"栈","permalink":"https://orzyt.cn/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"https://orzyt.cn/tags/单调栈/"}]},{"title":"LeetCode Algorithms' Solutions","slug":"leetcode-algorithms-solutions","date":"2017-12-31T16:00:00.000Z","updated":"2019-02-08T10:07:01.637Z","comments":true,"path":"posts/leetcode-algorithms-solutions/","link":"","permalink":"https://orzyt.cn/posts/leetcode-algorithms-solutions/","excerpt":"“ Talk is cheap, show me the code! ”— Linus Torvalds 如果题解中有谬误或疑问的地方，欢迎大家留言交流！","text":"“ Talk is cheap, show me the code! ”— Linus Torvalds 如果题解中有谬误或疑问的地方，欢迎大家留言交流！ # Title Acceptance Difficulty 1 Two Sum 40.2% 1Easy 2 Add Two Numbers 30.4% 2Medium 7 Reverse Integer 25.1% 1Easy 8 String to Integer (atoi) 14.4% 2Medium 9 Palindrome Number 41.5% 1Easy 13 Roman to Integer 51.3% 1Easy 20 Valid Parentheses 35.7% 1Easy 21 Merge Two Sorted Lists 45.4% 1Easy 27 Remove Element 43.3% 1Easy 28 Implement strStr() 31.0% 1Easy 35 Search Insert Position 40.4% 1Easy 38 Count and Say 39.2% 1Easy 50 Pow(x, n) 27.4% 2Medium 53 Maximum Subarray 42.5% 1Easy 69 Sqrt(x) 30.4% 1Easy 70 Climbing Stairs 43.1% 1Easy 83 Remove Duplicates from Sorted List 41.7% 1Easy 84 Largest Rectangle in Histogram 30.0% 3Hard 100 Same Tree 49.2% 1Easy 101 Symmetric Tree 42.5% 1Easy 102 Binary Tree Level Order Traversal 46.6% 2Medium 104 Maximum Depth of Binary Tree 58.8% 1Easy 107 Binary Tree Level Order Traversal II 45.3% 1Easy 108 Convert Sorted Array to Binary Search Tree 48.8% 1Easy 112 Path Sum 36.8% 1Easy 118 Pascal’s Triangle 44.1% 1Easy 119 Pascal’s Triangle II 41.6% 1Easy 121 Best Time to Buy and Sell Stock 45.9% 1Easy 122 Best Time to Buy and Sell Stock II 50.6% 1Easy 125 Valid Palindrome 29.9% 1Easy 136 Single Number 58.6% 1Easy 153 Find Minimum in Rotated Sorted Array 42.3% 2Medium 154 Find Minimum in Rotated Sorted Array II 38.8% 3Hard 155 Min Stack 35.2% 1Easy 167 Two Sum II - Input array is sorted 48.9% 1Easy 168 Excel Sheet Column Title 28.4% 1Easy 169 Majority Element 51.2% 1Easy 171 Excel Sheet Column Number 50.7% 1Easy 172 Factorial Trailing Zeroes 37.2% 1Easy 189 Rotate Array 28.6% 1Easy 190 Reverse Bits 29.9% 1Easy 191 Number of 1 Bits 41.7% 1Easy 202 Happy Number 44.1% 1Easy 204 Count Primes 28.0% 1Easy 206 Reverse Linked List 52.2% 1Easy 217 Contains Duplicate 50.5% 1Easy 226 Invert Binary Tree 56.7% 1Easy 231 Power of Two 41.6% 1Easy 237 Delete Node in a Linked List 51.6% 1Easy 242 Valid Anagram 50.6% 1Easy 258 Add Digits 53.4% 1Easy 263 Ugly Number 40.3% 1Easy 264 Ugly Number II 35.4% 2Medium 268 Missing Number 47.3% 1Easy 278 First Bad Version 28.6% 1Easy 283 Move Zeroes 53.4% 1Easy 292 Nim Game 55.4% 1Easy 303 Range Sum Query - Immutable 36.2% 1Easy 307 Range Sum Query - Mutable 27.1% 2Medium 326 Power of Three 41.3% 1Easy 338 Counting Bits 63.8% 2Medium 342 Power of Four 39.9% 1Easy 344 Reverse String 62.6% 1Easy 345 Reverse Vowels of a String 40.7% 1Easy 349 Intersection of Two Arrays 52.4% 1Easy 350 Intersection of Two Arrays II 46.5% 1Easy 367 Valid Perfect Square 39.3% 1Easy 371 Sum of Two Integers 51.4% 1Easy 383 Ransom Note 49.1% 1Easy 387 First Unique Character in a String 48.8% 1Easy 389 Find the Difference 52.6% 1Easy 401 Binary Watch 45.0% 1Easy 404 Sum of Left Leaves 48.6% 1Easy 405 Convert a Number to Hexadecimal 41.6% 1Easy 409 Longest Palindrome 47.3% 1Easy 412 Fizz Buzz 58.7% 1Easy 413 Arithmetic Slices 55.1% 2Medium 414 Third Maximum Number 28.6% 1Easy 415 Add Strings 42.9% 1Easy 419 Battleships in a Board 65.0% 2Medium 437 Path Sum III 41.7% 1Easy 442 Find All Duplicates in an Array 59.6% 2Medium 447 Number of Boomerangs 48.9% 1Easy 448 Find All Numbers Disappeared in an Array 52.5% 1Easy 451 Sort Characters By Frequency 54.6% 2Medium 453 Minimum Moves to Equal Array Elements 48.9% 1Easy 455 Assign Cookies 48.0% 1Easy 459 Repeated Substring Pattern 39.2% 1Easy 461 Hamming Distance 69.9% 1Easy 463 Island Perimeter 60.0% 1Easy 476 Number Complement 62.0% 1Easy 479 Largest Palindrome Product 27.0% 3Hard 485 Max Consecutive Ones 54.4% 1Easy 492 Construct the Rectangle 48.3% 1Easy 496 Next Greater Element I 58.4% 1Easy 500 Keyboard Row 61.5% 1Easy 501 Find Mode in Binary Search Tree 38.8% 1Easy 504 Base 7 44.5% 1Easy 506 Relative Ranks 47.8% 1Easy 513 Find Bottom Left Tree Value 57.8% 2Medium 520 Detect Capital 52.2% 1Easy 530 Minimum Absolute Difference in BST 49.5% 1Easy 541 Reverse String II 44.9% 1Easy 543 Diameter of Binary Tree 46.1% 1Easy 557 Reverse Words in a String III 62.9% 1Easy 561 Array Partition I 68.1% 1Easy 563 Binary Tree Tilt 46.8% 1Easy 566 Reshape the Matrix 58.3% 1Easy 575 Distribute Candies 59.0% 1Easy 599 Minimum Index Sum of Two Lists 47.0% 1Easy 606 Construct String from Binary Tree 50.9% 1Easy 617 Merge Two Binary Trees 68.9% 1Easy 637 Average of Levels in Binary Tree 57.7% 1Easy 654 Maximum Binary Tree 71.7% 2Medium 657 Robot Return to Origin 70.5% 1Easy 661 Image Smoother 47.7% 1Easy 665 Non-decreasing Array 19.6% 1Easy 669 Trim a Binary Search Tree 59.6% 1Easy 671 Second Minimum Node In a Binary Tree 43.2% 1Easy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://orzyt.cn/tags/算法/"}]},{"title":"条件生成对抗网络(Conditional GANs)","slug":"conditional-gan","date":"2017-12-26T04:39:58.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/conditional-gan/","link":"","permalink":"https://orzyt.cn/posts/conditional-gan/","excerpt":"背景在原始的生成对抗网络论文中，作者指出了一个可能的拓展: A conditional generative model $p(x|c)$ can be obtained by adding $c$ as input to both $G$ and $D$ 于是同年11月，Mirza等人便提出了Conditional Generative Adversarial Networks，这是一种带条件约束的生成模型。","text":"背景在原始的生成对抗网络论文中，作者指出了一个可能的拓展: A conditional generative model $p(x|c)$ can be obtained by adding $c$ as input to both $G$ and $D$ 于是同年11月，Mirza等人便提出了Conditional Generative Adversarial Networks，这是一种带条件约束的生成模型。它在生成器 $G$ 和 判别器 $D$ 中均引入了条件变量 $y$，这里 $y$ 可以是任何的辅助信息（比如说，类别标签、其它模态的数据等等）。使用这个额外的条件变量，对生成器数据的生成具有指导作用。因此，该项工作可以看成是把无监督的GAN变成有监督模型的一种改进。 基本框架 Conditional GANs的基本框架非常地简单，只需在原始GAN的生成器和判别器的输入中，加入额外的条件信息即可。 显然地，目标函数改为： \\mathop{\\min}_{G}\\mathop{\\max}_{D}V(D,G)=\\mathbb{E}_{\\boldsymbol{x}\\sim p_{\\text{data}}}\\left[\\log D(\\boldsymbol{x}|\\boldsymbol{y})\\right]+\\mathbb{E}_{\\boldsymbol{z}\\sim p_z(\\boldsymbol{z})}\\left[\\log(1-D(G(\\boldsymbol{z}|\\boldsymbol{y})|\\boldsymbol{y}))\\right]实验在论文中，作者做了两个实验，一个是单模态的MNIST手写数字生成，另一个是基于多模态的图像自动标注。 在MNIST数据集的实验中，生成器 $G$ 的输入分为两部分： 噪声 $z$：100维 服从均匀分布的向量 条件 $y$：类别标签的one hot编码 然后将噪声 $z$ 和 标签 $y$ 分别映射到隐层(200和1000units)，在映射到第二层前，连接所有1200units。最终，用一个sigmoid层输出784维(28*28)的单通道图像。 判别器 $D$ 把输入图像 $x$ 映射到一个有240units和5pieces的maxout layer，把标签 $y$ 映射到有50units和5pieces的maxout layer。同时，把所有隐层连接成为一个有240units和4pieces的maxout layer。最后送入sigmoid层，该层的输出即为在条件 $y$ 下，输入图像 $x$ 为真实样本的概率。 代码实现Github地址：(orzyt/Generative-Adversarial-Nets/conditional-gan) 具体实现细节与论文有所不同，网络架构使用的是DCGAN，效果会比论文中的好（毕竟DCGAN是在CGAN之后才提出的… 让我们看下代码跑出来的效果","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://orzyt.cn/categories/深度学习/"}],"tags":[{"name":"cgan","slug":"cgan","permalink":"https://orzyt.cn/tags/cgan/"},{"name":"conditional gan","slug":"conditional-gan","permalink":"https://orzyt.cn/tags/conditional-gan/"},{"name":"条件生成对抗网络","slug":"条件生成对抗网络","permalink":"https://orzyt.cn/tags/条件生成对抗网络/"}]},{"title":"生成对抗网络(Generative Adversarial Nets)","slug":"generative-adversarial-nets","date":"2017-12-18T23:16:14.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/generative-adversarial-nets/","link":"","permalink":"https://orzyt.cn/posts/generative-adversarial-nets/","excerpt":"背景生成对抗网络（Generative Adversarial Nets, GANs）是由 Ian Goodfellow 等人于2014年6月提出的一种生成模型，至今仍是非常热门的研究方向。深度学习领域泰斗级人物 Yann LeCun 曾如此评价道：“GANs and the variations that are now being proposed is the most interesting idea in the last 10 years in ML, in my opinion.”，从中可见GAN的强大之处！","text":"背景生成对抗网络（Generative Adversarial Nets, GANs）是由 Ian Goodfellow 等人于2014年6月提出的一种生成模型，至今仍是非常热门的研究方向。深度学习领域泰斗级人物 Yann LeCun 曾如此评价道：“GANs and the variations that are now being proposed is the most interesting idea in the last 10 years in ML, in my opinion.”，从中可见GAN的强大之处！ 基本框架生成对抗网络的主要框架基于博弈论中的二人零和博弈游戏（zero-sum game） 在该游戏中，两位博弈方的利益之和为零或一个常数，即一方有所得，另一方必有所失。而在生成对抗网络中，这两个博弈的角色分别为：生成器（generator）和判别器（discriminator），作用如下： 生成器 $G$：接受随机噪声（noise）输入，生成尽可能真实的样本判别器 $D$：接受任意样本 $x$，输出 $D(x)$ 代表 $x$ 为真实样本的概率 在训练过程中，生成器 $G$ 的目标就是尽量生成真实的样本去欺骗判别器$D$，而判别器 $D$ 的目标就是尽量把生成器$G$生成的假样本和真实的样本区分开来。如此一来，生成器 $G$ 和判别器 $D$ 就构成了一个动态的“博弈过程” 在理想的情况下，博弈的结果是：生成器 $G$ 所拟合的分布 $p_\\it{g}$ 可以无限接近于真实样本中的分布 $p_\\it{data}$ ，足以生成以假乱真的样本。而判别器 $D$ 无法再区分出样本的真假，因此对任意样本 $x$ ，都有 $D(x)=\\frac{1}{2}$ 最终，我们得到了一个生成模型 $G$！ 数学原理GAN的优化目标函数如下： \\min_G \\max_D V(D, G) = \\mathbb{E}_{x \\sim p_{data}(x)}[\\log D(x)] + \\mathbb{E}_{z \\sim p_{z}(z)}[\\log (1 - D(G(z)))] \\tag{1}其中， $x$：真实样本 $p_{data}(x)$：真实样本的分布 $z$：随机噪声 $p_{z}(z)$：随机噪声的分布，一般采用高斯分布 $G(z)$：生成器根据随机噪声 $z$ 生成的假样本 $D(x)$：样本 $x$ 为真实样本的概率 上述目标函数是一个极小化极大的过程。对于判别器 $D$ 来说，它的目标是极大化 $V(D, G)$，那么必然导致 $D(x) \\to 1$ 且 $D(G(z)) \\to 0$，也就是前面提到的尽可能把生成的假样本和真样本正确地区分开来。而对于生成器 $G$ 来说，它的目标是极小化最优的判别器，同样地，有 $D(G(z)) \\to 1$，即生成器尽量生成真实的样本去欺骗判别器 那么，对于固定的生成器 $G$，最优的判别器 $D^*$ 是多少呢？ \\begin{align} D^* &= \\max_D V(D, G) \\nonumber \\\\ &= \\max_D \\mathbb{E}_{x \\sim p_{data}(x)}[\\log D(x)] + \\mathbb{E}_{z \\sim p_{z}(z)}[\\log (1 - D(G(z))] \\nonumber \\\\ &= \\max_D \\mathbb{E}_{x \\sim p_{data}(x)}[\\log D(x)] + \\mathbb{E}_{x \\sim p_{G}(x)}[\\log (1 - D(x))] \\nonumber \\\\ &= \\max_D \\int_x P_{data}(x) \\log D(x)dx + \\int_x P_{G}(x) \\log (1-D(x))dx \\nonumber \\\\ &= \\max_D \\int_x \\left[ P_{data}(x) \\log D(x)+ P_{G}(x) \\log (1-D(x)) \\right]dx \\nonumber \\\\ \\end{align}想要极大化 $V(D, G)$，那么对每一个样本 $x$，都令 $P_{data}(x) \\log D(x)+ P_{G}(x) \\log (1-D(x))$ 取到极大值即可。 由于给定了 $x$, 那么 $P_{data}(x)$ 和 $P_{G}(x)$ 都为定值，分别记作 $a$ 和 $b$对于函数 $f(D)=a\\log D + b\\log (1-D)$，令 $\\frac{df(D)}{dD} = a \\cdot \\frac{1}{D}-b \\cdot \\frac{1}{1-D} = 0 $，解得 $D^* = \\frac{a}{a + b} = \\frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}$ 即对于固定的生成器 $G$，最优的判别器为 D^* = \\frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)} \\tag{2} 现在，考虑生成器 $G$ 的目标，极小化最优的判别器，得到最优生成器 $G^*$ \\begin{align} G^* &= \\min_G V(D^*, G) \\nonumber \\\\ &= \\min_G \\mathbb{E}_{x \\sim p_{data}(x)}[\\log D^*(x)] + \\mathbb{E}_{z \\sim p_{z}(z)}[\\log (1 - D^*(G(z))] \\nonumber \\\\ &= \\min_G \\mathbb{E}_{x \\sim p_{data}(x)}[\\log D^*(x)] + \\mathbb{E}_{x \\sim p_{G}(x)}[\\log (1 - D^*(x))] \\nonumber \\\\ &= \\min_G \\mathbb{E}_{x \\sim p_{data}(x)}[\\log \\frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}] + \\mathbb{E}_{x \\sim p_{G}(x)}[\\log (1 - \\frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)})] \\nonumber \\\\ &= \\min_G \\mathbb{E}_{x \\sim p_{data}(x)}[\\log \\frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}] + \\mathbb{E}_{x \\sim p_{G}(x)}[\\log ( \\frac{P_{G}(x)}{P_{data}(x) + P_{G}(x)})] \\nonumber \\\\ &= \\min_G \\mathbb{E}_{x \\sim p_{data}(x)}[\\log \\frac{P_{data}(x)}{\\frac{P_{data}(x) + P_{G}(x)}{2}}] + \\mathbb{E}_{x \\sim p_{G}(x)}[\\log ( \\frac{P_{G}(x)}{\\frac{P_{data}(x) + P_{G}(x)}{2}})] -2\\log2 \\nonumber \\\\ &= \\min_G KL(P_{data}||\\frac{P_{data}(x) + P_{G}(x)}{2}) + KL(P_{G}||\\frac{P_{data}(x) + P_{G}(x)}{2}) - 2\\log2 \\nonumber \\\\ &= \\min_G 2JS(P_{data}||P_{G}) - 2\\log 2 \\tag{3} \\end{align}其中，$KL$表示Kullback–Leibler divergence，$JS$表示Jensen–Shannon divergence，都是用来度量两个分布的相似性对于$JS$散度来说，其取值范围为$[0, \\log2]$，当且仅当两个分布相等时取到最小值0 因此，最优生成器 $G^* = \\min_G 2JS(P_{data}||P_{G}) - 2\\log 2$ ，当且仅当 $P_{data} = P_{G}$ 时，取到最小值 $-2\\log2$ 由上述分析可知，该极小化极大的博弈对抗过程确实可以让生成器学习到真实的数据分布！ 算法流程根据前面 $V(D,G)$ 的定义，我们需要求两个数学期望，即 $\\mathbb{E}_{x \\sim p_{data}(x)}[\\log D(x)]$ 和 $\\mathbb{E}_{z \\sim p_{z}(z)}[\\log (1 - D(G(z)))]$。但在实践中，我们是没办法利用积分来求这两个数学期望的，所以一般只能从数据集中做采样以逼近真实的数学期望 \\tilde{V}(D, G) = \\frac{1}{m} \\sum_{i=1}^{m} \\log D(\\boldsymbol{x}^i) + \\frac{1}{m} \\sum_{i=1}^{m} \\log (1 - D(G(\\boldsymbol{z}^i)) 训练判别器 $D$ （训练 $k$ 次）：每次采样一组噪声变量 $\\{z^1,z^2, \\dots,z^m\\}$ 和 一组真实数据 $\\{x^1,x^2, \\dots,x^m\\}$，计算 $\\theta_d$ 的梯度： \\nabla_{\\boldsymbol{\\theta}_d} \\frac{1}{m} \\sum_{i=1}^{m} \\left[ \\log(D(\\boldsymbol{x}^i)) + \\log(1 - D(G(\\boldsymbol{z}^i))) \\right]然后使用梯度上升算法更新$\\theta_d$ 训练生成器 $G$ （训练 $1$ 次）：每次采样一组噪声变量 $\\{z^1,z^2, \\dots,z^m\\}$，计算 $\\theta_g$ 的梯度： \\nabla_{\\boldsymbol{\\theta}_g} \\frac{1}{m} \\sum_{i=1}^{m} \\log(1 - D(G(\\boldsymbol{z}^i)))然后使用梯度下降算法更新$\\theta_g$ Q：为什么判别器要训练k次，而生成器才训练1次？A：因为优化生成器D的前提是判别器G要达到最优的状态。如果判别器比较弱的话，那么它将给生成器错误的引导，使得生成器的优化方向不对 Q：为什么生成器的梯度只有后一项？A：因为 $\\tilde{V}$ 的前一项与参数 $\\theta_g$ 无关 此外在论文中，作者针对生成器的训练提出了一个 “$-\\log(D)$ trick“：将最小化 $\\log (1-D(G(z)))$ 改为 最小化 $-\\log D(G(z))$ 我们先来观察一下二者的函数图像 作者指出，在训练的早期，判别器 $G$ 可以轻易地区分出假样本，使得$D(G(z)) \\to 0$。观察图像发现，$\\log (1-D(x))$这个函数在 $x \\to 0$ 时比较平滑，梯度也比较小，这就会导致生成器 $G$ 的训练变得十分地缓慢。而改为优化 $-\\log(D(x))$ 后，在训练的早期能提供比较高的梯度，从而提高了训练速度。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://orzyt.cn/categories/深度学习/"}],"tags":[{"name":"GAN","slug":"GAN","permalink":"https://orzyt.cn/tags/GAN/"},{"name":"生成对抗网络","slug":"生成对抗网络","permalink":"https://orzyt.cn/tags/生成对抗网络/"}]},{"title":"使用TensorFlow实现逻辑回归","slug":"use-tensorflow-to-implement-logistic-regression","date":"2017-12-02T03:31:49.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/use-tensorflow-to-implement-logistic-regression/","link":"","permalink":"https://orzyt.cn/posts/use-tensorflow-to-implement-logistic-regression/","excerpt":"题目大意 使用TensorFlow实现小批量梯度下降的逻辑回归。数据集：moons dataset— From《Hands-on Machine Learning with Scikit-Learn and TensorFlow》Chapter9 Exercise12","text":"题目大意 使用TensorFlow实现小批量梯度下降的逻辑回归。数据集：moons dataset— From《Hands-on Machine Learning with Scikit-Learn and TensorFlow》Chapter9 Exercise12 *附加功能： • 在logistic_regression()函数中定义计算图，以便复用• 在训练的时候定期保存检查点，并在训练结束的时候保存最终的模型• 若训练中断，则从检查点中恢复• 使用命名域来定义图• 增加summaries日志记录，在TensorBoard中可视化学习曲线• 调参（如，学习率、批数据大小等）并观察学习曲线 数据预处理首先载入数据集1234from sklearn.datasets import make_moonsm = 1000 # 样本数量# 载入数据集X_moons, y_moons = make_moons(m, noise=0.1, random_state=42) 接着将数据集可视化，以便有一个直观的感受12345678# 数据可视化import matplotlib.pyplot as plt# y_moons == 1提取正样本的索引plt.plot(X_moons[y_moons == 1, 0], X_moons[y_moons == 1, 1], 'go', label='Positive')plt.plot(X_moons[y_moons == 0, 0], X_moons[y_moons == 0, 1], 'r^', label='Negative')plt.legend()plt.show() 为每个样本在第0维上添加bias12# 添加biasX_moons_with_bias = np.c_[np.ones((m, 1)), X_moons] 标签形状需要从(m, )reshape为(m, 1)12# 将数据标签从 1-D reshape成 2-Dy_moons_column_vector = y_moons.reshape(-1, 1) 从整个数据集中以8:2的比例，划分出训练集和测试集12345678910111213# 测试集占整个数据集的比例test_ratio = 0.2# 测试样本数量test_size = int(m * test_ratio)# 划分训练集X_train = X_moons_with_bias[:-test_size]y_train = y_moons_column_vector[:-test_size]# 划分测试集X_test = X_moons_with_bias[-test_size:]y_test = y_moons_column_vector[-test_size:] 定义一个随机划分批数据函数，方便后续训练123456789101112def random_batch(X_train, y_train, batch_size): ''' # 随机划分批数据 :param X_train: 整个训练集样本 :param y_train: 整个训练集标签 :param batch_size: 每个batch的大小 :return: 样本和标签的批数据 ''' rnd_indices = np.random.randint(0, len(X_train), size=batch_size) X_batch = X_train[rnd_indices] y_batch = y_train[rnd_indices] return X_batch, y_batch 构造计算图阶段moons dataset的特征只有2个12# 特征数量n_inputs = 2 构造计算图123456789# 输入数据X = tf.placeholder(tf.float32, shape=(None, n_inputs + 1), name='X')y = tf.placeholder(tf.float32, shape=(None, 1), name='y')# 权值初始化theta = tf.Variable(tf.random_uniform([n_inputs + 1, 1], -1.0, 1.0, seed=42), name='theta')# 计算logitslogits = tf.matmul(X, theta, name='logits') sigmod函数的计算方式12345# 方式一（根据定义）y_proba = 1 / (1 + tf.exp(-logits))# 方式二（内建函数）y_proba = tf.sigmoid(logits) 计算逻辑回归的损失函数123456# 方式一（根据定义）epsilon = 1e-7 # 避免运算溢出loss = -tf.reduce_mean(y * tf.log(y_proba + epsilon) + (1 - y) * tf.log(1 - y_proba + epsilon), name = 'loss')# 方式二（内建函数）loss = tf.losses.log_loss(y, y_proba, epsilon=epsilon) 定义学习率、梯度下降优化器及变量初始化节点123456789learning_rate = 0.01 # 学习率# 梯度下降优化器optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)# 训练节点training_op = optimizer.minimize(loss)# 变量初始化节点init = tf.global_variables_initializer() 训练相关的参数12345678# 训练的epoch次数（即遍历epoch次整个数据集）n_epochs = 1000# 每次批训练的样本数量batch_size = 50# 完成一次epoch所需要的批训练次数n_batches = int(np.ceil(m / batch_size)) 运行计算图阶段12345678910111213with tf.Session() as sess: sess.run(init) for epoch in range(n_epochs): for batch_index in range(n_batches): # 获取批数据 X_batch, y_batch = random_batch(X_train, y_train, batch_size) sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) loss_val = loss.eval(feed_dict=&#123;X: X_test, y: y_test&#125;) # 每训练100个epoch打印当前的loss值 if epoch % 100 == 0: print('Epoch:', epoch, '\\tLoss:', loss_val) # 在测试集上预测 y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test, y: y_test&#125;) 将概率大等于0.5的样本预测为正类1y_pred = (y_proba_val &gt;= 0.5) 模型评价使用准确率（precision）和召回率（recall）来评价模型123456789from sklearn.metrics import precision_score, recall_score# 准确率p_score = precision_score(y_test, y_pred)# 召回率r_score = recall_score(y_test, y_pred)print('Precision score:', p_score)print('Recall score:', r_score) 可视化预测结果123456y_pred_idx = y_pred.reshape(-1)plt.plot(X_test[y_pred_idx, 1], X_test[y_pred_idx, 2], 'go', label='Positive')plt.plot(X_test[~y_pred_idx, 1], X_test[~y_pred_idx, 2], 'r^', label='Negative')plt.legend()plt.show() 实现附加功能由于逻辑回归是一个线性分类器（从上面可视化的预测结果也可看出），效果不是特别好。因此，我们使用多项式回归，即额外增加4个特征($x_{1}^2$、$x_{2}^2$、$x_{1}^3$、$x_{2}^3$) 12345678910# 增加4个特征X_train_enhanced = np.c_[X_train, X_train[:, 1] ** 2, X_train[:, 2] ** 2, X_train[:, 1] ** 3, X_train[:, 2] ** 3,]X_test_enhanced = np.c_[X_test, X_test[:, 1] ** 2, X_test[:, 2] ** 2, X_test[:, 1] ** 3, X_test[:, 2] ** 3,] 将逻辑回归封装成一个函数12345678910111213141516171819202122232425262728def logistic_regression(X, y, initializer=None, seed=42, learning_rate=0.01): ''' 逻辑回归 :param X: 样本 :param y: 标签 :param initializer: 权值初始化器 :param seed: 随机数种子 :param learning_rate: 学习率 :return: sigmod概率, 损失函数, 训练节点, loss日志记录, 保存器 ''' n_inputs_with_bias = int(X.get_shape()[1]) with tf.name_scope('logistic_regression'): # 使用命名域 with tf.name_scope('model'): if initializer is None: initializer = tf.random_uniform([n_inputs_with_bias, 1], -1.0, 1.0, seed=seed) theta = tf.Variable(initializer, name='theta') logits = tf.matmul(X, theta) y_proba = tf.sigmoid(logits) with tf.name_scope('train'): loss = tf.losses.log_loss(y, y_proba, scope='loss') optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate) training_op = optimizer.minimize(loss) loss_summary = tf.summary.scalar('log_loss', loss) with tf.name_scope('init'): init = tf.global_variables_initializer() with tf.name_scope('save'): saver = tf.train.Saver() return y_proba, loss, training_op, loss_summary, init, saver 构造日志文件目录123456789from datetime import datetimedef log_dir(prefix=''): now = datetime.utcnow().strftime('%Y%m%d%H%M%S') root_logdir = 'tf_logs' if prefix: prefix += '-' name = prefix + 'run-' + now return '&#123;&#125;/&#123;&#125;/'.format(root_logdir, name) 构造计算图1234567891011121314# 特征数量，注意额外增加了4个特征n_inputs = 2 + 4# 日志文件目录logdir = log_dir('logreg')X = tf.placeholder(tf.float32, shape=(None, n_inputs + 1), name='X')y = tf.placeholder(tf.float32, shape=(None, 1), name='y')# 封装好logistic_regression，直接调用y_proba, loss, training_op, loss_summary, init, saver = logistic_regression(X, y)# 保存计算图结构file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph()) 运行计算图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osn_epochs = 10001batch_size = 50n_batches = int(np.ceil(m / batch_size))checkpoint_path = './tmp/my_logreg_model.ckpt'checkpoint_epoch_path = checkpoint_path + '.epoch'final_model_path = './my_logreg_model'with tf.Session() as sess: # 判断checkpoint_epoch_path文件是否存在 if os.path.isfile(checkpoint_epoch_path): with open(checkpoint_epoch_path, 'rb') as f: # 文件记录了最后一次保存的epoch编号 start_epoch = int(f.read()) print('Training was interrupted. Continuing at epoch', start_epoch) # 恢复会话 saver.restore(sess, checkpoint_path) else: # 重新开始 start_epoch = 0 sess.run(init) for epoch in range(start_epoch, n_epochs): for batch_index in range(n_batches): X_batch, y_batch = random_batch(X_train_enhanced, y_train, batch_size) sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) # 计算每个epoch的loss值及其日志记录 loss_val, summary_str = sess.run([loss, loss_summary], feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;) # 追加loss日志记录,注意当前epoch的编号也要记录 file_writer.add_summary(summary_str, epoch) # 每500个epoch保存checkpoint if epoch % 500 == 0: print('Epoch:', epoch, '\\tLoss:', loss_val) saver.save(sess, checkpoint_path) # 每次覆盖写入新的epoch编号 with open(checkpoint_epoch_path, 'wb') as f: f.write(b'%d' % (epoch + 1)) # 保存最终模型 saver.save(sess, final_model_path) # 在测试集上进行预测 y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;) # 若训练未中断,则删除checkpoint_epoch_path文件 os.remove(checkpoint_epoch_path) 预测结果1y_pred = (y_proba_val &gt;= 0.5) 输出准确率和召回率12print('Precision score:', precision_score(y_test, y_pred))print('Recall score:', recall_score(y_test, y_pred)) 可视化预测结果123456y_pred_idx = y_pred.reshape(-1)plt.plot(X_test[y_pred_idx, 1], X_test[y_pred_idx, 2], 'go', label='Positive')plt.plot(X_test[~y_pred_idx, 1], X_test[~y_pred_idx, 2], 'r^', label='Negative')plt.legend()plt.show() 可以看出，增加额外4个特征，能够显著提高预测结果 开始对learning rate和batch size进行玄学调参… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from scipy.stats import reciprocaln_search_iterations = 10for search_iteration in range(n_search_iterations): batch_size = np.random.randint(1, 100) # reciprocal为倒数分布 # 详见https://en.wikipedia.org/wiki/Reciprocal_distribution # 一般来说，如果对超参数的最优量级没把握的话，可以使用该分布进行调参 learning_rate = reciprocal.rvs(0.0001, 0.1, random_state=search_iteration) n_inputs = 2 + 4 logdir = log_dir('logdir') print('Iteration', search_iteration) print(' logdir:', logdir) print(' batch size:', batch_size) print(' learning rate:', learning_rate) print(' training: ', end='') X = tf.placeholder(tf.float32, shape=(None, n_inputs + 1), name='X') y = tf.placeholder(tf.float32, shape=(None, 1), name='y') y_proba, loss, training_op, loss_summary, init, saver = logistic_regression(X, y, learning_rate=learning_rate) file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph()) n_epochs = 10001 n_batches = int(np.ceil(m / batch_size)) final_model_path = './model/my_logreg_model_%d' % search_iteration with tf.Session() as sess: sess.run(init) for epoch in range(n_epochs): for batch_index in range(n_batches): X_batch, y_batch = random_batch(X_train_enhanced, y_train, batch_size) sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) loss_val, summary_str = sess.run([loss, loss_summary], feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;) file_writer.add_summary(summary_str, epoch) if epoch % 500 == 0: print('.', end='') print() saver.save(sess, final_model_path) y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;) y_pred = (y_proba_val &gt;= 0.5) print(' Precision:', precision_score(y_test, y_pred)) print(' Recall:', recall_score(y_test, y_pred)) 打印训练信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Iteration 0 logdir: tf_logs/logdir-run-20171202101244/ batch size: 54 learning rate: 0.00443037524522 training: ..................... Precision: 0.979797979798 Recall: 0.979797979798Iteration 1 logdir: tf_logs/logdir-run-20171202101623/ batch size: 22 learning rate: 0.00178264971514 training: ..................... Precision: 0.979797979798 Recall: 0.979797979798Iteration 2 logdir: tf_logs/logdir-run-20171202102501/ batch size: 74 learning rate: 0.00203228544324 training: ..................... Precision: 0.969696969697 Recall: 0.969696969697Iteration 3 logdir: tf_logs/logdir-run-20171202102742/ batch size: 58 learning rate: 0.00449152382514 training: ..................... Precision: 0.979797979798 Recall: 0.979797979798Iteration 4 logdir: tf_logs/logdir-run-20171202103106/ batch size: 61 learning rate: 0.0796323472178 training: ..................... Precision: 0.980198019802 Recall: 1.0Iteration 5 logdir: tf_logs/logdir-run-20171202103417/ batch size: 92 learning rate: 0.000463425058329 training: ..................... Precision: 0.912621359223 Recall: 0.949494949495Iteration 6 logdir: tf_logs/logdir-run-20171202103630/ batch size: 74 learning rate: 0.0477068184194 training: ..................... Precision: 0.98 Recall: 0.989898989899Iteration 7 logdir: tf_logs/logdir-run-20171202103916/ batch size: 58 learning rate: 0.000169404470952 training: ..................... Precision: 0.9 Recall: 0.909090909091Iteration 8 logdir: tf_logs/logdir-run-20171202104242/ batch size: 61 learning rate: 0.0417146119941 training: ..................... Precision: 0.980198019802 Recall: 1.0Iteration 9 logdir: tf_logs/logdir-run-20171202104602/ batch size: 92 learning rate: 0.000107429229684 training: ..................... Precision: 0.882352941176 Recall: 0.757575757576 让我们打开TensorBoard观察10次训练的学习曲线 可以看出，第4次（从0开始）的loss值最小 最终，找到的超参数为 超参数 取值 learning rate 0.0796323472178 batch size 61","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://orzyt.cn/categories/TensorFlow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"},{"name":"hands-on ML","slug":"hands-on-ML","permalink":"https://orzyt.cn/tags/hands-on-ML/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"https://orzyt.cn/tags/逻辑回归/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://orzyt.cn/tags/TensorFlow/"}]},{"title":"Hands-on Machine learning 之 TensorFLow入门","slug":"hands-on-ml-up-and-running-tensorflow","date":"2017-12-01T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/hands-on-ml-up-and-running-tensorflow/","link":"","permalink":"https://orzyt.cn/posts/hands-on-ml-up-and-running-tensorflow/","excerpt":"简介 TensorFlow是Google在2015年11月份开源的人工智能系统，是之前所开发的深度学习基础架构DistBelief的改进版本，该系统可以被用于语音识别、图像识别等多个领域。本文将介绍TensorFlow的基本概念和常见用法。","text":"简介 TensorFlow是Google在2015年11月份开源的人工智能系统，是之前所开发的深度学习基础架构DistBelief的改进版本，该系统可以被用于语音识别、图像识别等多个领域。本文将介绍TensorFlow的基本概念和常见用法。 创建图并在会话中运行 1234567# 导入tensorflowimport tensorflow as tf# 定义变量x，y及计算节点fx = tf.Variable(3, name='x')y = tf.Variable(4, name='y')f = x * x * y + y + 2 值得注意的是，上述代码并没有进行任何的运算，仅仅是创建了一个计算图（computation graph）而已。实际上，连变量都还没有被初始化。 为了对该计算图进行运算，我们必须创建一个会话（session）。然后在会话中初始化变量，以及计算f。 123456sess = tf.Session() # 创建会话sess.run(x.initializer) # 初始化变量xsess.run(y.initializer) # 初始化变量yresult = sess.run(f) # 计算fprint(result) # 打印结果&gt;&gt; 42 1sess.close() # 关闭会话 重复使用sess.run(...)可能有点繁琐，有一个更好的方式是使用python的with语句。 在with语句块开始时，创建的会话会成为计算图的默认会话。在语句块结束时，创建的会话也会自动结束。 12345# 创建一个会话并命名为sesswith tf.Session() as sess: x.initializer.run() # 等同于 sess.run(x.initializer) y.initializer.run() # 等同于 sess.run(y.initializer) result = f.eval() # result = sess.run(f) 除了手动初始化每个变量，也可以使用global_variables_initializer()函数初始化所有变量。 123456# 注意，并没有立即将变量初始化，而是创建一个初始化节点init = tf.global_variables_initializer()with tf.Session() as sess: init.run() # 在这里才真正初始化 result = f.eval() 管理计算图所有创建的节点（node）都会自动添加进默认图中。 1234x1 = tf.Variable(1)# 判断变量x1所在的图是否是默认图x1.graph is tf.get_default_graph()&gt;&gt; True 但是，有的时候需要管理多个独立的图。我们便可以创建一个临时的图，并在with语句块内将其设置为默认图。 12345graph = tf.Graph() # 创建图# 在with内将graph设置为默认图with graph.as_default(): # 此时创建的变量应该在图graph里 x2 = tf.Variable(2) 1234567# 判断x2所在的图，是不是真的在graph里x2.graph is graph&gt;&gt; True# 同样，判断x2是不是在全局的默认图里(显然不是的)x2.graph is tf.get_default_graph()&gt;&gt; False 若想要将默认图重置（删除图中所有的节点），可以使用tf.reset_default_graph()函数。 节点的生命周期123456789# 创建一个简单的图w = tf.constant(3)x = w + 2y = x + 5z = x * 3# 在会话中计算图with tf.Session() as sess: print(y.eval()) # 10 print(z.eval()) # 15 在会话中，为了计算y，会自动检测出y依赖于x，而x又依赖于w。那么，将会依次计算w和x，最后再计算y。而为了计算z，也同样会依次计算w和x。 注意在此过程中，w和x的值并不会被重复使用！也就是说，上述代码总共对w和x计算了两次(即使两次的结果都是一样的)。 因此，对于同一张图的多次运算，除了tf.Variable()变量外，其他节点的值在一次运行结束后都会被丢弃，不会被重复使用。 节点类型 生命周期 tf.Variable() 整个会话 others 会话的某次运行 为了高效地求得y和z的值，可以在会话的一次运行内同时计算它们。 12345with tf.Session() as sess: # 同时计算y和z，此时w和x只计算一次 y_val, z_val = sess.run([y, z]) print(y_val) # 10 print(z_val) # 15 使用TensorFlow进行线性回归TensorFlow的操作（operations，记作ops）可以接收任意多个输入，可以产生任意多个输出。 比如addition和multiplication可以接受2个输入，产生1个输出。而被成为源操作（source ops）的Constants和variables，则没有输入。 其中，输入和输出都是多维数组，称之为张量（tensor）。 接下来，将使用sklearn的加利福尼亚房屋数据来进行线性回归。 对于线性回归参数theta的拟合，将使用正规方程（Normal Equation）计算：$\\theta = (X^T X)^{-1}X^T y$ 1234567891011121314151617181920212223import numpy as npfrom sklearn.datasets import fetch_california_housing# 载入sklearn自带的加利福尼亚房屋数据housing = fetch_california_housing()# 样本数及特征数m, n = housing.data.shape# 添加biashousing_data_plus_bias = np.c_[np.ones((m, 1)), housing.data]# 创建TensorFlow的常量节点X和y，分别用来存放样本和标签X = tf.constant(housing_data_plus_bias, dtype=tf.float32, name='X')y = tf.constant(housing.target.reshape(-1, 1), dtype=tf.float32, name='y')# 计算X的转置XT = tf.transpose(X)# 使用正规方程计算thetatheta = tf.matmul(tf.matmul(tf.matrix_inverse(tf.matmul(XT, X)), XT), y)# 再次注意，上述代码并没有进行实际的运算，只是在构建计算图而已with tf.Session() as sess: # 在会话中计算theta的值 theta_value = theta.eval() 实现梯度下降接下来将使用批梯度下降（Batch Gradient Descent）方法来进行线性回归参数的拟合。 使用梯度下降方法一般要先对特征进行标准化（normalize，即减均值，除方差） 12345from sklearn.preprocessing import StandardScalerscaler = StandardScaler()scaled_housing_data = scaler.fit_transform(housing.data)scaled_housing_data_plus_bias = np.c_[np.ones((m, 1)), scaled_housing_data] 手动计算梯度$\\theta := \\theta - \\frac{\\alpha}{m} X^{T} (X\\theta - \\vec{y})$其中，$\\alpha$是学习率，$m$是批样本数量 123456789101112131415161718192021222324252627282930313233343536373839n_epochs = 1000 # 遍历1000次数据集learning_rate = 0.01 # 学习率# 创建TensorFlow的常量节点X和y，分别用来存放样本和标签# 特征已经过normalize，并加上了biasX = tf.constant(scaled_housing_data_plus_bias, dtype=tf.float32, name='X')y = tf.constant(housing.target.reshape(-1, 1), dtype=tf.float32, name='y')# 创建TensorFlow的变量节点theta，用来存放待求解的参数（使用均匀分布初始化节点）theta = tf.Variable(tf.random_uniform([n + 1, 1], -1.0, 1.0), name='theta')# 创建预测节点y_pred = tf.matmul(X, theta, name='predictions')# 创建误差节点error = y_pred - y# 创建损失函数节点，使用均方根误差（mean square error）mse = tf.reduce_mean(tf.square(error), name='mse')# 创建梯度计算节点gradients = 1 / m * tf.matmul(tf.transpose(X), error)# 创建赋值节点，即 theta = theta - learning_rate * gradientstraining_op = tf.assign(theta, theta - learning_rate * gradients)# 创建变量初始化节点init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for epoch in range(n_epochs): # 每100个epoch打印当前的loss值 if epoch % 100 == 0: print('Epoch', epoch, 'MSE=', mse.eval()) # 进行梯度下降更新参数theta sess.run(training_op) # 训练完成后，计算最终的theta参数值 best_theta = theta.eval() 使用autodiff在前面的代码中，需要我们事先手动计算好loss function（MSE）的梯度才能进行训练。虽然在线性回归里面求解梯度还不算复杂，但是对于深度神经网络来说，梯度的求解将会让人十分头疼。 在TensorFlow中，提供了autodiff能够帮助我们自动计算梯度。 只需将之前的梯度计算替换为1gradients = tf.gradients(mse, [theta])[0] gradients()函数接受一个操作节点（如，mse损失函数计算节点），以及一系列需要求解梯度的变量（如，theta），最终返回对应的梯度列表。 使用优化器TensorFlow能够自动计算梯度已经很方便了，但是可以将事情变得更加简单——使用优化器。 比如，使用梯度下降优化器（Gardient Descent optimizer）。 便可以简单地将之前gradients = ...和training_op = ...直接替换成下列方式： 12optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)training_op = optimizer.minimize(mse) 为训练算法提供数据首先，我们将之前的批梯度下降算法改为小批量梯度下降算法（Mini-batch Gradient Descent）。那么对于每个batch，我们都需要不断地替换X和y常量节点，来向训练算法提供数据。 在TensorFlow中，一个典型的做法是使用placeholder占位符节点。 占位符节点在创建的时候，只需指定其存放的数据类型（如，floa32等），以及存放的数据维度大小即可。然后，等到训练运行时才真正往占位符里放数据（使用feed_dict参数放数据）。 123456789# None 意味着在该维度不限制大小A = tf.placeholder(tf.float32, shape=(None, 3))B = A + 5with tf.Session() as sess: # 由于B依赖于A，因此在对B求值的时候，必须先用feed_dict向占位符A提供数据 B_val_1 = B.eval(feed_dict=&#123;A: [[1, 2, 3]]&#125;) # 占位符A的第0维度可以是任意大小 B_val_2 = B.eval(feed_dict=&#123;A: [[4, 5, 6], [7, 8, 9]]&#125;) 123456print(B_val_1)&gt;&gt; [[ 6. 7. 8.]]print(B_val_2)&gt;&gt; [[ 9. 10. 11.] [ 12. 13. 14.]] 使用placeholder实现小批量梯度下降算法 1234n_epochs = 10 # 遍历10次数据集learning_rate = 0.01 # 学习率batch_size = 100 # 批数据大小n_batches = int(np.ceil(m / batch_size)) # 完成一次epoch所需要的批次数 1234567891011121314151617181920def fetch_batch(epoch, batch_index, batch_size): ''' 获取批数据 :param epoch: 当前epoch的次数 :param batch_index: 当前batch的序号 :param batch_size: 每个batch的大小 :return: 样本和标签的批数据 ''' # seed的种子设为：当前batch的总序号 # 比如，完成一个epoch需要5个batch # 当前是第3个epoch的第2个batch # 那么这个batch总序号就是3 × 5 + 2 = 17 np.random.seed(epoch * n_batches + batch_index) # 在[0, m)范围内，产生batch_size个索引 indices = np.random.randint(m, size=batch_size) # 根据索引，获取样本的批数据 X_batch = scaled_housing_data_plus_bias[indices] # 根据索引，获取标签的批数据 y_batch = housing.target.reshape(-1, 1)[indices] return X_batch, y_batch 123456789101112131415161718192021222324252627282930313233# 创建TensorFlow的占位符节点X和y，分别用来存放样本和标签# 第0维度为None则不指定大小，因为样本数需要在运行时确定X = tf.placeholder(tf.float32, shape=(None, n + 1), name='X')y = tf.placeholder(tf.float32, shape=(None, 1), name='y')# 创建TensorFlow的变量节点theta，用来存放待求解的参数（使用均匀分布初始化节点）theta = tf.Variable(tf.random_uniform([n + 1, 1], -1.0, 1.0, seed=42), name='thete')# 创建预测节点y_pred = tf.matmul(X, theta, name='predictions')# 创建误差节点error = y_pred - y＃ 创建损失函数节点，使用均方根误差（mean square error）mse = tf.reduce_mean(tf.square(error), name='mse')# 创建梯度下降优化器节点 及 对应的训练节点optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)training_op = optimizer.minimize(mse)# 创建变量初始化节点init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for epoch in range(n_epochs): for batch_index in range(n_batches): # 获取批数据 X_batch, y_batch = fetch_batch(epoch, batch_index, batch_size) # 由于训练节点依赖于X和y，因此使用feed_dict参数传送一个字典，分别为X和y提供数据 sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) best_theta = theta.eval() 模型的存储及读取模型一旦训练好，那么应该将相关的信息（如，参数、计算图等）存储在硬盘里，方便以后的使用。同样，在模型的训练过程中，应该定时地保存检查点（checkpoint）。这使得模型训练中断之后，可以直接从最后一次检查点开始训练而不是重头开始。 存储模型只需在计算图构造阶段（construction phase）的最后新建一个Saver保存节点即可。然后在执行阶段（execution phase），调用其save(sess, path)方法即可将模型保存到path路径下。 12345678910111213141516[...]theta = tf.Variable(tf.random_uniform([n + 1, 1], -1.0, 1.0), name=\"theta\")[...]init = tf.global_variables_initializer()# 在construction phase之后创建Saver node即可saver = tf.train.Saver()with tf.Session() as sess: sess.run(init) for epoch in range(n_epochs): if epoch % 100 == 0: # 每100个epoch保存checkpoint save_path = saver.save(sess, 'tmp/my_model.ckpt') sess.run(training_op) best_theta = theta.eval() # 训练完毕，保存最终模型 save_path = saver.save(sess, 'tmp/my_model_final.ckpt') 读取模型首先，还是在构造阶段的最后新建一个Saver保存节点。然后，在执行阶段的开始，调用其restore(sess, path)方法即可将path路径下的模型读取到当前的会话中。 123with tf.Session() as sess: saver.restore(sess, 'tmp/my_model_final.ckpt') [...] Saver默认情况下，会存储和读取模型的所有参数。不过，我们也可以指定只保存哪些变量，以及使用什么名字。 12# 只保存theta变量，命名为weightssaver = tf.train.Saver(&#123;\"weights\": theta&#125;) Saver默认情况下，也会存储计算图的结构，保存在路径的*.meta文件中。如果需要读取模型的计算图，可以调用tf.train.import_meta_graph()函数。 123456# 读取模型的计算图# 这样可以完整地恢复模型，不仅包括模型的参数，还包括模型的计算图结构saver = tf.train.import_meta_graph(\"/tmp/my_model_final.ckpt.meta\")with tf.Session() as sess: saver.restore(sess, \"/tmp/my_model_final.ckpt\")[...] 使用TensorBoard进行可视化在此之前，我们都是用print函数打印出训练过程。然而，有一个更好的选择是：使用TensorBoard！ 接下来，我们将对线性回归的loss值进行可视化。 首先，新建一个存放数据的日志目录（使用时间戳作为目录名）。 12345678from datetime import datetime# 以指定格式获取当前时间now = datetime.utcnow().strftime('%Y%m%d%H%M%S')# 根目录root_logdir = 'tf_logs'# 日志文件目录logdir = '&#123;&#125;/run-&#123;&#125;/'.format(root_logdir, now) 其次，在构造阶段的末尾添加以下代码 12345678910# summary是TensorBoard的一种二进制日志字符串# 我们使用它的scalar标量类型（还有其他类型，如tf.summary.image可以可视化图像）# 参数'MSE'：可视化时变量的名称# 参数mse：loss function节点mse_summary = tf.summary.scalar('MSE', mse)# FileWriter可以将summaries写进指定的日志文件中# 参数logdir：指定的日志文件路径# 参数tf.get_default_graph()：需要可视化的计算图结构file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph()) 最后，在执行阶段添加以下代码： 12345678910111213[...]for batch_index in range(n_batches): X_batch, y_batch = fetch_batch(epoch, batch_index, batch_size) if batch_index % 10 == 0: # 计算mse_summary的值 summary_str = mse_summary.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;) step = epoch * n_batches + batch_index # 将summary添加到日志文件中，同时需要指定当前的step（也就是可视化时的横轴坐标） file_writer.add_summary(summary_str, step) sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)[...]# 关闭FileWriterfile_writer.close() 现在，让我们启动TensorBoard！ 首先，在终端中输入:123$ tensorboard --logdir tf_logs/&gt;&gt; Starting TensorBoard on port 6006 (You can navigate to http://0.0.0.0:6006) 然后，在浏览器中打开http://0.0.0.0:6006/ (或http://localhost:6006/)，即可访问TensorBoard！ 命名域当处理复杂模型的时候，图中可能有成千上万个节点。因此，非常有必要将相关的节点组织起来放到一起。这就需要TensorFlow中的命名域（Name Scopes）来管理节点！ 比如，我们可以将之前代码里的error和mse操作节点放在一个名叫loss的命名域里。 123with tf.name_scope('loss') as scope: error = y_pred - y mse = tf.reduce_mean(tf.square(error), name='mse') 1234print(error.op.name)&gt;&gt; loss/subprint(mse.op.name)&gt;&gt; loss/mse 在TensorBoard中，error和mse将出现在loss命名域内。 12345678910111213a1 = tf.Variable(0, name=\"a\")a2 = tf.Variable(0, name=\"a\")with tf.name_scope(\"param\"): a3 = tf.Variable(0, name=\"a\")with tf.name_scope(\"param\"): a4 = tf.Variable(0, name=\"a\")for node in (a1, a2, a3, a4): print(node.op.name) &gt;&gt; a a_1 param/a param_1/a 模块化假设现在要对多个ReLU（rectified linear units，修正线性单元）输出进行累加。 ReLU_{x,b}(X) = max(X \\cdot w + b, 0 )由于要计算多次ReLU，所以基于模块化的思想，我们可以将实现ReLU功能的语句单独封装成一个函数以供调用。 1234567891011def relu(X): ''' 实现ReLU :param X: 输入样本 :return: 经过ReLU修正后的输出 ''' w_shape = (int(X.get_shape()[1]), 1) w = tf.Variable(tf.random_normal(w_shape), name='weights') b = tf.Variable(0.0, name='bias') z = tf.add(tf.matmul(X, w), b, name='z') return tf.maximum(z, 0.0, name='relu') 123456n_features = 3X = tf.placeholder(tf.float32, shape=(None, n_features), name='X')# 调用5次relu函数relus = [relu(X) for i in range(5)]# 将5次的结果累加output = tf.add_n(relus, name='output') 还可以做得更好… 我们将之前讲过的命名域加进来 12345678def relu(X): ''' 实现ReLU :param X: 输入样本 :return: 经过ReLU修正后的输出 ''' with tf.name_scope('relu'): [...] 共享变量如果你想让计算图中不同的部分共享一个变量（比如CNN中卷积核的权值），一个可能的操作是将变量作为参数传递过去。但是，当计算图中需要共享的变量非常多时，将变得十分麻烦。 TensorFlow有一个更好的解决方案是，使用get_variable()函数来创建（或复用）共享变量。而选择创建还是选择复用则是由当前的变量域variable_scope()决定的。 123# 在relu变量域内创建threshold变量with tf.variable_scope('relu'): threshold = tf.get_variable('threshold', shape=(), initializer=tf.constant_initializer(0.0)) 123# 复用，设置reuse=Truewith tf.variable_scope('relu', reuse=True): threshold = tf.get_variable('threshold') 1234# 另一种复用方式with tf.variable_scope('relu') as scope: scope.reuse_variables() # 调用scope的reuse_variables方法 threshold = tf.get_variable('threshold') 复用ReLU的阈值1234567891011121314def relu(X): # 存在则复用，不存在则创建 threshold = tf.get_variable('threshold', shape=(), initializer=tf.constant_initializer(0.0)) [...] return tf.maximum(z, threshold, name=\"max\")X = tf.placeholder(tf.float32, shape=(None, n_features), name='X')relus = []for relu_index in range(5): # 第一次调用relu时reuse为0，则不复用选择创建变量 # 后续调用relu则会选择复用变量 with tf.variable_scope('relu', reuse=(relu_index &gt;= 1)) as scope: relus.append(relu(X))output = tf.add_n(relus, name='output') 复用CNN卷积层参数12345678910111213141516171819202122232425262728293031323334353637383940import tensorflow as tfimport numpy as npinput_images = tf.placeholder(tf.float32, shape = (1, 32, 32, 1))# 定义了一层卷积神经网络def conv_relu(input, kernel_shape, bias_shape): # 创建名为weights的变量 weights = tf.get_variable(\"weights\", kernel_shape, initializer=tf.random_normal_initializer()) # 创建名为biases的变量 biases = tf.get_variable(\"biases\", bias_shape, initializer=tf.constant_initializer(0.0)) conv = tf.nn.conv2d(input, weights, strides=[1, 1, 1, 1], padding='SAME') return tf.nn.relu(conv + biases)def my_image_filter(input_images): with tf.variable_scope(\"conv1\"): # 在名为conv1的variable scope下调用一层神经网络，对应的参数名为 # \"conv1/weights\", \"conv1/biases\" relu1 = conv_relu(input_images, [3, 3, 1, 1], [1]) with tf.variable_scope(\"conv2\"): # 在名为conv2的variable scope下调用一层神经网络，对应的参数名为 # \"conv2/weights\", \"conv2/biases\" return conv_relu(relu1, [3, 3, 1, 1], [1])with tf.variable_scope(\"image_filter\") as scope: result1 = my_image_filter(input_images) scope.reuse_variables() # 复用变量 result2 = my_image_filter(input_images)init = tf.global_variables_initializer();with tf.Session() as sess: sess.run(init) image = np.random.rand(1, 32, 32, 1) result1 = sess.run(result1, feed_dict=&#123;input_images: image&#125;) result2 = sess.run(result2, feed_dict=&#123;input_images: image&#125;) print(result2.all() == result1.all())&gt;&gt; True # 说明第二次的参数没有重新初始化，而是复用了第一次的参数","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://orzyt.cn/categories/TensorFlow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"},{"name":"hands-on ML","slug":"hands-on-ML","permalink":"https://orzyt.cn/tags/hands-on-ML/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://orzyt.cn/tags/TensorFlow/"}]},{"title":"使用WebIDE搭建Hexo云端写作环境","slug":"use-hexo-on-coding-webIDE","date":"2017-11-22T23:20:58.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/use-hexo-on-coding-webIDE/","link":"","permalink":"https://orzyt.cn/posts/use-hexo-on-coding-webIDE/","excerpt":"前言由于学习的需要，现在日常使用Ubuntu系统。但是，之前hexo的写作环境是搭建在Win10系统里的，如果想在Ubuntu系统里写博客的话，又得重新搭建环境，耗时耗力！ 本着Setup Once, Write Anywhere的原则，便开始寻找一劳永逸的方法。 因为本博客是托管在Coding Pages上的，所以首先看看Coding有没有解决方案。幸运的是，Coding有一款产品叫Coding webIDE满足我们的需求！","text":"前言由于学习的需要，现在日常使用Ubuntu系统。但是，之前hexo的写作环境是搭建在Win10系统里的，如果想在Ubuntu系统里写博客的话，又得重新搭建环境，耗时耗力！ 本着Setup Once, Write Anywhere的原则，便开始寻找一劳永逸的方法。 因为本博客是托管在Coding Pages上的，所以首先看看Coding有没有解决方案。幸运的是，Coding有一款产品叫Coding webIDE满足我们的需求！ Coding WebIDE 是 Coding 自主研发的在线集成开发环境 (IDE)。用户可以通过 WebIDE 创建项目的工作空间, 进行在线开发, 调试等操作。同时 WebIDE 集成了 Git 代码版本控制, 用户可以选择 Coding、GitHub、BitBucket、Git@OSC 等任意的代码仓库。 WebIDE 还提供了分享开发环境的功能, 用户可以保存当前的开发环境, 分享给团队的其他成员。 准备工作 最好有hexo、git、ubuntu等的使用经验 若没有coding.net的账号，可以点此注册 完善个人资料，即可免费成为银牌会员注：银牌会员可以使用一个webIDE工作空间，配置：CPU×1，内存256M，磁盘空间2G 新建工作空间新建工作空间 选择空项目 填写项目信息并选择配置 运行工作空间 配置工作空间配置hexo点击右侧边栏的Environments选项卡，然后选择使用ide-ttf-hexo环境。 配置git12git config --global user.email &quot;Your Email&quot;git config --global user.name &quot;Your Name&quot; 配置npmhexo的插件需要通过npm安装，换国内的源比较快1npm config set registry https://registry.npm.taobao.org 初始化hexo在workspace（即hexo-cloud）目录下，执行下列命令初始化hexo123hexo init blogcd blognpm install 至此，hexo环境已经搭好，并成功初始化！ 预览博客写好文章之后，通常需要使用命令hexo s预览博客效果。在本地的话，直接在地址栏输入http://localhost:4000即可预览。但是在云端要怎么访问呢？ 方法是，点击右侧边栏的Access URL选项卡，然后在Port选择使用4000端口。然后点击添加+，会生成一个临时链接（有效期为1个小时），访问该链接即可预览博客。 （可选）导入原有博客上述操作是在webIDE里新建一个hexo博客，但是如何导入已有的博客呢？ 方式一右键点击文件树空白处，可以选择上传文件。（但是好像不能上传整个目录） 方式二由于每次更新博客之后，我都会把博客文件备份在coding的仓库里。所以，现在只需把该仓库clone到webIDE中即可。 12// 复制原有的博客文件到文件夹 hexo_cloud/blog_backup 下git clone https://git.coding.net/orzyt/blog_backup.git 12// 删除之前初始化的博客文件sudo rm -rf blog/* 12// 将blog_backup中的所有文件移到blog中sudo mv blog_backup/* blog_backup/.[^.]* blog/ 12// 安装原有博客所依赖的插件npm install","categories":[{"name":"教程","slug":"教程","permalink":"https://orzyt.cn/categories/教程/"}],"tags":[{"name":"webIDE","slug":"webIDE","permalink":"https://orzyt.cn/tags/webIDE/"},{"name":"hexo","slug":"hexo","permalink":"https://orzyt.cn/tags/hexo/"}]},{"title":"Hands-on Machine learning 之 机器学习概览","slug":"hands-on-ml-the-machine-learning-landscape","date":"2017-11-04T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/hands-on-ml-the-machine-learning-landscape/","link":"","permalink":"https://orzyt.cn/posts/hands-on-ml-the-machine-learning-landscape/","excerpt":"什么是机器学习？在1959年， Arthur Samuel 给机器学习定义如下： [Machine Learning is the] field of study that gives computers the ability to learn without being explicitly programmed.—Arthur Samuel, 1959 Arthur Samuel是美国计算机游戏和人工智能领域的先驱之一。在IBM的时候，他开发出的西洋跳棋程序被认为是世界上第一个自学习程序。Samuel让该程序自己和自己下棋，很快它就习得了在哪些情况下赢的机会比较大，从而可以不断提高自己的棋艺。最终，该程序的棋艺已经远远超过Samuel。 Samuel这段话的意思是说，“机器学习是这样的一个研究领域，在没有显式编码的情况下赋予计算机学习的能力。”虽然这个定义看上去是挺不错的，但是却有点含糊不清。","text":"什么是机器学习？在1959年， Arthur Samuel 给机器学习定义如下： [Machine Learning is the] field of study that gives computers the ability to learn without being explicitly programmed.—Arthur Samuel, 1959 Arthur Samuel是美国计算机游戏和人工智能领域的先驱之一。在IBM的时候，他开发出的西洋跳棋程序被认为是世界上第一个自学习程序。Samuel让该程序自己和自己下棋，很快它就习得了在哪些情况下赢的机会比较大，从而可以不断提高自己的棋艺。最终，该程序的棋艺已经远远超过Samuel。 Samuel这段话的意思是说，“机器学习是这样的一个研究领域，在没有显式编码的情况下赋予计算机学习的能力。”虽然这个定义看上去是挺不错的，但是却有点含糊不清。 后来在1998年， Tom Mitchell在他的著作《Machine Learning 》中给出了一个被广泛引用且更加正式的定义： A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.—Tom Mitchell, 1997 这段话是说，“如果一个计算机程序在任务T中以P为度量的性能从经验E中得到了提升，那么可以说该程序从与某类任务T和性能度量P有关的经验E中进行了学习。” 根据该定义，一个机器学习问题必须具备三个要素： 任务（Tasks） 性能度量（Performance Measure） 训练经验（Training Experience） 以垃圾邮件过滤器（spam filter）为例，该程序的任务是标记垃圾邮件，性能度量可以是正确分类的比例，训练经验通常是包含正常邮件和垃圾邮件的训练数据集。 为什么要使用机器学习？考虑如何构建一个垃圾邮件过滤器。 使用传统方式 首先人工提取垃圾邮件中的特征（比如一些经常出现的单词或短语），然后总结成“规则”写进代码中。若一封邮件满足其中某些规则，则将其标记为垃圾邮件。 弊端在于：随着时间的推移，程序中复杂、冗长的“规则”将变得难以维护。 使用机器学习 基于机器学习的方法可以自动地从训练数据中学习垃圾邮件的特征，该过程无需过多的人工操作。 优点在于：程序通常更短、更容易维护，且准确率更高。 一般来说，机器学习擅长以下几个方面： 已存在的解法需要过多的人工操作，或者手动维护一长串的“规则”。例如，垃圾邮件的过滤； 对于非常复杂的问题，传统方式通常不能够有效地解决。例如，语音识别问题； 能够自动适应复杂多变的外部环境。例如，机器学习系统可以自动适应新数据； 对复杂问题和大规模数据有很好的洞察能力。例如，可以发现数据中潜在的模式。 机器学习系统的类型有/无监督学习根据在训练过程中得到的监督类型和数量，通常可以分为： 有监督学习在有监督学习（supervised learning）中，每一个训练数据都带有标签（labels）。比如，在垃圾邮件问题中，训练数据中的每封邮件都会带上是否是垃圾邮件（spam or ham）的标签。 有监督学习一般分为以下两类： 分类（classification） 比如，将邮件按是否是垃圾邮件进行分类。通常，该问题的标签是离散型数据。 回归（regression） 比如，根据车的一系列特征预测车的价格是多少。通常，该问题的标签是连续型数据。 一些比较重要的有监督学习算法： K近邻（k-Nearest Neighbors） 线性回归（Linear Regression） 对数几率回归（Logistic Regression） 支持向量机（SVMs，Support Vector Machines） 决策树和随机森林（Decision Trees and Random Forests） 神经网络（Neural networks） 无监督学习在无监督学习（unsupervised learning）中，训练数据都是无标签的。 一般有以下几类任务： 聚类（Clustering） 比如，通过计算样本之间的相似性，将其聚拢成一个个簇。使得簇内样本的相似度高，簇外样本的相似度低。 可视化与降维（Visualization and dimensionality reduction） 比如，将高维的数据降维到低维空间（二维或三维），使得可以进行数据可视化。 异常检测（anomaly detection） 比如，检测信用卡中的非法交易、剔除数据中的异常点。 关联规则学习（association rule learning） 比如，在大量购物记录中挖掘出各个商品之间的购买关系。 一些比较重要的无监督算法： 聚类（Clustering） k均值（k-Means） 层序聚类分析（HCA，Hierarchical Cluster Analysis ） 期望最大化（EM，Expectation Maximization） 可视化与降维（Visualization and dimensionality reduction） 主成分分析（PCA，Principal Component Analysis ） 核PCA（Kernel PCA） 局部线性嵌入（LLE，Locally-Linear Embedding） t分布随机领域嵌入（t-SNE，t-distributed Stochastic Neighbor Embedding） 关联规则学习（Association rule learning） Apriori Eclat 半监督学习在半监督学习（semi-supervised learning）中，训练数据通常由大量无标签数据和少量带标签数据构成。 比如，当你把一张家庭照上传到Google Photos，便可以自动识别出在哪些照片中出现了人物A，在哪些照片中出现了人物B，这是无监督聚类的过程。但是，如果想要知道人物A、人物B叫什么的话，那么只需要给每个人物打上一个”姓名“标签即可，这是有监督的过程。 因此，只需标记少量样本，便可以对每张照片的每个人物打上标签。 强化学习强化学习（Reinforcement Learning）是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。 在该问题中，学习系统被称为agent，它可以观察环境（environment），执行动作（actions），然后可以得到奖励（rewards），最终学习到最优的策略（policy）。 批量/在线学习该分类标准是根据系统能否从连续的数据流中进行学习。 批量学习（Batching learning） 批量学习的每次训练都需要使用整个数据集，该过程通常是离线（offline）进行的。 模型离线训练完毕后，再部署到生产环境中去，在运行过程中模型也不会再进行训练。如果批量学习系统需要适应新的数据，那么必须重新进行训练，训练的数据由旧数据和新数据组成，训练完毕后再部署上去。 批量学习的过程非常消耗计算资源，通常是每隔24h或更久训练一次。 在线学习（Online learning） 在在线学习的过程中，可以依次递送数据（单个或者小批量）来逐步地训练系统。 该方法特别适用于需要不断接收连续的数据流，或者需要不断适应变化数据的系统。同时，在线学习也适用于计算资源缺乏的环境，因为通常系统学习完新数据后，便不再需要保留该数据，从而可以节约巨大的存储空间。 在线学习也常被用来进行out-of-core learning，使得系统可以在巨大的数据集（不能一次性放入机器的内存中）上进行训练。每次训练只载入数据集的部分数据，不断重复，直到所有数据都被处理过。 对于在线学习来说，一个很重要的参数是学习率（learning rate）。若学习率过高，那么系统将会更加适应新的数据，而更快遗忘旧的数据。若学习率过低，那么系统将会学习得很慢，但同时对新数据中的噪声或数据中没有代表性的样本不会太敏感。 在线学习面临的一个挑战是，一旦”坏数据“被输入到系统中，那么系统的性能将会逐渐降低。为了降低该风险，可以不断地监测系统，在性能下降时恢复到之前正常的状态；也可以使用异常检测算法对数据进行检测，没有问题后再输入到系统中去。 基于实例/基于模型的学习该分类标准是系统是如何对未知数据进行泛化（generalize）。 基于实例的学习（Instance-based learning） 基于实例的学习只是简单地把训练数据存储起来，当遇到新的查询实例时，根据相似性计算规则从已知数据中找到相似的实例，然后对其进行泛化预测。例如，k近邻算法。 基于模型的学习（Mode-based learning） 基于模型的学习是从训练数据中建立一个模型（model），然后使用该模型对未知数据进行泛化预测。例如，支持向量机。 机器学习的主要挑战训练数据方面 训练数据的数量不够 训练数据的数量在一定程度上也影响最终模型的效果，特别是采用深度学习等方法，其所需数据量通常比较大。对于图片数据来说，可以通过平移、翻转、裁剪、加噪声等方式进行数据增强（data augmentation）。 训练数据的代表性不足 如果训练数据的代表性不足，通常训练出来的模型的泛化能力也比较弱。在数据采样的时候，如果样本数量较少，那么可能出现采样噪声（sampling noise）的问题；若采样方式错误，即使样本数量很多也可能不具有代表性，依然会出现采样偏差（sampling bias）的问题。 训练数据的质量不好 如果训练数据中充满了错误、异常点、噪声等等，那么训练出的模型也很难检测出原本真实数据中潜在的模式。所以，数据清洗（data cleaning）是整个机器学习过程中不可缺少的一个环节，其结果质量直接关系到模型效果和最终结论。 训练数据的特征与问题不相关 特征工程（feature engineering）其本质上是一项工程活动，它目的是最大限度地从原始数据中提取特征以供算法和模型使用。一般认为，数据和特征决定了机器学习的上限，而模型和算法只能逼近这个上限而已。特征工程一般包括特征选择（feature selection）、特征提取（feature extraction）等部分。 算法模型方面 过拟合（overfitting）问题 模型复杂度过高，训练数据过少，训练误差虽小，但测试误差大。 一般通过正则化（generalization）方式解决，本质上是降低模型的复杂度。 欠拟合（underfitting）问题 模型复杂度过低，不能很好地拟合所有的数据，训练误差大。 测试和验证评估一个模型的好坏，可以测试该模型对新样本的泛化能力。 通常将数据集分为两部分：训练集（training set）和测试集（test set）。其中，训练集用于模型参数的拟合，测试集用于对已经训练好的模型进行性能评估。 如果算法中存在超参数（hyperparameter），那么可以从训练集中再划分出验证集（validation set）来进行调参。 一种常用的验证方式是：k折交叉验证（k-fold cross validation）。k折交叉验证将所有训练样本分成K份，一般每份样本的数量相等或相差不多。取一份作为测试样本，剩余K-1份作为训练样本。这个过程重复K次，取平均值作为最终的验证结果。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"},{"name":"hands-on ML","slug":"hands-on-ML","permalink":"https://orzyt.cn/tags/hands-on-ML/"}]},{"title":"LeetCode501 Find Mode in Binary Search Tree","slug":"leetcode501-find-mode-in-binary-search-tree","date":"2017-09-29T07:06:45.000Z","updated":"2019-02-08T10:26:00.050Z","comments":true,"path":"posts/leetcode501-find-mode-in-binary-search-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode501-find-mode-in-binary-search-tree/","excerpt":"","text":"描述Given a binary search tree (BST) with duplicates, find all the mode(s)) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 样例123456789Input:Given BST [1,null,2,2], 1 \\ 2 / 2Output:2 思路找出二叉搜索树中的众数。 直观的想法是，遍历一遍二叉搜索树，用哈希表来记录每个数出现的次数，维护一个最大值，最后遍历哈希表找出众数即可。这个方法需要申请额外的空间，并且也没有用到BST的性质。 根据二叉搜索树的性质，我们使用中序遍历其实可以得到一个有序的结果。那么问题就转化为：给一个单调递增的数组，找出其中的众数。该问题只需要遍历一遍数组，将每个元素与其前驱元素比较是否相等，然后维护出现次数的最大值，不需要额外空间即可找到众数。 代码哈希表： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: unordered_map&lt;int, int&gt; Map; int maxCnt; void dfs(TreeNode* root) &#123; if (root == nullptr) return ; maxCnt = max(maxCnt, ++Map[root-&gt;val]); dfs(root-&gt;left); dfs(root-&gt;right); &#125; vector&lt;int&gt; findMode(TreeNode* root) &#123; Map.clear(); maxCnt = 0; dfs(root); vector&lt;int&gt; ans; for (auto&amp; x: Map) &#123; if (x.second == maxCnt) &#123; ans.push_back(x.first); &#125; &#125; return ans; &#125;&#125;; 无需额外空间： 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxCnt, curCnt; TreeNode* preNode; void inOrder(TreeNode* root, vector&lt;int&gt;&amp; ans) &#123; if (root == nullptr) return ; inOrder(root-&gt;left, ans); if (preNode) curCnt = (preNode-&gt;val == root-&gt;val) ? curCnt + 1 : 1; if (curCnt &gt;= maxCnt) &#123; if (curCnt &gt; maxCnt) ans.clear(); ans.push_back(root-&gt;val); maxCnt = curCnt; &#125; preNode = root; inOrder(root-&gt;right, ans); &#125; vector&lt;int&gt; findMode(TreeNode* root) &#123; preNode = nullptr; maxCnt = 0, curCnt = 1; vector&lt;int&gt; ans; inOrder(root, ans); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"BST","slug":"BST","permalink":"https://orzyt.cn/tags/BST/"}]},{"title":"LeetCode479 Largest Palindrome Product","slug":"leetcode479-largest-palindrome-product","date":"2017-09-27T13:19:37.000Z","updated":"2019-02-08T10:26:00.102Z","comments":true,"path":"posts/leetcode479-largest-palindrome-product/","link":"","permalink":"https://orzyt.cn/posts/leetcode479-largest-palindrome-product/","excerpt":"","text":"描述Find the largest palindrome made from the product of two n-digit numbers. Since the result could be very large, you should return the largest palindrome mod 1337. Note: The range of n is [1,8]. 样例123456Input: 2Output: 987Explanation: 99 x 91 = 9009, 9009 % 1337 = 987 思路找出两个$n$位数乘积中最大的回文数。 首先，乘积的范围为$[10^{n-1} \\cdot 10^{n-1}, (10^{n} - 1) \\cdot (10^{n} - 1)]$，暴力的方法是遍历每一个数，检查是否为回文的，然后记录其中最大值。复杂度：$\\mathcal{O}(10^{2n})$ 一个可以优化的地方是，不再枚举所有的数，而是枚举所有的回文数，然后再判断这个回文数能否被分解为两个$n$位数的乘积。基于一个事实，两个$n$位数$(2 \\le n \\le 8)$乘积中最大的回文数的位数为$2n$位（本弱不会证明…）。所以只需枚举回文数的左半部分，然后再构造出回文数判断。复杂度：$\\mathcal{O}(10^{1.5n})$ 虽然理论复杂度比较高，但是因为是从大到小枚举，很快便能得到答案，实测只跑了300+ms。 当然，这题还可以本地打表交上去。 代码1234567891011121314151617181920212223class Solution &#123;public: long long palindrome(int x) &#123; long long ret = x; while (x) &#123; ret = ret * 10 + x % 10; x /= 10; &#125; return ret; &#125; int largestPalindrome(int n) &#123; if (n == 1) return 9; long long l = pow(10, n - 1), r = pow(10, n) - 1; for (int i = r; i &gt;= l; --i) &#123; // 枚举回文数左半部分 long long p = palindrome(i); // 构造回文数 for (long long j = r; j * j &gt;= p; --j) &#123; // 判断p能否分解为两个n位数的乘积 // j为其中较大者，故只需枚举到j * j &gt;= p if (p % j == 0) return p % 1337; &#125; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode437 Path Sum III","slug":"leetcode437-path-sum-iii","date":"2017-09-25T09:30:14.000Z","updated":"2019-02-08T10:26:00.362Z","comments":true,"path":"posts/leetcode437-path-sum-iii/","link":"","permalink":"https://orzyt.cn/posts/leetcode437-path-sum-iii/","excerpt":"","text":"描述You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. 样例123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路求二叉树中有多少条权值和为sum的路径。 遍历每个结点，以该结点作为根结点DFS搜索答案。 代码1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 以root为根结点，路径和为sum的数目 int find(TreeNode* root, int sum) &#123; if (root == NULL) return 0; return find(root-&gt;left, sum - root-&gt;val) // 找左儿子中权值和为(sum - root-&gt;val)的路径数 + find(root-&gt;right, sum - root-&gt;val) + (sum == root-&gt;val); // 相等说明找到一条路径 &#125; int pathSum(TreeNode* root, int sum) &#123; if (root == NULL) return 0; return find(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode415 Add Strings","slug":"leetcode415-add-strings","date":"2017-09-25T09:25:02.000Z","updated":"2019-02-08T10:26:00.250Z","comments":true,"path":"posts/leetcode415-add-strings/","link":"","permalink":"https://orzyt.cn/posts/leetcode415-add-strings/","excerpt":"","text":"描述Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 样例12345Input:num1 = &quot;123&quot;num2 = &quot;456&quot;Output:&quot;579&quot; 思路给两个以字符串表示的非负数num1和num2，返回其和。 模拟一遍加法的过程即可。 $sum[i] = (num1[i] + num2[i] + carry[i-1]) \\% 10$ $carry[i] = (num1[i] + num2[i] + carry[i-1]) / 10$ 代码1234567891011121314151617class Solution &#123;public: string addStrings(string num1, string num2) &#123; string ans; int a, b, carry = 0; int n = num1.size(), m = num2.size(), len = max(n, m); for (int i = 0; i &lt; len; ++i) &#123; a = i &lt; n ? num1[n-1-i] - '0' : 0; b = i &lt; m ? num2[m-1-i] - '0' : 0; ans += char(((a + b + carry) % 10) + '0'); carry = (a + b + carry) / 10; &#125; if (carry &gt; 0) ans += char(carry + '0'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode414 Third Maximum Number","slug":"leetcode414-third-maximum-number","date":"2017-09-25T09:11:29.000Z","updated":"2019-02-08T10:26:00.094Z","comments":true,"path":"posts/leetcode414-third-maximum-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode414-third-maximum-number/","excerpt":"","text":"描述Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 样例12345Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. 12345Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. 123456Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 思路找出数组中第三小的数。 模拟题。 如果一个数大于当前第一大数，那么更新第一、二、三大数。 如果只大于当前第二大数，那么更新第二、三大数。 如果只大于当前第三大数，那么更新第三大数。 注意相等情况的处理。 代码1234567891011121314151617181920class Solution &#123;public: const long long oo = 1e18; int thirdMax(vector&lt;int&gt;&amp; nums) &#123; long long firstNum = -oo, secondNum = -oo, thirdNum = -oo; for (int&amp; x: nums) &#123; if (x &gt;= firstNum) &#123; // 等于的情况也要归进来，不然会被拿去更新第二、三大数。 if (x == firstNum) continue; thirdNum = secondNum; secondNum = firstNum; firstNum = x; &#125; else if (x &gt;= secondNum) &#123; if (x == secondNum) continue; thirdNum = secondNum; secondNum = x; &#125; else if (x &gt;= thirdNum) thirdNum = x; &#125; return (thirdNum == -oo) ? firstNum : thirdNum; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode413 Arithmetic Slices","slug":"leetcode413-arithmetic-slices","date":"2017-09-25T08:20:15.000Z","updated":"2019-02-08T10:26:00.130Z","comments":true,"path":"posts/leetcode413-arithmetic-slices/","link":"","permalink":"https://orzyt.cn/posts/leetcode413-arithmetic-slices/","excerpt":"","text":"描述A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1231, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9 The following sequence is not arithmetic. 11, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N. A slice (P, Q) of array A is called arithmetic if the sequence:A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q. The function should return the number of arithmetic slices in the array A. 样例1234567Input:A = [1, 2, 3, 4]Output:3for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. 思路给一个序列，找出其中有多少个连续的子序列是等差序列。 一个直观的想法是，双指针扫一遍数组，每次确定一个最长的等差序列$a[l..r]$，那么这个等差序列对答案的贡献是 $(len - 2) * (len - 1) / 2$，其中$len = r - l + 1$。 另一个做法是使用动态规划，设$dp[i]$表示以$a[i]$结尾的等差序列的个数。 如果$a[i] - a[i-1] == a[i-1] - a[i-2]$，那么有$dp[i] = dp[i-1] + 1$，否则$dp[i] = 0$。 其中$dp[i] = dp[i-1] + 1$是怎么来的呢？ 根据条件$a[i] - a[i-1] == a[i-1] - a[i-2]$我们知道，所有以$a[i-1]$结尾的等差序列，现在加上$a[i]$之后依然是等差序列。同时，还新增一个只有3个元素的等差序列$a[i-2 .. i]$，所以$dp[i] = dp[i-1] + 1$。 最后，答案$ans = \\sum^{n-1}_{i=0} {dp[i]}$ 代码双指针：12345678910111213141516171819class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int ans = 0, n = A.size(); if (n &lt; 3) return 0; // 小于3个元素，答案为0 int diff = A[1] - A[0]; // 当前序列的公差 int l = 0, r = 2, len; while (l &lt; n &amp;&amp; r &lt; n) &#123; // 更新等差序列的右端点r while (r &lt; n &amp;&amp; A[r] - A[r - 1] == diff) r++; len = r - l; // 当前等差序列为a[l..r-1] // 计算该序列贡献的答案 if (len &gt;= 3) ans += (len - 2) * (len - 1) / 2; l = r - 1; r++; // 更新左右端点 if (l + 1 &lt; n) diff = A[l + 1] - A[l]; // 更新公差 &#125; return ans; &#125;&#125;; DP：1234567891011121314151617class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int ans = 0, n = A.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); // 初始化 dp[2] = (A[2] - A[1] == A[1] - A[0]); ans += dp[2]; for (int i = 3; i &lt; n; ++i) &#123; if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; dp[i] = dp[i - 1] + 1; &#125; ans += dp[i]; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"https://orzyt.cn/tags/DP/"}]},{"title":"LeetCode367 Valid Perfect Square","slug":"leetcode367-valid-perfect-square","date":"2017-09-15T12:41:30.000Z","updated":"2019-02-08T10:26:00.126Z","comments":true,"path":"posts/leetcode367-valid-perfect-square/","link":"","permalink":"https://orzyt.cn/posts/leetcode367-valid-perfect-square/","excerpt":"","text":"描述Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. 样例12Input: 16Returns: True 思路判断一个数是否是完全平方数。 和这题LeetCode69 Sqrt(x)几乎一模一样。 只需在返回的时候判断二分搜索出来的答案，其平方之后还会不会与num相等即可。复杂度$\\mathcal{O}(logn)$ 还有一种解法是，根据奇数和通项公式：$1+3+5+ \\cdots + (2n-1) = n^2$ ，把num每次 -1、-3、-5…，看最后能否正好减到零。复杂度$\\mathcal{O}(\\sqrt n)$ 代码123456789101112class Solution &#123;public: bool isPerfectSquare(int num) &#123; long long l = 0, r = num, m; while (l &lt; r) &#123; m = l + (r - l + 1) / 2; if (m * m &lt;= num) l = m; else r = m - 1; &#125; return l * l == num; &#125;&#125;; 1234567891011class Solution &#123;public: bool isPerfectSquare(int num) &#123; int i = 1; while (num &gt; 0) &#123; num -= i; i += 2; &#125; return num == 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode345 Reverse Vowels of a String","slug":"leetcode345-reverse-vowels-of-a-string","date":"2017-09-15T12:34:43.000Z","updated":"2019-02-08T10:26:00.210Z","comments":true,"path":"posts/leetcode345-reverse-vowels-of-a-string/","link":"","permalink":"https://orzyt.cn/posts/leetcode345-reverse-vowels-of-a-string/","excerpt":"","text":"描述Write a function that takes a string as input and reverse only the vowels of a string. 样例1234Input:&quot;hello&quot;Output:&quot;holle&quot; 思路给一个字符串，只翻转字符串中的元音字符。 在普通的翻转中，加入对元音字符的判断，使得指针每次只能指向元音。 代码12345678910111213141516class Solution &#123;public: bool check(char c) &#123; c = tolower(c); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'; &#125; string reverseVowels(string s) &#123; int l = 0, r = s.size()-1; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; !check(s[l])) l++; while (l &lt; r &amp;&amp; !check(s[r])) r--; if (l &lt; r) swap(s[l++], s[r--]); &#125; return s; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode342 Power of Four","slug":"leetcode342-power-of-four","date":"2017-09-15T12:03:49.000Z","updated":"2019-02-08T10:26:00.478Z","comments":true,"path":"posts/leetcode342-power-of-four/","link":"","permalink":"https://orzyt.cn/posts/leetcode342-power-of-four/","excerpt":"","text":"描述Given an integer (signed 32 bits), write a function to check whether it is a power of 4. 样例1234Input:16Output:true 思路判断一个数是否是4的次幂。 做过这题LeetCode231 Power of Two的话，应该知道怎么判断一个数是否是2的次幂。 4次幂数显然满足2次幂数的性质，进一步观察发现，4次幂数二进制下“1”的位置只能在第0、2、…等偶数位。 因此，4次幂数如果和0x55555555相与的话，可以得到非零数，这就剔除了那些是2次幂数但不是4次幂数的数。 代码123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; !(num &amp; (num-1)) &amp;&amp; (num &amp; 0x55555555); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode190 Reverse Bits","slug":"leetcode190-reverse-bits","date":"2017-09-15T11:05:53.000Z","updated":"2019-02-08T10:26:00.474Z","comments":true,"path":"posts/leetcode190-reverse-bits/","link":"","permalink":"https://orzyt.cn/posts/leetcode190-reverse-bits/","excerpt":"","text":"描述Reverse bits of a given 32 bits unsigned integer. 样例1234Input:43261596 (represented in binary as 00000010100101000001111010011100)Output:964176192 (represented in binary as 00111001011110000010100101000000) 思路翻转32bits无符号整数。 暴力的做法是，对称着遍历然后swap即可。 不过，还有类似LeetCode191 Number of 1 Bits的优雅做法 (ﾉﾟ∀ﾟ)ﾉ 比如，翻转32bits无符号整数1001 1011 0101 0010 1001 1111 0001 0010 那么可以先每16位翻转 123Input: [1001 1011 0101 0010] [1001 1111 0001 0010] XOutput: [1001 1111 0001 0010] [1001 1011 0101 0010] 再每8位翻转 123Input: [1001 1111] [0001 0010] | [1001 1011] [0101 0010] X | XOutput: [0001 0010] [1001 1111] | [0101 0010] [1001 1011] 接着每4位翻转 123Input: [0001] [0010] | [1001] [1111] | [0101] [0010] | [1001] [1011] X | X | X | X Output: [0010] [0001] | [1111] [1001] | [0010] [0101] | [1011] [1001] 然后每2位翻转 …（就不给出具体的过程啦） 最后每1位翻转即可得到答案 0100 1000 1111 1001 0100 1010 1101 1001 如果有仔细阅读LeetCode191 Number of 1 Bits 这篇文章，代码应该不难实现 (～￣▽￣)～ 代码12345678910111213141516class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; int l = 0, r = 31; while (l &lt; r) &#123; // 当前比特位不相同 if (((n &gt;&gt; l) &amp; 1) ^ ((n &gt;&gt; r) &amp; 1)) &#123; // 各自取反 n ^= (1 &lt;&lt; l); n ^= (1 &lt;&lt; r); &#125; l++; r--; &#125; return n; &#125;&#125;; 1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; n = (n &gt;&gt; 16) | (n &lt;&lt; 16); n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8); n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4); n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2); n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1); return n; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode307 Range Sum Query-Mutable","slug":"leetcode307-range-sum-query-mutable","date":"2017-09-10T13:25:14.000Z","updated":"2019-02-08T10:26:00.010Z","comments":true,"path":"posts/leetcode307-range-sum-query-mutable/","link":"","permalink":"https://orzyt.cn/posts/leetcode307-range-sum-query-mutable/","excerpt":"","text":"描述Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. 样例12345Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 思路要求对数组支持单点修改，区间查询操作。 树状数组 模板题，修改、查询复杂度都是$\\mathcal{O}(logn)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class NumArray &#123;private: int* sum; int n;public: int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int i, int x) &#123; while (i &lt;= n) &#123; sum[i] += x; i += lowbit(i); &#125; &#125; int getSum(int i) &#123; int ans = 0; while (i &gt; 0) &#123; ans += sum[i]; i -= lowbit(i); &#125; return ans; &#125; NumArray(vector&lt;int&gt; nums) &#123; n = nums.size(); sum = new int[n + 1]; fill(sum, sum + n + 1, 0); for (int i = 0; i &lt; n; ++i) &#123; add(i + 1, nums[i]); &#125; &#125; void update(int i, int val) &#123; add(i + 1, val - sumRange(i, i)); &#125; int sumRange(int i, int j) &#123; return getSum(j + 1) - getSum(i); &#125;&#125;;/* * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树状数组","slug":"树状数组","permalink":"https://orzyt.cn/tags/树状数组/"}]},{"title":"LeetCode303 Range Sum Query-Immutable","slug":"leetcode303-range-sum-query-immutable","date":"2017-09-10T13:20:14.000Z","updated":"2019-02-08T10:26:00.042Z","comments":true,"path":"posts/leetcode303-range-sum-query-immutable/","link":"","permalink":"https://orzyt.cn/posts/leetcode303-range-sum-query-immutable/","excerpt":"","text":"描述Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Note: You may assume that the array does not change. There are many calls to sumRange function. 样例12345Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 思路查询数组的区间和。 其中数组元素不会改变，会有频繁的查询操作。 $\\mathcal{O}(n)$预处理出前缀和，然后$\\mathcal{O}(1)$查询即可。 代码1234567891011121314151617181920212223class NumArray &#123;private: int* sum;public: NumArray(vector&lt;int&gt; nums) &#123; int n = nums.size(); sum = new int[n + 1]; sum[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i-1] + nums[i-1]; &#125; &#125; int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i]; &#125;&#125;;/* * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(i,j); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode278 First Bad Version","slug":"leetcode278-first-bad-version","date":"2017-09-10T13:08:52.000Z","updated":"2019-02-08T10:26:00.474Z","comments":true,"path":"posts/leetcode278-first-bad-version/","link":"","permalink":"https://orzyt.cn/posts/leetcode278-first-bad-version/","excerpt":"","text":"描述You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. 样例1无 思路在$n$个版本的产品中，找出第一个坏版本。 有一个性质是，坏版本之后的版本都是坏版本。使用普通的二分搜索即可，如果当前版本是坏版本，那么减少上界，否则增加下界。 代码123456789101112131415// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l = 1, r = n, m; while (l &lt; r) &#123; m = l + (r - l) / 2; if (isBadVersion(m)) r = m; else l = m + 1; &#125; return r; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode101 Symmetric Tree","slug":"leetcode101-symmetric-tree","date":"2017-09-10T11:34:06.000Z","updated":"2019-02-08T10:26:00.366Z","comments":true,"path":"posts/leetcode101-symmetric-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode101-symmetric-tree/","excerpt":"","text":"描述Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). 样例12345678910Input:[1,2,2,3,4,4,3] 1 / \\ 2 2 / \\ / \\3 4 4 3Output:true 12345678910Input:[1,2,2,null,3,null,3] 1 / \\ 2 2 \\ \\ 3 3Output:false 思路判断一颗二叉树是否是对称的。 首先判断给定的二叉树是否是空树，空树也算是对称的。 然后判断左右子树是否是对称的。即判断左右子树的值是否相等，并且递归下去判断「左子树的左儿子」和「右子树的右儿子」是否是对称的，以及「左子树的右儿子」和「右子树的左儿子」是否是对称的。 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // 判断左右子树是否相等 bool check(TreeNode* l, TreeNode* r) &#123; // 两棵都是空树 if (!l &amp;&amp; !r) return true; // 有一棵不是空树 if (!l ^ !r) return false; return l-&gt;val == r-&gt;val &amp;&amp; check(l-&gt;left, r-&gt;right) &amp;&amp; check(l-&gt;right, r-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; if (root == nullptr) return true; return check(root-&gt;left, root-&gt;right); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode172 Factorial Trailing Zeroes","slug":"leetcode172-factorial-trailing-zeroes","date":"2017-09-09T13:50:13.000Z","updated":"2019-02-08T10:26:00.142Z","comments":true,"path":"posts/leetcode172-factorial-trailing-zeroes/","link":"","permalink":"https://orzyt.cn/posts/leetcode172-factorial-trailing-zeroes/","excerpt":"","text":"描述Given an integer $n$, return the number of trailing zeroes in $n!$.Note: Your solution should be in logarithmic time complexity. 样例1234Input:10Output:2 思路求$n!$末尾零的个数。 不难发现，其末尾的零来源于$n!=1 × 2 × \\cdots × n$这一乘法过程中产生了多少个$10$。而$10 = 2 × 5$，因此要统计其中有多少个$2$和多少个$5$，但是由于$2$的数量多于$5$的数量，故只需统计$5$的数量即可。 现在问题转化为：求$n!=1 × 2 × \\cdots × n$中有多少个$5$。 显然，能被$5$整除的数至少能贡献$1$个$5$，若同时又能被$5^2$整除，则还可以再贡献一个$5$，若继续能被$5^3$整除，那么还可以再贡献一个$5$… 所以，$ans = \\lfloor n / 5\\rfloor + \\lfloor n / 5^2\\rfloor + \\lfloor n / 5^3\\rfloor + … $ 算法时间复杂度：$\\mathcal{O}(log_{5}n)$ 代码1234567891011class Solution &#123;public: int trailingZeroes(int n) &#123; int ans = 0; while (n) &#123; ans += n / 5; n /= 5; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode669 Trim a Binary Search Tree","slug":"leetcode669-trim-a-binary-search-tree","date":"2017-09-05T09:40:16.000Z","updated":"2019-02-08T10:26:00.358Z","comments":true,"path":"posts/leetcode669-trim-a-binary-search-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode669-trim-a-binary-search-tree/","excerpt":"","text":"描述Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. 样例123456789101112Input: 1 / \\ 0 2 L = 1 R = 2Output: 1 \\ 2 123456789101112131415161718Input: 3 / \\ 0 4 \\ 2 / 1 L = 1 R = 3Output: 3 / 2 / 1 思路修剪一颗二叉搜索树，使其权值都位于$[L, R]$之间。 考虑任意一个结点node。 若其权值小于$L$，根据BST的性质（左子树上所有结点的值均小于它的根节点的值，右子树上所有结点的值均大于它的根节点的值），其左子树（包括node本身）应该被修剪掉，此时node结点应该由被修剪后的右子树替代（即使修剪后的右子树变成空树也无妨）。 同理，若其权值大于$R$，根据BST的性质，其右子树（包括node本身）应该被修剪掉，此时node结点应该由被修剪后的左子树替代。 若权值正好在$[L, R]$区间内，那么node结点不变，继续递归下去修剪左右子树。 代码1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if (root == nullptr) return root; if (root-&gt;val &lt; L) return trimBST(root-&gt;right, L, R); if (root-&gt;val &gt; R) return trimBST(root-&gt;left, L, R); root-&gt;left = trimBST(root-&gt;left, L, R); root-&gt;right = trimBST(root-&gt;right, L, R); return root; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"},{"name":"BST","slug":"BST","permalink":"https://orzyt.cn/tags/BST/"}]},{"title":"LeetCode671 Second Minimum Node In a Binary Tree","slug":"leetcode671-second-minimum-node-in-a-binary-tree","date":"2017-09-05T08:36:29.000Z","updated":"2019-02-08T10:26:00.038Z","comments":true,"path":"posts/leetcode671-second-minimum-node-in-a-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode671-second-minimum-node-in-a-binary-tree/","excerpt":"","text":"描述Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. 样例123456789Input: 2 / \\ 2 5 / \\ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5. 1234567Input: 2 / \\ 2 2Output: -1Explanation: The smallest value is 2, but there isn&apos;t any second smallest value. 思路给一颗非空的二叉树，结点权值为非负数。这棵二叉树有一个特殊的性质：每个结点要么没有儿子结点，要么一定有两个儿子结点，并且两个儿子结点的权值都大等于该节点的权值。现在，要求出这颗二叉树中第二小的权值是多少，若不存在则输出“-1”。 根据其性质，显然最小值为根结点的权值。那么，第二小的权值就应该等于除了根结点权值外的那个最小值。 所以，从根结点开始，若当前节点权值等于根结点权值，那么继续$dfs$下去。直到不相等的时候，说明该权值有可能是候选答案，与当前最优答案取个$min$即可，并且此时也不用继续搜下去，根据其性质可知后代结点不可能是答案。 对于不存在的情况，一开始可以设置答案$ans$为无穷大（由于val是int类型，因此可以设置为INT_MAX）。若$dfs$结束之后，$ans$没有改变的话，说明不存在答案，此时输出“-1”即可。 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void dfs(TreeNode* root, int minVal, int&amp; ans) &#123; if (root == nullptr) return ; if (root-&gt;val == minVal) &#123; dfs(root-&gt;left, minVal, ans); dfs(root-&gt;right, minVal, ans); &#125; else ans = min(ans, root-&gt;val); &#125; int findSecondMinimumValue(TreeNode* root) &#123; int ans = INT_MAX; dfs(root, root-&gt;val, ans); return ans == INT_MAX ? -1 : ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"}]},{"title":"LeetCode264 Ugly Number II","slug":"leetcode264-ugly-number-ii","date":"2017-09-03T12:22:46.000Z","updated":"2019-02-08T10:26:00.474Z","comments":true,"path":"posts/leetcode264-ugly-number-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode264-ugly-number-ii/","excerpt":"","text":"描述Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. 样例1234Input:10Output:12 思路输出第$n$个“丑数”。 不难发现，任意一个“丑数”都是通过其之前某个“丑数”乘2、3或5得到的。 那么，我们就可以从初始条件$dp[1] = 1$开始递推出整个“丑数”序列。 123456781×2, …↑1×3, …↑1×5, …↑dp[2] = min(dp[1] * 2, dp[1] * 3, dp[1] * 5) = 2; 同时指向“2”的指针右移一格; 123456781×2, 2×2, … ↑1×3, 2×3, …↑1×5, 2×5, …↑dp[3] = min(dp[2] * 2, dp[1] * 3, dp[1] * 5) = 3; 同时指向“3”的指针右移一格; 123456781×2, 2×2, 3×2… ↑1×3, 2×3, 3×3… ↑1×5, 2×5, 3×5…↑dp[4] = min(dp[2] * 2, dp[2] * 3, dp[1] * 5) = 4; 同时指向“2”的指针右移一格; 123456781×2, 2×2, 3×2, 4×2… ↑1×3, 2×3, 3×3, 4×3… ↑1×5, 2×5, 3×5, 4×5…↑dp[5] = min(dp[3] * 2, dp[2] * 3, dp[1] * 5) = 5; 同时指向“5”的指针右移一格; 123456789101×2, 2×2, 3×2, 4×2, 5×2,… ↑1×3, 2×3, 3×3, 4×3, 5×3,… ↑1×5, 2×5, 3×5, 4×5, 5×5,… ↑dp[6] = min(dp[3] * 2, dp[2] * 3, dp[2] * 5) = 6; 注意到此时，dp[3] * 2 和 dp[2] * 3同时取到最小值，那么，指向“2”的指针和指向“3”的指针应该同时右移一格，不然得到的序列中将出现重复元素。 以此类推，最终就可以得到答案 代码1234567891011121314class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n, 1); int idx_2 = 0, idx_3 = 0, idx_5 = 0; for (int i = 1; i &lt; n; ++i) &#123; dp[i] = min(dp[idx_2] * 2, min(dp[idx_3] * 3, dp[idx_5] * 5)); if (dp[i] == dp[idx_2] * 2) idx_2++; if (dp[i] == dp[idx_3] * 3) idx_3++; if (dp[i] == dp[idx_5] * 5) idx_5++; &#125; return dp[n - 1]; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"https://orzyt.cn/tags/DP/"}]},{"title":"LeetCode263 Ugly Number","slug":"leetcode263-ugly-number","date":"2017-09-03T12:17:02.000Z","updated":"2019-02-08T10:26:00.230Z","comments":true,"path":"posts/leetcode263-ugly-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode263-ugly-number/","excerpt":"","text":"描述Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 样例1234Input:10Output:true 思路判断一个数的质因数是否只有2、3、5。 模拟一遍，不断用2、3、5去整除num，看能否能被除尽。 注意特判非正数的情况。 代码123456789class Solution &#123;public: bool isUgly(int num) &#123; if (num &lt;= 0) return false; int factor[3] = &#123;2, 3, 5&#125;; for (auto&amp; x: factor) while (num % x == 0) num /= x; return num == 1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"}]},{"title":"LeetCode204 Count Primes","slug":"leetcode204-count-primes","date":"2017-09-02T13:48:43.000Z","updated":"2019-02-08T10:26:00.474Z","comments":true,"path":"posts/leetcode204-count-primes/","link":"","permalink":"https://orzyt.cn/posts/leetcode204-count-primes/","excerpt":"","text":"描述Count the number of prime numbers less than a non-negative number, n. 样例1无 思路统计前$n$个数中有多少个素数。 可以用Eratosthenes筛法或Euler筛法，详见素数筛法。 代码123456789101112131415class Solution &#123;public: int countPrimes(int n) &#123; bool* isPrime = new bool[n]; fill(isPrime, isPrime+n, true); int ans = 0; for (int i = 2; i &lt; n; ++i) &#123; if (isPrime[i]) &#123; ans++; for (int j = 2*i; j &lt; n; j += i) isPrime[j] = false; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode202 Happy Number","slug":"leetcode202-happy-number","date":"2017-09-02T12:57:17.000Z","updated":"2019-02-08T10:26:00.278Z","comments":true,"path":"posts/leetcode202-happy-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode202-happy-number/","excerpt":"","text":"描述Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number $1^2 + 9^2 = 82$ $8^2 + 2^2 = 68$ $6^2 + 8^2 = 100$ $1^2 + 0^2 + 0^2 = 1$ 样例1234Input:19Output:true 思路判断一个数是否是“happy”的。 “happy”的定义是每次将数$n$替换为其各数位的平方和，若最终得到1，则该数为“happy”。 如果一个数是“happy”的，可以直接模拟一遍，看是否得到1。但如果不是“happy”的话，那么模拟将陷入死循环，进入到一个不包含1的圈里。 这里介绍一个Floyd判圈算法，又称龟兔赛跑算法。该算法可以在有限状态机、迭代函数或者链表上判断是否存在环。如果从同一个起点(即使这个起点不在某个环上)，同时开始以不同速度前进的两个指针最终相遇，那么可以判定存在一个环。 我们假设龟以1×的速度，兔以2×的速度从起点出发。若途中不存在圈，那么兔将率先到达终点。但是如果存在圈的话，龟兔便会在圈中相遇。此时兔必然是领先龟数圈，然后从后方追上龟。 代码1234567891011121314151617181920class Solution &#123;public: // 计算数位平方和 int cal(int n) &#123; int ans = 0; while (n) &#123; ans += (n % 10) * (n % 10); n /= 10; &#125; return ans; &#125; bool isHappy(int n) &#123; int fast = n, slow = n; // 相同起点 do &#123; slow = cal(slow); // 模拟龟，1×速度 fast = cal(cal(fast)); // 模拟兔，2×速度 &#125; while (slow != fast); // 直到相遇 return slow == 1; // 为1则在终点相遇，否则在圈中相遇 &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode191 Number of 1 Bits","slug":"leetcode191-number-of-1-bits","date":"2017-09-01T12:32:44.000Z","updated":"2019-02-08T10:26:00.170Z","comments":true,"path":"posts/leetcode191-number-of-1-bits/","link":"","permalink":"https://orzyt.cn/posts/leetcode191-number-of-1-bits/","excerpt":"","text":"描述Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). 样例1234Input:00000000000000000000000000001011Output:3 思路统计32位无符号数中”1”的个数。 思路同LeetCode338 Counting Bits。 今天再介绍一种基于「分治」的算法来统计”1”的个数。 假设现在我们要统计1001 1011 0101 0010 1001 1111 0001 0010中“1”的个数。 基于分治的思想，我们先统计出每2位有多少个1，如图中第①层所示。 将每2位的结果合并，统计出每4位有多少个1，如图中第②层所示。 再将每4位的结果合并，统计出每8位有多少个1，如图中第③层所示。 接着将每8位的结果合并，统计出每16位有多少个1，如图中第④层所示。 最后将每16位的结果合并，统计出每32位有多少个1，如图中第⑤层所示，即可得到答案。 好了，有了一个直观的感受后，现在考虑如何实现合并的过程。 初始的$n$为： 1001 1011 0101 0010 1001 1111 0001 0010， 第①层的结果为：0101 0110 0101 0001 0101 1010 0001 0001，这该怎么得到呢? 一条语句即可搞定！ n = (n &amp; (0x55555555)) + ((n &gt;&gt; 1) &amp; (0x55555555)); 很神奇有木有，让我们来分析一下这条语句干了什么！ 首先，十六进制的常数0x55555555转化为二进制是0101 0101 0101 0101 0101 0101 0101 0101 0101。 那么，n &amp; 0x55555555就可以提取$n$偶数位上的1： (n &gt;&gt; 1) &amp; 0x55555555就可以提取$n$奇数位上的1： 最后，n = (n &amp; (0x55555555)) + ((n &gt;&gt; 1) &amp; (0x55555555))把这两个结果相加，即可得到每两位上“1”的个数。 这就得到第①层的结果啦。 现在考虑怎么得到第②层的结果。 既然得到每2位的结果是通过常数0101 0101 0101 0101 0101 0101 0101 0101，即0x55555555得到的。 那么类比一下，每4位就应该是通过常数0011 0011 0011 0011 0011 0011 0011 0011，即0x3333333得到。 经过第一层，此时$n$更新为0101 0110 0101 0001 0101 1010 0001 0001。 那么，n &amp; 0x33333333就等于： (n &gt;&gt; 2) &amp; 0x33333333 （注意，现在要右移两位）就等于： 最后，n = (n &amp; (0x33333333)) + ((n &gt;&gt; 2) &amp; (0x33333333));相加即可得到每四位上“1”的个数。 这就得到第②层的结果啦。 以此类推… 合并每4位，得到每8位的结果。常数为：0000 1111 0000 1111 0000 1111 0000 1111，即0x0F0F0F0F。 因此有n = (n &amp; (0x0F0F0F0F)) + ((n &gt;&gt; 4) &amp; (0x0F0F0F0F)); 合并每8位，得到每16位的结果。常数为：0000 0000 1111 1111 0000 0000 1111 1111，即0x00FF00FF。 因此有n = (n &amp; (0x00FF00FF)) + ((n &gt;&gt; 8) &amp; (0x00FF00FF)); 合并每16位，得到每32位的结果。常数为：0000 0000 0000 0000 1111 1111 1111 1111，即0x0000FFFF。 因此有n = (n &amp; (0x0x0000FFFF)) + ((n &gt;&gt; 16) &amp; (0x0x0000FFFF)); 最后得到 n = 16，即最开始所求的32位数1001 1011 0101 0010 1001 1111 0001 0010中有16个“1”。 代码12345678class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int ans = 0; while (n) ans++, n &amp;= (n-1); return ans; &#125;&#125;; 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; n = (n &amp; (0x55555555)) + ((n &gt;&gt; 1) &amp; (0x55555555)); n = (n &amp; (0x33333333)) + ((n &gt;&gt; 2) &amp; (0x33333333)); n = (n &amp; (0x0F0F0F0F)) + ((n &gt;&gt; 4) &amp; (0x0F0F0F0F)); n = (n &amp; (0x00FF00FF)) + ((n &gt;&gt; 8) &amp; (0x00FF00FF)); n = (n &amp; (0x0000FFFF)) + ((n &gt;&gt; 16) &amp; (0x0000FFFF)); return n; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode168 Excel Sheet Column Title","slug":"leetcode168-excel-sheet-column-title","date":"2017-09-01T12:04:13.000Z","updated":"2019-02-08T10:26:00.210Z","comments":true,"path":"posts/leetcode168-excel-sheet-column-title/","link":"","permalink":"https://orzyt.cn/posts/leetcode168-excel-sheet-column-title/","excerpt":"","text":"描述Given a positive integer, return its corresponding column title as appear in an Excel sheet. 样例12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB 思路将数字转换为excel的表头。 本质上还是二十六进制的转换。由于是从1开始，故转换的时候要减掉一。 代码123456789101112class Solution &#123;public: string convertToTitle(int n) &#123; string ans; while (n &gt; 0) &#123; ans += char((--n) % 26 + 'A'); n /= 26; &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode167 Two Sum II Input array is sorted","slug":"leetcode167-two-sum-ii-input-array-is-sorted","date":"2017-09-01T11:41:58.000Z","updated":"2019-02-08T10:26:00.054Z","comments":true,"path":"posts/leetcode167-two-sum-ii-input-array-is-sorted/","link":"","permalink":"https://orzyt.cn/posts/leetcode167-two-sum-ii-input-array-is-sorted/","excerpt":"","text":"描述Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 样例1234Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 思路给一个递增的数组，从中找到两个元素使得它们的和等于给定的目标。 题目保证存在唯一解，并且同一个元素不能使用两次。 暴力的做法是枚举两个元素，复杂度$\\mathcal{O}(n^2)$。 由于数组单调递增，可以枚举一个元素，然后二分搜索另外一个元素，复杂度$\\mathcal{O}(logn)$。 再来考虑双指针的做法，$l$指向第一个元素，$r$指向第二个元素，由于数组有序，因此可以根据nums[l] + nums[r] 和 target的大小关系来更新$l$或$r$。 代码二分 123456789101112131415161718192021222324252627class Solution &#123;public: // 标准的二分查找 int find(vector&lt;int&gt;&amp; nums, int key) &#123; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &lt; key) l = m + 1; else r = m; &#125; if (nums[r] == key) return r; return -1; &#125; vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int n = numbers.size(); vector&lt;int&gt; ans; for (int i = 0; i &lt; n; ++i) &#123; int j = find(numbers, target - numbers[i]); if (i != j &amp;&amp; j != -1) &#123; ans.push_back(min(i, j) + 1); ans.push_back(max(i, j) + 1); break; &#125; &#125; return ans; &#125;&#125;; 双指针 123456789101112class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int l = 0, r = numbers.size() - 1; while (numbers[l] + numbers[r] != target) &#123; if (numbers[l] + numbers[r] &lt; target) l++; else r--; &#125; //vector构造函数之一：通过list构造 return vector&lt;int&gt;(&#123;l + 1, r + 1&#125;); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode154 Find Minimum in Rotated Sorted Array II","slug":"leetcode154-find-minimum-in-rotated-sorted-array-ii","date":"2017-08-31T14:26:20.000Z","updated":"2019-02-08T10:26:00.014Z","comments":true,"path":"posts/leetcode154-find-minimum-in-rotated-sorted-array-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode154-find-minimum-in-rotated-sorted-array-ii/","excerpt":"","text":"描述 Follow up for “Find Minimum in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. 样例1234Input:[3, 3, 3, 1, 2, 3]Output:1 思路LeetCode153 Find Minimum in Rotated Sorted Array的加强版，现在多了元素会重复这个条件。 由于原始数组单调，不妨考虑二分，但是怎么更新$l$和$r$呢？ 如果此时位于$mid$的元素大于位于$r$的元素，那么说明$mid$正位于中枢元素的左侧（中枢元素就是0），即$[l, mid]$这一段区间都不可能是答案，于是更新l = mid + 1。 反之，说明$mid$位于中枢元素的右侧（或者就是中枢元素本身），于是更新r = mid。 两道题的思路其实差不多，但是现在得考虑元素重复带来的影响。 也就是说如果出现$mid$的元素和$r$的元素相等的情况该怎么办？更新$l$还是更新$r$，以及怎么更新？ 比如对于样例 123[3, 3, 3, 1, 2, 3] ↑ ↑ ↑l=0 mid=2 r=5 可能会认为此时应该l = mid + 1。 再考虑如下样例 123[3, 1, 2, 3, 3, 3, 3] ↑ ↑ ↑l=0 mid=3 r=6 此时又应该是r = mid。 出现这种情况的原因是，我们没办法判断中枢元素到底位于mid的左侧还是右侧，也就没办法进行相应的更新。 因此，遇到$mid$元素和$r$元素相等的情况，需要考虑打破这种相等状态，一种可能的方式是：只是将 $r$减一。 万一nums[r]是答案，将$r$减一会不会让最小值丢失？ 不会的，因为nums[r] == nums[mid]，中间的nums[mid]还在呢。 那为什么不是将$l$加一，不是也有可能改变相等的情况吗？ 因为现在的写法是$mid$和$r$比较。在这种写法下，如果通过$l$加1来打破相等状态，有可能会越过中枢元素。 比如考虑如下样例 12345第一次二分：[3, 1, 2, 3, 3, 3, 3] ↑ ↑ ↑l=0 mid=3 r=6mid元素和r元素相等，l++ 123456第二次二分：[3, 1, 2, 3, 3, 3, 3] ↑ ↑ ↑ l=1 mid=3 r=6mid元素还是和r元素相等，l++此时l=2，已经越过了中枢元素 因此如果想用$l$加1，那么在二分的时候就得用$mid$和$l$做比较。 但是还是不推荐用$l$来和$mid$作比较，考虑如下样例 123[1, 3]l = 0, r = 1, mid = 0l和mid相等，l++，又错过了中枢元素... 因此遇到相等的情况，仅仅让$r$减一是比较保险的做法。 接下来说说复杂度的事情。 虽然打着“二分”的旗号，可能认为复杂度是$\\mathcal{O}(logn)$。 在没有重复元素的时候，复杂度确实是这样，但是有重复元素的时候，却要小心了。 考虑样例 [1, 1, 1, 1, 1, 1] 那么每次都会碰到相等的情况，只能简单的r--，相当于遍历一遍数组，复杂度又退化到$\\mathcal{O}(n)$了。 代码1234567891011121314class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; int cnt = 0; while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &gt; nums[r]) l = m + 1; else if (nums[m] &lt; nums[r]) r = m; else r--; &#125; return nums[l]; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode153 Find Minimum in Rotated Sorted Array","slug":"leetcode153-find-minimum-in-rotated-sorted-array","date":"2017-08-31T14:01:03.000Z","updated":"2019-02-08T10:26:00.294Z","comments":true,"path":"posts/leetcode153-find-minimum-in-rotated-sorted-array/","link":"","permalink":"https://orzyt.cn/posts/leetcode153-find-minimum-in-rotated-sorted-array/","excerpt":"","text":"描述Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 样例1234Input:[4, 5, 6, 7, 0, 1, 2]Output:0 思路递增的原始数组（没有重复的元素），经过某个中枢元素旋转后，得到一个新的数组。现在只给出新数组，求其中最小的元素。 直接遍历新数组，就可以找到最小的元素，复杂度$\\mathcal{O}(n)$，但这显然不是我们想要的。 由于原始数组单调，不妨考虑二分，但是怎么更新$l$和$r$呢？ 如果此时位于$mid$的元素大于位于$r$的元素，那么说明$mid$正位于中枢元素的左侧（中枢元素就是0），即$[l, mid]$这一段区间都不可能是答案，于是更新l = mid + 1。 反之，说明$mid$位于中枢元素的右侧（或者就是中枢元素本身），于是更新r = mid。 代码123456789101112class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int m = l + (r - l) / 2; if (nums[m] &gt; nums[r]) l = m + 1; else r = m; &#125; return nums[l]; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode102 Binary Tree Level Order Traversal","slug":"leetcode102-binary-tree-level-order-traversal","date":"2017-08-31T13:39:20.000Z","updated":"2019-02-08T10:26:00.470Z","comments":true,"path":"posts/leetcode102-binary-tree-level-order-traversal/","link":"","permalink":"https://orzyt.cn/posts/leetcode102-binary-tree-level-order-traversal/","excerpt":"","text":"描述Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). 样例1234567891011121314Input:Given binary tree [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7Output:return its level order traversal as:[ [3], [9,20], [15,7]] 思路求二叉树的层序遍历。 BFS：初始化一个队列，存放节点信息以及对应的深度。由于是宽搜，所以每到达新的一层，就把上一层的信息全push到vector里。 DFS：在前序遍历的时候，初始化好相应深度的vector，若以后又访问到该层，直接push到相应层的vector中。 代码BFS 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if (root == NULL) return ans; queue&lt;pair&lt;TreeNode*, int&gt;&gt; que; que.push(make_pair(root, 1)); vector&lt;int&gt; temp; int pre = 1; while (!que.empty()) &#123; pair&lt;TreeNode*, int&gt;&amp; p = que.front(); que.pop(); if (p.second != pre) &#123; // 新的一层 ans.push_back(temp); temp.clear(); pre = p.second; &#125; temp.push_back(p.first-&gt;val); if (p.first-&gt;left != NULL) que.push(make_pair(p.first-&gt;left, p.second + 1)); if (p.first-&gt;right != NULL) que.push(make_pair(p.first-&gt;right, p.second + 1)); &#125; ans.push_back(temp); return ans; &#125;&#125;; DFS 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; vec; void dfs(TreeNode* root, int dep) &#123; if (root == NULL) return ; // 第一次到达dep层，初始化一个空的vector if (vec.size() == dep) vec.push_back(vector&lt;int&gt;()); vec[dep].push_back(root-&gt;val); dfs(root-&gt;left, dep + 1); dfs(root-&gt;right, dep + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; dfs(root, 0); return vec; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://orzyt.cn/tags/BFS/"}]},{"title":"LeetCode112 Path Sum","slug":"leetcode112-path-sum","date":"2017-08-20T16:00:00.000Z","updated":"2019-02-08T10:26:00.446Z","comments":true,"path":"posts/leetcode112-path-sum/","link":"","permalink":"https://orzyt.cn/posts/leetcode112-path-sum/","excerpt":"","text":"描述Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 样例123456789101112Input:Given the below binary tree and sum = 22 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1Output:return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 思路给定一颗二叉树和一个值，问是否存在从根到叶的路径，满足路径权值和等于给定的值。 可以从根开始dfs，每经过一个节点就减去该结点的值，然后在叶结点判断给定的值是否被减到零。 代码123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (root == NULL) return false; sum -= root-&gt;val; if (sum == 0 &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return true; return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode118 Pascal's Triangle","slug":"leetcode118-pascals-triangle","date":"2017-08-20T16:00:00.000Z","updated":"2019-02-08T10:26:00.170Z","comments":true,"path":"posts/leetcode118-pascals-triangle/","link":"","permalink":"https://orzyt.cn/posts/leetcode118-pascals-triangle/","excerpt":"","text":"描述Given numRows, generate the first numRows of Pascal’s triangle. 样例12Input:numRows = 5 12345678Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 思路求$n$层的帕斯卡三角，也就是杨辉三角。 递推式如下： dp[i][j] = \\left\\{\\begin{matrix} 1 \\; & \\text{if j = 0 or j = i}\\\\ dp[i-1][j-1] + dp[i-1][j] \\; & \\text{others}\\ \\end{matrix}\\right.代码123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt; &gt; ans; for (int i = 0; i &lt; numRows; ++i) &#123; vector&lt;int&gt; temp; for (int j = 0; j &lt;= i; ++j) &#123; if (j == 0 || j == i) temp.push_back(1); else temp.push_back(ans[i-1][j-1] +ans[i-1][j]); &#125; ans.push_back(temp); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode119 Pascal's Triangle II","slug":"leetcode119-pascals-triangle-ii","date":"2017-08-20T16:00:00.000Z","updated":"2019-02-08T10:26:00.214Z","comments":true,"path":"posts/leetcode119-pascals-triangle-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode119-pascals-triangle-ii/","excerpt":"","text":"描述Given an index k, return the kth row of the Pascal’s triangle. 样例12Input:k = 3 12Output:[1,3,3,1] 思路求第$k$层的帕斯卡三角。 一种方法是像LeetCode118 Pascal’s Triangle那样，先把$k$层全求出来，然后再取出第$k$层，这样空间是$\\mathcal{O}(k^2)$。 为了降低空间复杂度，可以考虑使用滚动数组。 观察下列的递推式， dp[i][j] = \\left\\{\\begin{matrix} 1 \\; & \\text{if j = 0 or j = i}\\\\ dp[i-1][j] + dp[i-1][j-1] \\; & \\text{others}\\ \\end{matrix}\\right.假设我们忽略第一维的信息，只利用$dp[j] = dp[j] + dp[j-1]$来更新，是否可以呢？ 答案是可以的，但是需要注意更新的顺序。 在有两维的时候，$j$按什么顺序更新都没问题，但是在只有一维的情况下，$j$只能从大往小更新。 当$j$从大往小更新的时候，等号左边的$dp[j]$ 指代$dp[i][j]$，等号右边的$dp[j]$指代$dp[i-1][j]$，$dp[j-1]$指代$dp[i-1][j-1]$，这样才能保证更新的时候等号右边的数据还是上一层的。 代码1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; dp(rowIndex + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= rowIndex; ++i) &#123; for (int j = i; j &gt;= 1; --j) dp[j] += dp[j-1]; &#125; return dp; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode125 Valid Palindrome","slug":"leetcode125-valid-palindrome","date":"2017-08-20T16:00:00.000Z","updated":"2019-02-08T10:26:00.422Z","comments":true,"path":"posts/leetcode125-valid-palindrome/","link":"","permalink":"https://orzyt.cn/posts/leetcode125-valid-palindrome/","excerpt":"","text":"描述Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. 样例1234Input:&quot;A man, a plan, a canal: Panama&quot;Output:true 1234Input:&quot;race a car&quot;Output:false 思路判断一个字符串是否是回文的，只考虑其中出现的字母、数字，并且忽略大小写。 使用双指针，$l$指向头部，$r$指向尾部，遇到非法字符则移动到合法字符为止，然后将字母转为小写进行比较。 isalnum()函数是用来判断一个字符是否是字母或数字的，tolower()则是返回一个字母的小写状态，这些函数都定义在&lt;cctype&gt;头文件中。 代码123456789101112class Solution &#123;public: bool isPalindrome(string s) &#123; int l = 0, r = s.size()-1; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; !isalnum(s[l])) l++; while (l &lt; r &amp;&amp; !isalnum(s[r])) r--; if (tolower(s[l++]) != tolower(s[r--])) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"}]},{"title":"LeetCode108 Convert Sorted Array to Binary Search Tree","slug":"leetcode108-convert-sorted-array-to-binary-search-tree","date":"2017-06-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.398Z","comments":true,"path":"posts/leetcode108-convert-sorted-array-to-binary-search-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode108-convert-sorted-array-to-binary-search-tree/","excerpt":"","text":"描述Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 样例1无 思路将有序数组转成二叉搜索树。 由于是有序数组，每次在中间位置将数组分成左右两部分递归下去即可。 代码1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* build(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l &gt; r) return NULL; int mid = l + (r - l + 1) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = build(nums, l, mid - 1); root-&gt;right = build(nums, mid + 1, r); return root; &#125; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return build(nums, 0, nums.size() - 1); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode107 Binary Tree Level Order Traversal II","slug":"leetcode107-binary-tree-level-order-traversal-ii","date":"2017-06-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.270Z","comments":true,"path":"posts/leetcode107-binary-tree-level-order-traversal-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode107-binary-tree-level-order-traversal-ii/","excerpt":"","text":"描述Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). 样例1234567891011121314Input:Given binary tree [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 Output:[ [15,7], [9,20], [3]] 思路求二叉树层序遍历的逆序。 BFS一遍即可。 代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if (root == NULL) return ans; queue&lt;pair&lt;TreeNode*, int&gt;&gt; que; que.push(make_pair(root, 1)); vector&lt;int&gt; temp; int pre = 1; while (!que.empty()) &#123; pair&lt;TreeNode*, int&gt;&amp; p = que.front(); que.pop(); if (p.second != pre) &#123; ans.push_back(temp); temp.clear(); pre = p.second; &#125; temp.push_back(p.first-&gt;val); if (p.first-&gt;left != NULL) que.push(make_pair(p.first-&gt;left, p.second + 1)); if (p.first-&gt;right != NULL) que.push(make_pair(p.first-&gt;right, p.second + 1)); &#125; ans.push_back(temp); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"BFS","slug":"BFS","permalink":"https://orzyt.cn/tags/BFS/"}]},{"title":"2017福建省大学生程序设计竞赛总结","slug":"2017-fjpcpc-summary","date":"2017-06-14T09:12:54.000Z","updated":"2018-11-10T11:47:16.903Z","comments":true,"path":"posts/2017-fjpcpc-summary/","link":"","permalink":"https://orzyt.cn/posts/2017-fjpcpc-summary/","excerpt":"正式赛的开场比较顺利，第一题是鸡兔同笼解方程，第二题是SG函数博弈，第三题是kmp，一人敲一题，都是1A。第四题是高精度题，不知道为什么机器明明装了JDK环境，但是却不提供Eclipse。于是我们就只能用文本编辑器写Java代码，然后提交到OJ上在线编译（尝试在本地用命令行编译运行，不过没成功）。一开始用了BigDecimal类，但是有精度问题wa了一次，最后发现用BigInteger就行了，最终2A。第五题是错排问题，我把错排公式给了队友，不过他好像卡在了什么地方，最后也找到bug然后过了。","text":"正式赛的开场比较顺利，第一题是鸡兔同笼解方程，第二题是SG函数博弈，第三题是kmp，一人敲一题，都是1A。第四题是高精度题，不知道为什么机器明明装了JDK环境，但是却不提供Eclipse。于是我们就只能用文本编辑器写Java代码，然后提交到OJ上在线编译（尝试在本地用命令行编译运行，不过没成功）。一开始用了BigDecimal类，但是有精度问题wa了一次，最后发现用BigInteger就行了，最终2A。第五题是错排问题，我把错排公式给了队友，不过他好像卡在了什么地方，最后也找到bug然后过了。 最后过的一题，说来惭愧，是那道签到的计算几何题，判断两个三角形的位置关系是相交、包含还是相离。这道题又是从开场卡到封榜，一开始想了比较复杂的做法，敲了一个多边形面积交再加一些特判就交了上去，结果wa了。想法虽然比较复杂，但是应该是没错的。一开始坐标都用int型，后来改成用double型交了，又wa了。队友又帮我想了一个用凸包判断的办法，又wa了。感觉我们在这道签到题上已经越走越远了，最后这题其实只用叉积判断下就过了。离结束还有四十多分钟，现在已经过了六题，想要夺金必须还得再过一题才比较稳，于是我们又开了两题。一道之前认为是后缀自动机的题，敲完自动机部分的模板之后才发现好像想法有点问题。然后还剩二三十分钟的时候，又重新开了另一道可能是斜率优化的DP，最后到比赛结束样例也没调出来。 赛前一周，我们队在VJ、CF上打了五场左右的训练赛，希望在省赛上能有不错的表现。但是，最终还是输了，银牌第一，与金失之交臂。 大学最后一场ACM比赛，还是留下了很多遗憾… 虽然已经退役了，但是还是非常感谢集训队提供的平台以及老师们的辛苦付出，两年来也参加了ICPC、CCPC、天梯赛、省赛、多校训练等大大小小的比赛。在这过程中，有喜悦、有遗憾，收获到了许多，也得到了锻炼和成长，感谢！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://orzyt.cn/categories/随笔/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://orzyt.cn/tags/ACM/"}]},{"title":"LeetCode69 Sqrt(x)","slug":"leetcode69-sqrtx","date":"2017-06-10T16:00:00.000Z","updated":"2019-02-08T10:26:00.298Z","comments":true,"path":"posts/leetcode69-sqrtx/","link":"","permalink":"https://orzyt.cn/posts/leetcode69-sqrtx/","excerpt":"","text":"描述Implement int sqrt(int x). Compute and return the square root of x. 样例12Input:4 12Output:2 思路实现开根函数，返回值向下取整。 一种方法是二分搜索答案，每次检查$mid^2$和$x$的关系来更新上下界。 另外，也可以使用牛顿迭代法。迭代公式：$f(x) = x^2 - n$，$x_{n+1}$ = $x_{n} - \\frac{f(x_{n})}{f^{‘}(x_{n})}$ = $x_{n} - \\frac{x_{n}^2-n}{2x_{n}}$ = $(x_n + \\frac{n}{x_n}) / 2$ 代码二分： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; long long l = 0, r = x, m; while (l &lt; r) &#123; m = l + (r - l + 1) / 2; if (m * m &lt;= x) l = m; else r = m - 1; &#125; return l; &#125;&#125;; 牛顿迭代法： 1234567891011class Solution &#123;public: int mySqrt(int x) &#123; double x0 = 0, x1 = 1; while (fabs(x0 - x1) &gt; 1e-6) &#123; x0 = x1; x1 = (x0 + x / x0) / 2; &#125; return int(x0); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"},{"name":"牛顿迭代法","slug":"牛顿迭代法","permalink":"https://orzyt.cn/tags/牛顿迭代法/"}]},{"title":"LeetCode70 Climbing Stairs","slug":"leetcode70-climbing-stairs","date":"2017-06-10T16:00:00.000Z","updated":"2019-02-08T10:26:00.438Z","comments":true,"path":"posts/leetcode70-climbing-stairs/","link":"","permalink":"https://orzyt.cn/posts/leetcode70-climbing-stairs/","excerpt":"","text":"描述You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 样例12Input:3 12Output:2 思路上一个$n$阶的楼梯，每次可以走1或2步，问有多少种走法。 动态规划经典题，也是斐波那契数列。 令$dp[i]$为走到第$i$阶时的方案数，则$dp[i] = dp[i-1] + dp[i-2]$，也就是说第$i$阶可以从第$i-1$阶走1步 或 第$i-2$阶走2步转移过来。初始化$dp[0] = 1$，$dp[1] = 1$。 代码123456789101112class Solution &#123;public: int climbStairs(int n) &#123; int a = 1, b = 1, t; //不必开数组，用三个变量模拟即可 for (int i = 1; i &lt;= n; ++i) &#123; t = b; b = a + b; a = t; &#125; return a; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"https://orzyt.cn/tags/DP/"}]},{"title":"LeetCode83 Remove Duplicates from Sorted List","slug":"leetcode83-remove-duplicates-from-sorted-list","date":"2017-06-10T16:00:00.000Z","updated":"2019-02-08T10:26:00.458Z","comments":true,"path":"posts/leetcode83-remove-duplicates-from-sorted-list/","link":"","permalink":"https://orzyt.cn/posts/leetcode83-remove-duplicates-from-sorted-list/","excerpt":"","text":"描述Given a sorted linked list, delete all duplicates such that each element appear only once. 样例1234Input:1-&gt;1-&gt;2Output:1-&gt;2 1234Input:1-&gt;1-&gt;2-&gt;3-&gt;3Output:1-&gt;2-&gt;3 思路删除有序链表中重复的数字。 记录下前驱节点的值，判断与当前节点的值是否相同，相同则删去。 代码12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; int preVal = INT_MAX; ListNode *cur = head, *pre = head; while (cur != NULL) &#123; if (cur-&gt;val == preVal) pre-&gt;next = cur-&gt;next; else pre = cur; preVal = cur-&gt;val; cur = cur-&gt;next; &#125; return head; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://orzyt.cn/tags/链表/"}]},{"title":"LeetCode84 Largest Rectangle in Histogram","slug":"leetcode84-largest-rectangle-in-histogram","date":"2017-06-10T16:00:00.000Z","updated":"2019-02-08T10:26:00.430Z","comments":true,"path":"posts/leetcode84-largest-rectangle-in-histogram/","link":"","permalink":"https://orzyt.cn/posts/leetcode84-largest-rectangle-in-histogram/","excerpt":"","text":"描述Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 样例12345Input:[2,1,5,6,2,3]Output:10 思路在直方图中找到面积最大的矩形。 暴力的做法是，枚举每个点$h[i]$作为最小值，看它能向左扩展多远$l_i$，能向右扩展多远$r_i$, $ans = max \\lbrace h[i] * (l_i + r_i) | i = 0..n-1 \\rbrace $，复杂度$O(n^2)$。 这题其实是一道单调栈的经典题，使用单调栈可以快速维护出每个点的$l$和$r$值。单调栈中存放节点的信息，表示节点的高度$h_i$以及节点的$l_i$值，并通过$l_i$值推出相应的$r_i$值。单调栈按节点的高度递增排序。 接下来以样例为例，具体说明各个步骤。（红色代表进栈，蓝色代表出栈） 一开始栈为空，第一个节点 $Node_1:\\lbrace h = 2, l = 1 \\rbrace$ 进栈。 由于当前节点 $Node_2:\\lbrace h = 1, l = 1 \\rbrace$ 与栈顶节点 $Node_1:\\lbrace h = 2, l = 1 \\rbrace$ 之间不满足单调性质，故栈顶元素出栈，计算蓝色部分的面积，并更新答案 , $area_1 = h_1 * (l_1 + r_1) = 2 * (1 + 0) = 2$， $ans = max(ans, area_1) = 2$。 此时栈为空，接下来节点 $Node_2:\\lbrace h = 1, l = 2 \\rbrace$ 进栈，那么我们如何知道该节点向左延伸的最长距离为$2$呢？前面提到，栈中的节点按高度递增排序，如果当前节点进栈之前，有若干节点由于破坏单调性而被弹出栈，则这些出栈的节点的高度一定是大于当前节点的高度的，也就说明当前节点可以往前延伸这么多的距离。$Node_2$初始$l_2$值为$1$，由于$Node_1$被弹出栈，那么$Node_2$向左延伸的距离除了本身的$1$以外，还要加上$Node_1$延伸的长度$l_1$。因此$l_2 = 1 + l_1 = 1 + 1 = 2$。 节点 $Node_3:\\lbrace h = 5, l = 1 \\rbrace$ 正常进栈。 节点 $Node_4:\\lbrace h = 6, l = 1 \\rbrace$ 正常进栈。 节点 $Node_5:\\lbrace h = 2, l = 1 \\rbrace$ 想要进栈，但是发现栈顶元素破坏单调性，则节点$Node_4:\\lbrace h = 6, l = 1 \\rbrace$出栈，更新答案，$area_4 = h_4 * (l_4 + r_4) = 6 * (1 + 0) = 6$， $ans = max(ans, area_4) = 6$。 此时，栈顶为节点 $Node_3:\\lbrace h = 5, l = 1 \\rbrace$，依旧破坏单调性，出栈，更新答案。但是$Node_3$进栈时的$l_3$值为$1$，为什么图中蓝色的宽度为$2$呢？请不要忘记计算节点的$r$值！(由于前几个节点的$r$值都为$0$，我就忽略没讲$r$ 怎么算)那么$r$值又是怎么算出来的呢？这就体现了单调栈的作用了！由于单调栈中节点的高度是递增排列的，因此如果节点$Node_3$出栈前有若干节点被弹出栈了的话，那么这些节点的高度一定是大于节点$Node_3$的，只要把这些节点的$l$值累加起来，就是$Node_3$的$r$值了！因此$r_3 = l\\ _4 = 1$。$area_3 = h_3 * (l_3 + r_3) = 5 * (1 + 1) = 10$。$ans = max(ans, area_3) = 10$。 节点 $Node_5:\\lbrace h = 2, l = 3 \\rbrace$进栈，其中$l_5 = 1 + l_3 + l_4 = 1 + 1 + 1 = 3$。 节点 $Node_6:\\lbrace h = 3, l = 1 \\rbrace$ 正常进栈。 至此，所有节点都已进栈，其中节点$Node_1$、节点$Node_3$和节点$Node_4$都已经被弹出栈，出栈时也更新过答案了。现在栈中还有节点$Node_2$、节点$Node_5$和节点$Node_6$。节点$Node_6:\\lbrace h = 3, l = 1 \\rbrace$出栈，更新答案，$area_6 = h_6 * (l_6 + r_6) = 3 * (1 + 0) = 3$， $ans = max(ans, area_6) = 10$。 节点$Node_5:\\lbrace h = 2, l = 3 \\rbrace$出栈，更新答案。其中$r_5 = l_6 = 1$，$area_5 = h_5 * (l_5 + r_5) = 2 * (3 + 1) = 8$， $ans = max(ans, area_5) = 10$。 节点$Node_2:\\lbrace h = 1, l = 2 \\rbrace$出栈，更新答案。其中$r_2 = l_5 +l_6 = 3 + 1 = 4$，$area_2 = h_2 * (l_2 + r_2) = 1 * (2 + 4) = 6$， $ans = max(ans, area_2) = 10$。 注意到，上述过程中每个节点只进栈和出栈各一次，因此复杂度是线性的！ 代码123456789101112131415161718192021222324252627class Solution &#123;public: struct Node &#123; int h; // 节点i的高度 int l; // 节点i向左延伸的最长距离 Node()&#123;&#125; Node(int height, int cnt):h(height), l(cnt)&#123;&#125; &#125;; int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; stack&lt;Node&gt; sta; int ans = 0, curl; for (int&amp; h: heights) &#123; curl = 0; while (!sta.empty() &amp;&amp; sta.top().h &gt;= h) &#123; ans = max(ans, (curl += sta.top().l) * sta.top().h); sta.pop(); &#125; sta.push(Node(h, curl + 1)); &#125; curl = 0; while (!sta.empty()) &#123; ans = max(ans, (curl += sta.top().l) * sta.top().h); sta.pop(); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"https://orzyt.cn/tags/单调栈/"}]},{"title":"LeetCode20 Valid Parentheses","slug":"leetcode20-valid-parentheses","date":"2017-05-29T16:00:00.000Z","updated":"2019-02-08T10:26:00.350Z","comments":true,"path":"posts/leetcode20-valid-parentheses/","link":"","permalink":"https://orzyt.cn/posts/leetcode20-valid-parentheses/","excerpt":"","text":"描述Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. 样例12Input:&quot;()&quot; 12Output:true 思路括号匹配问题。 用一个符号栈来维护即可。若当前的括号可以和栈顶括号匹配，则栈顶括号出栈，否则当前括号进栈，最后判断栈是否为空即可知道是否正确匹配完成。具体实现一般先在栈中压入一个特殊符号，避免栈为空的特判。 代码1234567891011121314class Solution &#123;public: bool isValid(string s) &#123; unordered_map&lt;char, char&gt; hs; hs[')'] = '('; hs['&#125;'] = '&#123;'; hs[']'] = '['; stack&lt;char&gt; sta; sta.push('#'); for (char&amp;c : s) &#123; if (hs[c] != sta.top()) sta.push(c); else sta.pop(); &#125; return sta.top() == '#'; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"栈","slug":"栈","permalink":"https://orzyt.cn/tags/栈/"}]},{"title":"LeetCode27 Remove Element","slug":"leetcode27-remove-element","date":"2017-05-29T16:00:00.000Z","updated":"2019-02-08T10:26:00.350Z","comments":true,"path":"posts/leetcode27-remove-element/","link":"","permalink":"https://orzyt.cn/posts/leetcode27-remove-element/","excerpt":"","text":"描述Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 样例12Input:nums = [3,2,2,3], val = 3 123Output:Your function should return length = 2, with the first two elements of nums being 2 思路将数组中所有指定元素移动到数组末尾，且不能使用额外的内存空间。 使用双指针，$i$ 指向当前访问的元素，$j$ 代表之前有出现过多少个非指定元素。将指定元素移到末尾，相当于将其他元素移到前面。 代码1234567891011121314151617181920class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int i = 0, j = 0; while (i &lt; nums.size()) &#123; if (nums[i] != val) &#123; swap(nums[i], nums[j]); j++; &#125; i++; &#125; return j; /* 短小精悍的实现 int k = 0; for (int&amp; x: nums) if (x != val) swap(x, nums[k++]); return k; */ &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"}]},{"title":"LeetCode53 Maximum Subarray Element","slug":"leetcode53-maximum-subarray","date":"2017-05-29T16:00:00.000Z","updated":"2019-02-08T10:26:00.490Z","comments":true,"path":"posts/leetcode53-maximum-subarray/","link":"","permalink":"https://orzyt.cn/posts/leetcode53-maximum-subarray/","excerpt":"","text":"描述Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 样例12Input:[-2,1,-3,4,-1,2,1,-5,4] 12Output:6 思路求数组最大子串和。 定义$dp[i]$为以第$i$个元素结尾的最大子串和。 显然，当$dp[i-1] &gt; 0$时，$ dp[i] = dp[i-1] + nums[i]$，否则$dp[i] = nums[i]$ 最后$ans = max(dp[i] | i = 0..n-1)$ 代码1234567891011class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int sum = 0, ans = INT_MIN; for (int&amp; x: nums) &#123; sum &lt; 0 ? sum = x : sum += x; ans = max(ans, sum); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"https://orzyt.cn/tags/DP/"}]},{"title":"2017团队程序设计天梯赛决赛总结","slug":"2017-cccc-final-summary","date":"2017-04-23T16:20:27.000Z","updated":"2018-11-10T11:47:16.903Z","comments":true,"path":"posts/2017-cccc-final-summary/","link":"","permalink":"https://orzyt.cn/posts/2017-cccc-final-summary/","excerpt":"去年新出的赛事，中国高校计算机大赛(China Collegiate Computing Contest,简称C4)，其中有一个项目是团队程序设计天梯赛。每个学校出三支队伍，每支队伍十个人。在本校参加完初赛后，有幸去杭州参加决赛。","text":"去年新出的赛事，中国高校计算机大赛(China Collegiate Computing Contest,简称C4)，其中有一个项目是团队程序设计天梯赛。每个学校出三支队伍，每支队伍十个人。在本校参加完初赛后，有幸去杭州参加决赛。 天梯赛不同于ACM比赛，虽然名义上都是“组队赛”，但是更多还是考验选手的个人实力。一般来说基础阶段的8道题和进阶阶段的4道题都没什么问题，思路和算法不会复杂，很快就可以想到。但是，怎么将思路转化为无BUG的代码，怎么快速编码实现是值得重视的。确实，想到了思路但不一定会敲，会敲但不一定没有BUG，在没有BUG的情况下还要保证手速，有BUG了还要快速调试出错误，在决赛短短两个半小时的时间里还是非常紧迫的。 这次比赛我主要是跟榜刷题，而不是按照题号顺序写，这样有一个好处是不容易卡题，前面快速把水题过了也能给自己一些信心。然后天梯赛是按点给分的，所以如果是一些小的点没过我就直接跳过了，不在上面浪费时间。思路上先想暴力能不能做，能的话直接敲下去，至少也能保证得到大部分的分数，节约想正解的时间。 在高压下编码，调试的能力迅速下降，以致于3-1那题最后没调试出来，甚是遗憾。参加这次比赛，发现自己的编码能力还有待提高，也认识到自己与一些大牛之间的差距。同样是两个半小时，有人能够AK比赛正确地做出所有的题目，而自己却只能刚刚到达登顶阶段。所以，有的时候能“理论AC”一道题，但是未必能够在短时间内正确编码通过。防止“眼高手低”，还是要多动手刷题才是正道。 Anyway，FZU最终夺得了高校一等奖！ （运气好的小伙伴已经出去逛西湖了，运气不好的小伙伴只能默默待在颁奖典礼现场QAQ）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://orzyt.cn/categories/随笔/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://orzyt.cn/tags/ACM/"}]},{"title":"LeetCode442 Find All Duplicates in an Array","slug":"leetcode442-find-all-duplicates-in-an-array","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.414Z","comments":true,"path":"posts/leetcode442-find-all-duplicates-in-an-array/","link":"","permalink":"https://orzyt.cn/posts/leetcode442-find-all-duplicates-in-an-array/","excerpt":"","text":"描述Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? 样例12345Input:[4,3,2,7,8,2,3,1]Output:[2,3] 思路找出所有在数组中出现两次的数。 类似LeetCode448 Find All Numbers Disappeared in an Array这题中的技巧，对原数组做标记(取个负)表示该数曾出现过，若下次遇到已经为负则说明重复出现。 代码12345678910111213class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), id; vector&lt;int&gt; ans; for (int i = 0; i &lt; n; ++i) &#123; id = abs(nums[i]) - 1; if (nums[id] &lt; 0) ans.push_back(id + 1); nums[id] *= -1; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode447 Number of Boomerangs","slug":"leetcode447-number-of-boomerangs","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.414Z","comments":true,"path":"posts/leetcode447-number-of-boomerangs/","link":"","permalink":"https://orzyt.cn/posts/leetcode447-number-of-boomerangs/","excerpt":"","text":"描述Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between iand j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). 样例12345678Input:[[0,0],[1,0],[2,0]]Output:2Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 思路统计有多少个$(i, j, k)$点对满足 $dis(i, j) = dis(i, k)$ 固定一个点i, 用map维护该点与其他点的距离。则每种距离对答案的贡献为$A^{2}_{n}$，$n$为该距离的个数。 代码1234567891011121314151617class Solution &#123;public: int dis(pair&lt;int, int&gt;&amp; p1, pair&lt;int, int&gt;&amp; p2) &#123; return (p1.first - p2.first) * (p1.first - p2.first) + (p1.second - p2.second) * (p1.second - p2.second); &#125; int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; int n = points.size(), ans = 0; unordered_map&lt;int, int&gt; hs(n); for (int i = 0; i &lt; n; ++i) &#123; hs.clear(); for (int j = 0; j &lt; n; ++j) hs[dis(points[i], points[j])]++; for (auto&amp; x: hs) ans += x.second * (x.second - 1); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"}]},{"title":"LeetCode451 Sort Characters By Frequency","slug":"leetcode451-sort-characters-by-frequency","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.450Z","comments":true,"path":"posts/leetcode451-sort-characters-by-frequency/","link":"","permalink":"https://orzyt.cn/posts/leetcode451-sort-characters-by-frequency/","excerpt":"","text":"描述Given a string, sort it in decreasing order based on the frequency of characters. 样例Example 1: 123456789Input:&quot;tree&quot;Output:&quot;eert&quot;Explanation:&apos;e&apos; appears twice while &apos;r&apos; and &apos;t&apos; both appear once.So &apos;e&apos; must appear before both &apos;r&apos; and &apos;t&apos;. Therefore &quot;eetr&quot; is also a valid answer. Example 2: 123456789Input:&quot;cccaaa&quot;Output:&quot;cccaaa&quot;Explanation:Both &apos;c&apos; and &apos;a&apos; appear three times, so &quot;aaaccc&quot; is also a valid answer.Note that &quot;cacaca&quot; is incorrect, as the same characters must be together. Example 3: 12345678910111213Input:&quot;Aabb&quot;Output:&quot;bbAa&quot;Explanation:&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.Note that &apos;A&apos; and &apos;a&apos; are treated as two different characters.Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 思路将字符串按字符出现频率排序。 每个字符丢到对应的桶中，然后按桶的大小排序，最后按序输出即可。 代码123456789101112class Solution &#123;public: string frequencySort(string s) &#123; pair&lt;int, char&gt; p[128]; for (int i = 0; i &lt; 128; ++i) p[i].first = 0, p[i].second = i; for (char&amp; c: s) p[c].first++; sort(p, p+128); string ans; for (int i = 127; i &gt;= 0; --i) while (p[i].first--&gt;0) ans += char(p[i].second); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"},{"name":"排序","slug":"排序","permalink":"https://orzyt.cn/tags/排序/"}]},{"title":"LeetCode459 Repeated Substring Pattern","slug":"leetcode459-repeated-substring-pattern","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.142Z","comments":true,"path":"posts/leetcode459-repeated-substring-pattern/","link":"","permalink":"https://orzyt.cn/posts/leetcode459-repeated-substring-pattern/","excerpt":"","text":"描述Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. 样例Example 1: 12345Input: &quot;abab&quot;Output: TrueExplanation: It&apos;s the substring &quot;ab&quot; twice. Example 2: 123Input: &quot;aba&quot;Output: False Example 3: 12345Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 思路判断字符串是否存在循环节。 kmp算法找字符串循环节的一个应用，具体见KMP算法 —— next 数组的应用 —- 前缀中最小循环节，最大重复次数 代码1234567891011121314151617class Solution &#123;public: int fail[10005]; void getFail(string s) &#123; int i = 0, j, len = s.size(); j = fail[0] = -1; while (i &lt; len) &#123; while (j != -1 &amp;&amp; s[i] != s[j]) j = fail[j]; fail[++i] = ++j; &#125; &#125; bool repeatedSubstringPattern(string str) &#123; getFail(str); int len = str.size(); return fail[len] != 0 &amp;&amp; len % (len - fail[len]) == 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode496 Next Greater Element I","slug":"leetcode496-next-greater-element-i","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.226Z","comments":true,"path":"posts/leetcode496-next-greater-element-i/","link":"","permalink":"https://orzyt.cn/posts/leetcode496-next-greater-element-i/","excerpt":"","text":"描述You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1‘s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Note: All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000. 样例Example 1: 123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Example 2: 12345Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. 思路找出nums1中的元素在nums2中对应位置的右边且比它大的第一个数，不存在则输出-1。 单调栈的应用。由于nums1是nums2的子集，所以先预处理出nums2中的所有答案再查询。 栈中的元素保持单调递减，若当前访问的元素x大于栈顶的元素sta.top()，则栈顶元素出栈并记录答案（即sta.top()右边第一个比它大的数为x) 代码12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; hs; stack&lt;int&gt; sta; for (int&amp; x: nums) &#123; while (!sta.empty() &amp;&amp; sta.top() &lt; x) &#123; hs[sta.top()] = x; sta.pop(); &#125; sta.push(x); &#125; for (int&amp; x: findNums) &#123; if (!hs.count(x)) x = -1; else x = hs[x]; &#125; return findNums; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"栈","slug":"栈","permalink":"https://orzyt.cn/tags/栈/"}]},{"title":"LeetCode492 Construct the Rectangle","slug":"leetcode492-construct-the-rectangle","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.206Z","comments":true,"path":"posts/leetcode492-construct-the-rectangle/","link":"","permalink":"https://orzyt.cn/posts/leetcode492-construct-the-rectangle/","excerpt":"","text":"描述For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: 123451. The area of the rectangular web page you designed must equal to the given target area.2. The width W should not be larger than the length L, which means L &gt;= W.3. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. Note: The given area won’t exceed 10,000,000 and is a positive integer The web page’s width and length you designed must be positive integers. 样例Example: 1234Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. 思路对给定的面积，在满足的条件下，求出长和宽 条件是：l * w == area &amp;&amp; l &gt;= w &amp;&amp; l 和 r 的差要尽可能的小 从$\\sqrt{area}$开始枚举宽度w，然后再判断是否满足上述条件即可 代码123456789101112131415class Solution &#123;public: vector&lt;int&gt; constructRectangle(int area) &#123; vector&lt;int&gt; ans; for (int w = sqrt(1.0 * area); w &gt;= 1; --w) &#123; int l = area / w; if (l * w == area) &#123; ans.push_back(max(l, w)); ans.push_back(min(l, w)); break; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode506 Relative Ranks","slug":"leetcode506-relative-ranks","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.194Z","comments":true,"path":"posts/leetcode506-relative-ranks/","link":"","permalink":"https://orzyt.cn/posts/leetcode506-relative-ranks/","excerpt":"","text":"描述Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”. Note: N is a positive integer and won’t exceed 10,000. All the scores of athletes are guaranteed to be unique. 样例123456Input: [5, 4, 3, 2, 1]Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. 思路根据数组元素的大小，给出排名。前三输出金银铜牌，其余输出名次。 sort一下就好了，用pair姿势会比较优雅。 代码123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123; vector&lt;pair&lt;int, int&gt; &gt; vec; // pair第一位存元素大小，第二位存下标 int siz = nums.size(), id = 0; for (int&amp; x: nums) vec.push_back(make_pair(-x, id++)); sort(vec.begin(), vec.end()); vector&lt;string&gt; ans(siz); string medals[3] = &#123;\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"&#125;; for (int i = 0; i &lt; siz; ++i) &#123; id = vec[i].second; if (i &lt; 3) ans[id] = medals[i]; else ans[id] = to_string(i + 1); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode504 Base 7","slug":"leetcode504-base-7","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.126Z","comments":true,"path":"posts/leetcode504-base-7/","link":"","permalink":"https://orzyt.cn/posts/leetcode504-base-7/","excerpt":"","text":"描述Given an integer, return its base 7 string representation. Note: The input will be in range of [-1e7, 1e7]. 样例Example 1: 12Input: 100Output: &quot;202&quot; Example 2: 12Input: -7Output: &quot;-10&quot; 思路将一个十进制数转化为七进制数。 注意负数以及零的处理。 代码123456789101112131415class Solution &#123;public: string convertToBase7(int num) &#123; int x = num &gt; 0 ? num : -num; string ans; while (x) &#123; ans += char(x % 7 + '0'); x /= 7; &#125; reverse(ans.begin(), ans.end()); if (num &lt; 0) ans = '-' + ans; else if (num == 0) ans = \"0\"; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode520 Detect Capital","slug":"leetcode520-detect-capital","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.210Z","comments":true,"path":"posts/leetcode520-detect-capital/","link":"","permalink":"https://orzyt.cn/posts/leetcode520-detect-capital/","excerpt":"","text":"描述Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”. Otherwise, we define that this word doesn’t use capitals in a right way. Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. 样例Example 1: 12Input: &quot;USA&quot;Output: True Example 2: 12Input: &quot;FlaG&quot;Output: False 思路判断一个字符串是否由全是大写字母或全是小写字母或开头大写其余小写组成。 记录大写字母的个数，特判一下即可。 代码12345678class Solution &#123;public: bool detectCapitalUse(string word) &#123; int count = 0; for (auto&amp; c: word) if (isupper(c)) count++; return (count == 0) || (count == word.size()) || (count == 1 &amp;&amp; isupper(word[0])); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode513 Find Bottom Left Tree Value","slug":"leetcode513-find-bottom-left-tree-value","date":"2017-03-07T16:00:00.000Z","updated":"2019-02-08T10:26:00.186Z","comments":true,"path":"posts/leetcode513-find-bottom-left-tree-value/","link":"","permalink":"https://orzyt.cn/posts/leetcode513-find-bottom-left-tree-value/","excerpt":"","text":"描述Given a binary tree, find the leftmost value in the last row of the tree. Note: You may assume the tree (i.e., the given root node) is not NULL. 样例12345678Input: 2 / \\ 1 3Output:1 123456789101112Input: 1 / \\ 2 3 / / \\ 4 5 6 / 7Output:7 思路输出二叉树最后一层最靠左的节点。 dfs一遍即可，具体看注释～ 代码1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // pair第一维存深度，第二维存节点的值 pair&lt;int, int&gt; find(int dep, TreeNode* root) &#123; // 空节点随便返回一个不可能取到的小值 if (root == NULL) return make_pair(-1, -1); // 叶节点返回当前深度以及节点的值 if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return make_pair(dep, root-&gt;val); // 递归访问左右儿子节点 pair&lt;int, int&gt; l = find(dep + 1, root-&gt;left), r = find(dep + 1, root-&gt;right); // 返回更深的结果，深度相同返回左儿子 return l.first &gt;= r.first ? l : r; &#125; int findBottomLeftValue(TreeNode* root) &#123; return find(1, root).second; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://orzyt.cn/tags/BFS/"}]},{"title":"Coursera Machine Learning 应用机器学习算法的建议","slug":"coursera-advice-for-applying-machine-learning","date":"2017-03-06T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/coursera-advice-for-applying-machine-learning/","link":"","permalink":"https://orzyt.cn/posts/coursera-advice-for-applying-machine-learning/","excerpt":"下一步该怎么办当你实现了一个带有正则化的线性回归来预测房价之后，也许你会发现结果并不尽如人意。 此时你可以试试以下一些方法： 获取更多的训练数据 尝试更小的特征集合 添加额外的特征 添加多项式特征 增大或减小正则化参数$\\lambda$","text":"下一步该怎么办当你实现了一个带有正则化的线性回归来预测房价之后，也许你会发现结果并不尽如人意。 此时你可以试试以下一些方法： 获取更多的训练数据 尝试更小的特征集合 添加额外的特征 添加多项式特征 增大或减小正则化参数$\\lambda$ 评估假设函数一个假设函数可能在训练集上的误差很小，但是并不是说这个误差越小越好（这通常意味着过拟合了）。因此，对于给定的训练样本，通常可以将其分为训练集（training set）和测试集（test set），一般来说分成七三开。 接下来我们将： 使用训练集来学习参数$\\Theta$以及最小化J_{train}(\\Theta) 在测试集上评估误差$J_{test}(\\Theta)$ 对于线性回归： J_{test}(\\Theta) = \\dfrac{1}{2m_{test}} \\sum_{i=1}^{m_{test}}(h_\\Theta(x^{(i)}_{test}) - y^{(i)}_{test})^2对于逻辑回归： err(h_\\Theta(x),y) = \\begin{matrix} 1 & \\mbox{if } h_\\Theta(x) \\geq 0.5\\ and\\ y = 0\\ or\\ h_\\Theta(x) < 0.5\\ and\\ y = 1\\newline 0 & \\mbox otherwise \\end{matrix}J_{test}(\\Theta) = \\dfrac{1}{m_{test}} \\sum^{m_{test}}_{i=1} err(h_\\Theta(x^{(i)}_{test}), y^{(i)}_{test})模型选择和训练/验证/测试集我们之前已经遇到过过拟合问题了，也知道训练误差小并不代表着它的泛化能力也好。 因此，我们需要对模型进行选择，找到合适的参数，比如正则化参数的大小、多项式特征的次数等等（俗称调参）。然后比较，在哪些参数下，模型的表现性能最好（也就是说测试误差最小）。 另外，在模型选择的时候，除了用到训练集和测试集外，通常还会用到交叉验证集（cross validation set），一般按6 : 2 : 2的比例划分。 接下来还是一样，分别计算训练、验证和测试的误差： 使用训练集来学习参数$\\Theta$以及最小化$J_{train}(\\Theta)$ 使用验证集来调参 使用测试集来评估泛化能力 注意：永远不要使用测试集来调参！ 偏差vs方差如果你的模型得到比较差的结果，通常有以下两种原因： 高偏差（high bias）：欠拟合，一般$J_{train}(\\Theta)$和$J_{CV}(\\Theta)$都很高，并且$J_{CV}(\\Theta) \\approx J_{train}(\\Theta)$ 高方差（high variance）：过拟合，一般是$J_{train}(\\Theta)$比较低，但是$J_{CV}(\\Theta)$却远高于$J_{train}(\\Theta)$ 正则化对偏差/方差的影响接下来，我们看看如何通过正则化参数$\\lambda$来影响偏差和方差。 $\\lambda$过大时：所有权重参数$\\Theta$都受到惩罚，大多数参数可能因此而趋于0，这也导致假设函数的结果趋于0，从而引起欠拟合的问题 $\\lambda$过小时：考虑极端情况$\\lambda = 0$，此时完全没有正则化项，当然假设函数会尽可能的拟合数据，从而引起过拟合的问题 为了选择模型以及正则化参数$\\lambda$，通常需要以下几步： 创建一个正则化参数列表 (比如说 $λ∈{0,0.01,0.02,0.04…}$); 使用不同的多项式次数或其他参数变量来生成一系列的模型 迭代正则化参数列表，对每个$\\lambda$在这一系列的模型上学习权重参数$\\Theta$ 使用该$\\Theta$来计算交叉验证误差（计算的时候不需要正则化） 选择在验证集上表现最好的参数组合 然后用该参数组合在测试集上计算$J_{test}(\\Theta)$，检验其泛化能力 学习曲线绘制学习曲线通常有助于检查和提高模型的性能 那么，什么是学习曲线呢？ 通常以训练集大小为横轴，将训练误差$J_{train}(\\Theta)$和验证误差$J_{CV}(\\Theta)$绘制在一起来观测训练结果。 学习曲线一般有以下两种情况： 高偏差的情况 在$N$比较小时，$J_{train}(\\Theta)$会比较低，但是$J_{CV}(\\Theta)$比较高 在$N$比较大时，$J_{train}(\\Theta)$和$J_{CV}(\\Theta)$都很高，并且$J_{CV}(\\Theta) \\approx J_{train}(\\Theta)$ 如果学习曲线出现这种情况的话，一般来说即使得到更多的训练样本也是没太大帮助的 高方差的情况 在$N$比较小时，$J_{train}(\\Theta)$会比较低，但是$J_{CV}(\\Theta)$比较高 在$N$比较大时，随着$N$的增大，$J_{train}(\\Theta)$会一直增加，同时$J_{CV}(\\Theta)$会一直减小，但是会保持$J_{train}(\\Theta) \\lt J_{CV}(\\Theta)$，且它们之间的差距还是会很明显的","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"}]},{"title":"LeetCode500 Keyboard Row","slug":"leetcode500-keyboard-row","date":"2017-03-05T16:00:00.000Z","updated":"2019-02-08T10:26:00.218Z","comments":true,"path":"posts/leetcode500-keyboard-row/","link":"","permalink":"https://orzyt.cn/posts/leetcode500-keyboard-row/","excerpt":"","text":"描述Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 样例12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] 思路判断一个字符串是不是由键盘上同一行的字符组成的，若是则输出该字符串。 将同一行的字符用map映射到同一个值，然后再对输入的字符串逐个字符比较判断即可。 注意大小写的问题。 代码123456789101112131415class Solution &#123;public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123; string r[3] = &#123;\"QWERTYUIOP\", \"ASDFGHJKL\", \"ZXCVBNM\"&#125;; unordered_map&lt;char, int&gt; hs; for (int i = 0; i &lt; 3; ++i) for (auto&amp; c: r[i]) hs[c] = i; vector&lt;string&gt; ans; for(auto&amp; s: words) &#123; int row = hs[toupper(s[0])], ok = 1; for (auto&amp; c: s) if (hs[toupper(c)] != row) ok = 0; if (ok) ans.push_back(s); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"}]},{"title":"LeetCode21 Merge Two Sorted Lists","slug":"leetcode21-merge-two-sorted-lists","date":"2017-02-24T16:00:00.000Z","updated":"2019-02-08T10:26:00.362Z","comments":true,"path":"posts/leetcode21-merge-two-sorted-lists/","link":"","permalink":"https://orzyt.cn/posts/leetcode21-merge-two-sorted-lists/","excerpt":"","text":"描述Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 样例123Input: [1, 2, 3, 3][1, 4, 5] 12Output: [1, 1, 2, 3, 3, 4, 5] 思路合并两个有序链表。 实现分为递归和非递归的方式，其中非递归写起来稍微麻烦一点，需要判断的情况比较多。相比较之下，递归的写法更加直观自然。 代码 非递归版 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (!l1 &amp;&amp; !l2) return NULL; ListNode* newList = new ListNode(0); ListNode* head = newList; // 指向新链表的头 while (1) &#123; // 如果l2为空，或者l1的值小等于l2的，则把l1的值加到新链表中 if (l2 == NULL || (l1 != NULL &amp;&amp; l1-&gt;val &lt;= l2-&gt;val)) &#123; head-&gt;val = l1-&gt;val; l1 = l1-&gt;next; &#125; else &#123; head-&gt;val = l2-&gt;val; l2 = l2-&gt;next; &#125; // l1和l2都为空，则退出 if (!l1 &amp;&amp; !l2) break; head-&gt;next = new ListNode(0); head = head-&gt;next; &#125; return newList; &#125;&#125;; 递归版 12345678910111213class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (!l1 || !l2) return l1 ? l1 : l2; if (l1-&gt;val &lt;= l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://orzyt.cn/tags/链表/"}]},{"title":"LeetCode28 Implement strStr","slug":"leetcode28-implement-strstr","date":"2017-02-24T16:00:00.000Z","updated":"2019-02-08T10:26:00.366Z","comments":true,"path":"posts/leetcode28-implement-strstr/","link":"","permalink":"https://orzyt.cn/posts/leetcode28-implement-strstr/","excerpt":"","text":"描述Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 样例123Input: abcaca 12Output: 2 思路实现strStr()函数。该函数是用来在s串中查询是否存在串t的，若存在则返回第一次出现的下标。 字符串匹配的模板题，使用KMP算法即可。注意要特判串t为空的情况。 代码1234567891011121314151617181920212223242526class Solution &#123;private: int* fail;public: void getFail(string s) &#123; int i = 0, j, n = s.size(); fail = new int[n + 1]; j = fail[0] = -1; while (i &lt; n) &#123; while (j != -1 &amp;&amp; s[i] != s[j]) j = fail[j]; fail[++i] = ++j; &#125; &#125; int strStr(string haystack, string needle) &#123; if (needle == \"\") return 0; getFail(needle); int i = 0, j = 0; int n = haystack.size(), m = needle.size(); while (i &lt; n) &#123; while (j != -1 &amp;&amp; haystack[i] != needle[j]) j = fail[j]; ++i; ++j; if (j == m) return i - m; &#125; return -1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"},{"name":"KMP","slug":"KMP","permalink":"https://orzyt.cn/tags/KMP/"}]},{"title":"LeetCode35 Search Insert Position","slug":"leetcode35-search-insert-position","date":"2017-02-24T16:00:00.000Z","updated":"2019-02-08T10:26:00.310Z","comments":true,"path":"posts/leetcode35-search-insert-position/","link":"","permalink":"https://orzyt.cn/posts/leetcode35-search-insert-position/","excerpt":"","text":"描述Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 样例1234[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 思路将一个数插入到有序数组（数组中没有重复的元素）中去，输出插入的位置。 二分查找即可。知乎上有一个讨论二分查找有几种写法？它们的区别是什么？，可以围观一下~ 代码12345678910111213class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &lt; target) l = mid + 1; else r = mid; &#125; if (nums[r] &lt; target) return nums.size(); return r; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode50 Pow(x, n)","slug":"leetcode50-powx-n","date":"2017-02-24T16:00:00.000Z","updated":"2019-02-08T10:26:00.250Z","comments":true,"path":"posts/leetcode50-powx-n/","link":"","permalink":"https://orzyt.cn/posts/leetcode50-powx-n/","excerpt":"","text":"描述Implement pow(x, n). 样例12Input:2 3 12Output:8 思路计算$x^n$，其中​x为浮点数，​n为整数。 使用快速幂算法，注意特判n小于0的情况。 代码12345678910class Solution &#123;public: double myPow(double x, int n) &#123; double ans = 1; long long p = n; if (n &lt; 0) p = -1LL * n, x = 1.0 / x; for (; p; p &gt;&gt;= 1, x = x*x) if (p &amp; 1) ans *= x; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"}]},{"title":"LeetCode9 Palindrome Number","slug":"leetcode9-palindrome-number","date":"2017-02-24T16:00:00.000Z","updated":"2019-02-08T10:26:00.054Z","comments":true,"path":"posts/leetcode9-palindrome-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode9-palindrome-number/","excerpt":"","text":"描述Determine whether an integer is a palindrome. Do this without extra space. 样例1Input: 121 1Output: true 思路判断一个数是否是回文的。 首先负数肯定不是，因为有个负号。其次，最后一位不能为0，因为翻转之后会有前导0。 然后只要把前半段和后半段的数（后半段的要翻转一下）取出来比较，判断是否相等即可。 比如123321，则前半段为123，翻转之后的后半段也是123，说明是回文的。 注意如果是奇数的话，要去掉中间的那位再比较。 代码123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0 || (x &gt; 0 &amp;&amp; x % 10 == 0)) return false; int rev = 0; while (rev &lt; x) &#123; rev = rev * 10 + x % 10; x /= 10; &#125; return (rev == x) || (rev / 10 == x); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"Coursera Machine Learning 神经网络模型","slug":"coursera-neural-networks-model","date":"2017-02-15T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/coursera-neural-networks-model/","link":"","permalink":"https://orzyt.cn/posts/coursera-neural-networks-model/","excerpt":"非线性假设函数 既然前面已经有效果不错的线性回归和逻辑回归模型了，那么我们为什么还需要神经网络模型呢？试想，在面对一个复杂庞大的数据集时，若使用线性回归我们势必要增加大量的特征才能够较好的拟合数据。比如说现在有$n$个特征，要生成所有的平方项，则其数量大约在$\\mathcal{O}(n^2/2)$左右，显然次数越高其数量增长速度越快。举个例子，现在我们有一个50*50像素的黑白照片数据集，训练目标是判断图片中是否包含有车辆。若我们选取每个像素来作为特征的话，那么特征数量$n$则为2500（如果是RGB彩色图片的话，则是7500），则其所有的平方项特征大约在三百万左右! 显然这是不切实际的，因此我们必须另辟蹊径。幸运的是，神经网络能为我们提供更为复杂的模型表示。","text":"非线性假设函数 既然前面已经有效果不错的线性回归和逻辑回归模型了，那么我们为什么还需要神经网络模型呢？试想，在面对一个复杂庞大的数据集时，若使用线性回归我们势必要增加大量的特征才能够较好的拟合数据。比如说现在有$n$个特征，要生成所有的平方项，则其数量大约在$\\mathcal{O}(n^2/2)$左右，显然次数越高其数量增长速度越快。举个例子，现在我们有一个50*50像素的黑白照片数据集，训练目标是判断图片中是否包含有车辆。若我们选取每个像素来作为特征的话，那么特征数量$n$则为2500（如果是RGB彩色图片的话，则是7500），则其所有的平方项特征大约在三百万左右! 显然这是不切实际的，因此我们必须另辟蹊径。幸运的是，神经网络能为我们提供更为复杂的模型表示。 神经网络表示神经网络是一种用来模拟人类大脑神经元工作的学习方法。 神经元生物意义上的神经元由以下三部分组成： 细胞体（处理信息） 树突（输入端） 轴突（输出端） 而在人工神经网络中，“神经元”则是一个简化的逻辑单元。其中的输入则是$x_1\\cdots x_n$这些特征（其中$x_0$叫bias unit，恒为1），输出则是由假设函数计算得出，处理输入的信息则是采用各种激活函数（常用的有Sigmoid函数等），特别的还有称为权重的$\\theta$参数，用来对输入给予不同的权重。 神经网络神经网络由若干层（layer）组成。第一层叫做“输入层”，最后一层叫做“输出层”，中间还有若干个“隐藏层”。 \\begin{align*}& a_i^{(j)} = \\text{第$j$层的第$i$个激活单元} \\newline& \\Theta^{(j)} = \\text{从第$j$层到第$j+1$层的权重矩阵} \\newline& \\text{如果第$j$层有 $s_j$个单元且第$j+1$有$s_{j+1}$个单元,那么 $\\Theta^{(j)}$是 $s_{j+1} \\times (s_j + 1)$维的矩阵.}\\end{align*}前向传播的向量化实现 为了将前向传播用向量化方法实现，我们引入一个新的变量： $z_k^{(j)}$表示第$j$层第$i$个单元激活函数里的参数。 因此有$z^{(j)} = \\Theta^{(j-1)}a^{(j-1)}$，$a^{(j)} = g(z^{(j)})$。若最后一层为第$k$层，则最终的结果为 $h_\\Theta(x) = a^{k} = g(z^{(k)})$ 非线性分类实例逻辑与 \\Theta^{(1)} =\\begin{bmatrix}-30 & 20 & 20\\end{bmatrix}\\begin{align*}& h_\\Theta(x) = g(-30 + 20x_1 + 20x_2) \\newline \\newline & x_1 = 0 \\ \\ and \\ \\ x_2 = 0 \\ \\ then \\ \\ g(-30) \\approx 0 \\newline & x_1 = 0 \\ \\ and \\ \\ x_2 = 1 \\ \\ then \\ \\ g(-10) \\approx 0 \\newline & x_1 = 1 \\ \\ and \\ \\ x_2 = 0 \\ \\ then \\ \\ g(-10) \\approx 0 \\newline & x_1 = 1 \\ \\ and \\ \\ x_2 = 1 \\ \\ then \\ \\ g(10) \\approx 1\\end{align*}逻辑或 \\Theta^{(1)} =\\begin{bmatrix}-10 & 20 & 20\\end{bmatrix}\\begin{align*}& h_\\Theta(x) = g(-10 + 20x_1 + 20x_2) \\newline \\newline & x_1 = 0 \\ \\ and \\ \\ x_2 = 0 \\ \\ then \\ \\ g(20) \\approx 0 \\newline & x_1 = 0 \\ \\ and \\ \\ x_2 = 1 \\ \\ then \\ \\ g(-10) \\approx 0 \\newline & x_1 = 1 \\ \\ and \\ \\ x_2 = 0 \\ \\ then \\ \\ g(-10) \\approx 0 \\newline & x_1 = 1 \\ \\ and \\ \\ x_2 = 1 \\ \\ then \\ \\ g(10) \\approx 1\\end{align*}异或非这是一个由多个层组合起来的更复杂的函数表示。 多分类问题输出层可以有多个输出单元，第$i$个单元为1表示输入的样本属于第$i$类。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"}]},{"title":"Coursera Machine Learning 逻辑回归和正则化","slug":"coursera-logistic-regression-and-regularization","date":"2017-02-03T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/coursera-logistic-regression-and-regularization/","link":"","permalink":"https://orzyt.cn/posts/coursera-logistic-regression-and-regularization/","excerpt":"二元分类对于二元分类来说，其输出值 $y$ 不再是一个连续的值，而是属于 $\\lbrace 0,1 \\rbrace$，一般0代表negative class，而1代表positive class。想要实现二元分类，一种方法是在线性回归的基础上进行修改，比如说输出值$y$超过了某一阈值，则认为它属于1，否则属于0，但是这个效果通常来说不是很好。","text":"二元分类对于二元分类来说，其输出值 $y$ 不再是一个连续的值，而是属于 $\\lbrace 0,1 \\rbrace$，一般0代表negative class，而1代表positive class。想要实现二元分类，一种方法是在线性回归的基础上进行修改，比如说输出值$y$超过了某一阈值，则认为它属于1，否则属于0，但是这个效果通常来说不是很好。 假设函数的表示首先，分类问题中的$h_\\theta (x)$函数要满足$0 \\leq h_\\theta (x) \\leq 1$，为此引入一个新的函数——Sigmoid Function。sigmoid函数定义为：$g(z) = \\dfrac{1}{1 + e^{-z}}$，它可以将任意的实数映射到区间$(0, 1)$ 。函数的大致图像如下： 在分类问题中，$h_\\theta (x) = g ( \\theta^T x )$，也就是在sigmoid函数作用下，将原本线性回归的输出值映射到$(0, 1)$区间。同时$h_\\theta (x)$的含义也有了变化，代表着在输入为$x$的情况下 ，其类别为1的概率大小。形式化的表示就是：$h_\\theta(x) = P(y = 1 | x; \\theta)$ 决策边界在将$h_\\theta (x)$ 映射到$ (0, 1) $区间之后，我们可以认为当$h_\\theta(x) \\geq 0.5 $时$y = 1$，$h_\\theta(x) &lt; 0.5$时$y = 0$。观察sigmoid函数的图像不难发现，$z \\geq 0$ 时 $g(z) \\geq 0.5 $，因此 $y = 1$ 的充要条件就是 $\\theta^T x &gt;= 0$ 。而所谓的决策边界(decision boundary)就是 $ \\theta^T x = 0$ 所构成的曲线。 损失函数逻辑回归的损失函数如下： \\begin{align*}& J(\\theta) = \\dfrac{1}{m} \\sum_{i=1}^m \\mathrm{Cost}(h_\\theta(x^{(i)}),y^{(i)}) \\newline & 其中\\newline & \\mathrm{Cost}(h_\\theta(x),y) = -\\log(h_\\theta(x)) \\; & \\text{if y = 1} \\newline & \\mathrm{Cost}(h_\\theta(x),y) = -\\log(1-h_\\theta(x)) \\; & \\text{if y = 0}\\end{align*}还是先来看下函数图像，有一个直观的感受 上述的 Cost 函数要分类讨论，计算的时候比较麻烦。其实可以化简成一个式子来表示两种情况，就是 $\\mathrm{Cost}(h_\\theta(x),y) = - y \\; \\log(h_\\theta(x)) - (1 - y) \\log(1 - h_\\theta(x))$ ，不难验证两者是等价的。 梯度下降$J(\\theta) = - \\frac{1}{m} \\displaystyle \\sum_{i=1}^m [y^{(i)}\\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\log (1 - h_\\theta(x^{(i)}))]$ 梯度下降算法（跟线性回归时的一样）： \\begin{align*}& Repeat \\; \\lbrace \\newline & \\; \\theta_j := \\theta_j - \\alpha \\dfrac{\\partial}{\\partial \\theta_j}J(\\theta) \\newline & \\rbrace\\end{align*}其中，$\\dfrac{\\partial}{\\partial \\theta_j}J(\\theta) = \\frac{1}{m}\\sum_{i=1}^m \\left [ h_\\theta(x^{(i)}) - y^{(i)} \\right ] x^{(i)}_j$ 高级优化虽然采用梯度下降算法也能求得结果，但是还存在一些更好的优化算法。不过一般来说都会比较复杂，没必要自己亲自实现。Matlab或Octave中有提供一个fminunc函数可以用来找到一个无约束多变量函数的最小值 (Find a minimum of an unconstrained multivariable function) 。 123456789示例代码：function [jVal, gradient] = costFunction(theta) jVal = [...code to compute J(theta)...]; gradient = [...code to compute derivative of J(theta)...];endoptions = optimset('GradObj', 'on', 'MaxIter', 100);initialTheta = zeros(2,1);[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options); 具体用法参阅：fminunc Unconstrained Minimization 多分类问题在多分类问题中，结果不再仅仅只有0、1两类，而是可能有多种分类结果。那么此时该如何处理呢？ 其实很简单，One-vs-all！将多分类问题转化成二元分类问题。 比如$y \\in \\lbrace0, 1 … n\\rbrace$ ，那么我们可以训练 $n+1$ 个二元分类器 $h_\\theta ^{(0)}(x), h_\\theta ^{(1)}(x), …, h_\\theta ^{(n)}(x)$ 。在第 $i$ 个二元分类器中，它只要计算当前输入为第 $i$ 个分类的概率。那么样本的类别就是等于这 $n+1$个结果中概率最大的那个类别，即 $ \\mathrm{类别} = \\max_i( h_\\theta ^{(i)}(x) ) $ 。 过拟合欠拟合(underfitting)：模型复杂度过低，不能很好的拟合所有的数据，训练误差大。 过拟合(Overfitting)：模型复杂度过高，训练数据过少，训练误差虽小，但测试误差大。 欠拟合对应高偏差(bias)，过拟合对应高方差(variance)。 正则化通过在损失函数中加入正则化项(regularizer)来避免过拟合问题。 min_\\theta\\ \\dfrac{1}{2m}\\ \\left[ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})^2 + \\lambda\\ \\sum_{j=1}^n \\theta_j^2 \\right]其中，$\\lambda$ 称作正则化参数，用来控制拟合训练数据和保持参数值较小这两个目标之间的关系。 对线性回归进行正则化 梯度下降： \\begin{align*} & \\text{Repeat}\\ \\lbrace \\newline & \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline & \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline & \\rbrace\\end{align*}正规方程(Normal equation)： \\begin{align*}& \\theta = \\left( X^TX + \\lambda \\cdot L \\right)^{-1} X^Ty \\newline& \\text{其中}\\ \\ L = \\begin{bmatrix} 0 & & & & \\newline & 1 & & & \\newline & & 1 & & \\newline & & & \\ddots & \\newline & & & & 1 \\newline\\end{bmatrix}\\end{align*} 对逻辑回归进行正则化 J(\\theta) = - \\frac{1}{m} \\sum_{i=1}^m \\large[ y^{(i)}\\ \\log (h_\\theta (x^{(i)})) + (1 - y^{(i)})\\ \\log (1 - h_\\theta(x^{(i)}))\\large] + \\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2梯度下降： \\begin{align*}& \\text{Repeat}\\ \\lbrace \\newline& \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\newline& \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2...n\\rbrace\\newline& \\rbrace\\end{align*} 需要注意的是，一般都不对 $\\theta_0$ 进行正则化（$\\theta_0$ 恒为1），因此在上面的公式中下标 $j$ 都从1开始。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"}]},{"title":"LeetCode268 Missing Number","slug":"leetcode268-missing-number","date":"2017-02-03T16:00:00.000Z","updated":"2019-02-08T10:26:00.470Z","comments":true,"path":"posts/leetcode268-missing-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode268-missing-number/","excerpt":"","text":"描述Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 样例Given nums = [0, 1, 3] return 2. 思路从$[0, n]$ 中给出 $n$ 个不同的数，问哪一个数不在里面。 0 到 n 之和 再扣掉 数组元素之和，即得到答案。 代码12345678class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), ans = n * (n + 1) / 2; for (int&amp; x: nums) ans -= x; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode326 Power of Three","slug":"leetcode326-power-of-three","date":"2017-02-03T16:00:00.000Z","updated":"2019-02-08T10:26:00.450Z","comments":true,"path":"posts/leetcode326-power-of-three/","link":"","permalink":"https://orzyt.cn/posts/leetcode326-power-of-three/","excerpt":"","text":"描述Given an integer, write a function to determine if it is a power of three. 样例12Input: 3Output: true 思路判断一个数是否为3的次幂。 直接模拟，或者先找到int范围内最大的3次幂（也就是1162261467）看能否整除，能整除说明输入的是3的次幂。 代码12345678class Solution &#123;public: bool isPowerOfThree(int n) &#123; long long x = 1; for (; x &lt; n; x *= 3); return x == n; &#125;&#125;; 123456class Solution &#123;public: bool isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; 1162261467 % n == 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode350 Intersection of Two Arrays II","slug":"leetcode350-intersection-of-two-arrays-ii","date":"2017-02-03T16:00:00.000Z","updated":"2019-02-08T10:26:00.382Z","comments":true,"path":"posts/leetcode350-intersection-of-two-arrays-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode350-intersection-of-two-arrays-ii/","excerpt":"","text":"描述Given two arrays, write a function to compute their intersection. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 样例1Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. 思路求两个数组的交，结果不去重。 具体解法可参考LeetCode349-Intersection-of-Two-Arrays这题，只不过少掉了去重操作而已。 代码123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n = nums1.size(), m = nums2.size(), i = 0, j = 0; vector&lt;int&gt; ans; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (nums1[i] &lt; nums2[j]) i++; else if (nums1[i] &gt; nums2[j]) j++; else &#123; ans.push_back(nums1[i]); i++; j++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"},{"name":"排序","slug":"排序","permalink":"https://orzyt.cn/tags/排序/"}]},{"title":"LeetCode401 Binary Watch","slug":"leetcode401-binary-watch","date":"2017-02-03T16:00:00.000Z","updated":"2019-02-08T10:26:00.382Z","comments":true,"path":"posts/leetcode401-binary-watch/","link":"","permalink":"https://orzyt.cn/posts/leetcode401-binary-watch/","excerpt":"","text":"描述A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. 样例123Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 思路这是一个神奇的二进制手表… 问当有n个LED灯亮起时，可能的时间是多少。 直接枚举所有时间，再判断当前时间的二进制表示中1的个数是否满足即可。用到了 一个小技巧就是把时间用二进制压缩表示。h &lt;&lt; 6 | m，h是小时数，m是分钟数，由于分钟数最多用6个二进制位表示即可，所以低6位用来表示分钟，高位则表示小时。最后再用系统自带的__builtin_popcount()函数计算二进制中1的个数。 代码1234567891011121314class Solution &#123;public: vector&lt;string&gt; readBinaryWatch(int num) &#123; vector&lt;string&gt; ans; for (int h = 0; h &lt; 12; ++h) &#123; for (int m = 0; m &lt; 60; ++m) &#123; if (__builtin_popcount(h &lt;&lt; 6 | m) == num) &#123; ans.push_back(to_string(h) + (m &lt; 10 ? \":0\" : \":\") + to_string(m)); &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode405 Convert a Number to Hexadecimal","slug":"leetcode405-convert-a-number-to-hexadecimal","date":"2017-02-03T16:00:00.000Z","updated":"2019-02-08T10:26:00.030Z","comments":true,"path":"posts/leetcode405-convert-a-number-to-hexadecimal/","link":"","permalink":"https://orzyt.cn/posts/leetcode405-convert-a-number-to-hexadecimal/","excerpt":"","text":"描述Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used. Note: All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &#39;0&#39;; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly. 样例12345Input:26Output:&quot;1a&quot; 12345Input:-1Output:&quot;ffffffff&quot; 思路求一个int类型整数的十六进制表示。 直接4位4位压缩表示即可。需要注意的是负数的情况，由于C++中&gt;&gt;运算是带符号右移，负数的符号位是1右移高位会补1…然而我们的判断终止条件是为0（补1的话是永远不可能移到0的…），因此要先把有符号数转成无符号数再处理。 代码123456789101112131415class Solution &#123;public: string toHex(int num) &#123; if (num == 0) return \"0\"; string ans; unsigned int x = num, bit; while (x != 0) &#123; bit = x &amp; 0XF; ans += bit &gt; 9 ? bit - 10 + 'a' : bit + '0'; x &gt;&gt;= 4; &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode409 Longest Palindrome","slug":"leetcode409-longest-palindrome","date":"2017-02-03T16:00:00.000Z","updated":"2019-02-08T10:26:00.350Z","comments":true,"path":"posts/leetcode409-longest-palindrome/","link":"","permalink":"https://orzyt.cn/posts/leetcode409-longest-palindrome/","excerpt":"","text":"描述Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example &quot;Aa&quot; is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010. 样例12345678Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7. 思路问从输入的字符串中任意挑选出字符所能够组成的最长回文串的长度是多少。每个字符只能用一次，也可以不用。 一看题目还以为求最长回文子串，Manacher算法走起啊… 然而仔细看题并不是，其实只是一个模拟。首先统计出所有字符的个数，然后偶数个的通通加进来，奇数个的就扣掉一个变成偶数再加进来。注意，如果存在某个字符的个数是奇数的话，答案长度可以再加1，因为可以把这个字符放在中间。 代码12345678910111213141516171819class Solution &#123;public: int longestPalindrome(string s) &#123; int cnt[26][2] = &#123;0&#125;; for (char&amp; c: s) &#123; if (isupper(c)) cnt[c-'A'][0]++; else cnt[c-'a'][1]++; &#125; int ans = 0, add = 0, cur; for (int i = 0; i &lt; 26; ++i) &#123; for (int j = 0; j &lt; 2; ++j) &#123; cur = cnt[i][j]; if (cur &amp; 1) add = 1; ans += cur - (cur &amp; 1); &#125; &#125; return ans + add; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode189 Rotate Array","slug":"leetcode189-rotate-array","date":"2017-02-02T16:00:00.000Z","updated":"2019-02-08T10:26:00.446Z","comments":true,"path":"posts/leetcode189-rotate-array/","link":"","permalink":"https://orzyt.cn/posts/leetcode189-rotate-array/","excerpt":"","text":"描述Rotate an array of n elements to the right by k steps. 样例12For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. 思路将数组中每个元素循环右移k位。 不妨记A = [1, 2, 3, 4]，B = [5, 6, 7]，其目标就是是将原数组从 AB 变成 BA，所以可以运用$BA = (A^TB^T)^T$这一性质。注：$A^T$的意思是将数组$A$中元素翻转。 代码12345678910111213class Solution &#123;public: void reverse(vector&lt;int&gt;&amp; nums, int l, int r) &#123; while (l &lt; r) swap(nums[l++], nums[r--]); &#125; void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); k %= n; // 去掉无意义的移动 reverse(nums, 0, n - k - 1); reverse(nums, n - k, n - 1); reverse(nums, 0, n - 1); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode8 String to Integer (atoi)","slug":"leetcode8-string-to-integer-atoi","date":"2017-02-02T16:00:00.000Z","updated":"2019-02-08T10:26:00.298Z","comments":true,"path":"posts/leetcode8-string-to-integer-atoi/","link":"","permalink":"https://orzyt.cn/posts/leetcode8-string-to-integer-atoi/","excerpt":"","text":"描述Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 样例12Input: &quot;123&quot; 12Output: 123 思路实现$atoi$函数，这是一个将字符串转成$int$的函数。 这题坑爹的是要考虑所有可能的输入情况，然后又不给你样例…(#‵ ′)凸 自认为考虑周到了，符号啊，溢出啊，非法字符啊都考虑了，但是提交却WA了几遍… 第一次WA在输入可能有前导空白，比如 &quot; 123&quot; 。。第二次WA在正数的符号处理，比如像+1 （orz…只处理了’-‘的情况，没想到正数前面也可能加个’+’）。。 总的来说，$atoi$函数处理的方式应该是，先忽略前导空白符，再判断是否有+-符号，然后处理到第一个非法字符（不是0-9）为止。 代码123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; int l, r, sign = 1, n = str.size(); for (l = 0; l &lt; n &amp;&amp; isspace(str[l]); ++l); // 处理空白符 if (l &lt; n &amp;&amp; str[l] == '-') sign = -1, ++l; // 处理符号 else if (l &lt; n &amp;&amp; str[l] == '+') sign = 1, ++l; for (r = l; r &lt; n &amp;&amp; isdigit(str[r]); ++r); // 找到第一个非法字符 str = str.substr(l, r - l); // 合法数字的子串 long long num = 0; for (char&amp; c: str) &#123; num = num * 10 + c - '0'; if (sign * num &gt; INT_MAX) return INT_MAX; if (sign * num &lt; INT_MIN) return INT_MIN; &#125; return sign * num; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode7 Reverse Integer","slug":"leetcode7-reverse-integer","date":"2017-02-02T16:00:00.000Z","updated":"2019-02-08T10:26:00.258Z","comments":true,"path":"posts/leetcode7-reverse-integer/","link":"","permalink":"https://orzyt.cn/posts/leetcode7-reverse-integer/","excerpt":"","text":"描述Reverse digits of an integer. 样例1Example1: x = 123, return 321 1Example2: x = -123, return -321 思路将一个int类型数字翻转。 只要注意两点：符号和溢出。虽然输入是int类型，但是翻转之后不保证也在int范围内，比如说1000000007（十亿零七）翻转之后变成7000000001（七十亿零一），已经超过INT_MAX（2147483647）了，溢出就直接输出0即可。 代码1234567891011121314class Solution &#123;public: int reverse(int x) &#123; long long sign = 1, ans = 0; if (x &lt; 0) sign = -1, x = -x; while (x) &#123; ans = ans * 10 + x % 10; x /= 10; &#125; ans *= sign; if (ans &gt; INT_MAX || ans &lt; INT_MIN) ans = 0; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode121 Best Time to Buy and Sell Stock","slug":"leetcode121-best-time-to-buy-and-sell-stock","date":"2017-02-01T16:00:00.000Z","updated":"2019-02-08T10:26:00.286Z","comments":true,"path":"posts/leetcode121-best-time-to-buy-and-sell-stock/","link":"","permalink":"https://orzyt.cn/posts/leetcode121-best-time-to-buy-and-sell-stock/","excerpt":"","text":"描述Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 样例12345Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 思路给出$N$天的股价，在只能做一次交易的情况下，问最大收益是多少。 考虑第$i$天卖出的最大收益，其实就是等于第$i$天的价格减去前$i-1$天的最低价格，即prices[i] - min \\{ prices[k] \\ |\\ k = 1..i-1 \\} ，那么只要维护一个当前最小值就好了。 代码1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int ans = 0, curMin = INT_MAX; for (int&amp; x: prices) &#123; ans = max(ans, x - curMin); curMin = min(curMin, x); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"DP","slug":"DP","permalink":"https://orzyt.cn/tags/DP/"}]},{"title":"LeetCode13 Roman to Integer","slug":"leetcode13-roman-to-integer","date":"2017-02-01T16:00:00.000Z","updated":"2019-02-08T10:26:00.010Z","comments":true,"path":"posts/leetcode13-roman-to-integer/","link":"","permalink":"https://orzyt.cn/posts/leetcode13-roman-to-integer/","excerpt":"","text":"描述Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 样例12Input: XI 12Output: 6 思路将罗马数字转换成十进制数。 对罗马数字的转换规则并不是很熟悉，搜索之后也看得一脸懵逼… 来源： 维基百科—罗马数字 重复数次：一个罗马数字重复几次，就表示这个数的几倍。 右加左减： 在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。 在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。 但是，左减时不可跨越一个位值。 左减数字必须为一位。 右加数字不可连续超过三位。 加线乘千： 在罗马数字的上方加上一条横线或者加上下标的Ⅿ，表示将这个数乘以1000，即是原数的1000倍。 同理，如果上方有两条横线，即是原数的1000000倍。 数码限制： 同一数码最多只能连续出现三次，如40不可表示为XXXX，而要表示为XL。 例外：由于IV是古罗马神话主神朱庇特（即IVPITER，古罗马字母里没有J和U）的首字，因此有时用IIII代替IV。 好在本题只要求罗马数字转十进制且数字范围不大，我们其实只要关注重复数次和右加左减这两个规则。简单来说，就是直接把所有数字都加起来，再扣掉“左减”的贡献即可。 代码123456789101112131415161718192021class Solution &#123;public: unordered_map&lt;char, int&gt; hs; void initMap() &#123; hs['I'] = 1; hs['V'] = 5; hs['X'] = 10; hs['L'] = 50; hs['C'] = 100; hs['D'] = 500; hs['M'] = 1000; &#125; int romanToInt(string s) &#123; initMap(); int ans = hs[s[0]], n = s.size(); for (int i = 1; i &lt; n; ++i) &#123; if (hs[s[i-1]] &lt; hs[s[i]]) ans += hs[s[i]] - 2*hs[s[i-1]]; else ans += hs[s[i]]; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode206 Reverse Linked List","slug":"leetcode206-reverse-linked-list","date":"2017-02-01T16:00:00.000Z","updated":"2019-02-08T10:26:00.310Z","comments":true,"path":"posts/leetcode206-reverse-linked-list/","link":"","permalink":"https://orzyt.cn/posts/leetcode206-reverse-linked-list/","excerpt":"","text":"描述Reverse a singly linked list. 样例12Input: 1 -&gt; 2 -&gt; 3Output: 3 -&gt; 2 -&gt; 1 思路翻转链表。 建pre和next指针，然后理清指针之间该怎么交换就好了。 代码123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *pre = NULL, *next = NULL; while (head != NULL) &#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://orzyt.cn/tags/链表/"}]},{"title":"LeetCode217 Contains Duplicate","slug":"leetcode217-contains-duplicate","date":"2017-02-01T16:00:00.000Z","updated":"2019-02-08T10:25:59.990Z","comments":true,"path":"posts/leetcode217-contains-duplicate/","link":"","permalink":"https://orzyt.cn/posts/leetcode217-contains-duplicate/","excerpt":"","text":"描述Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 样例12Input: 1 2 2 3Output: true 思路判断数组中是否有重复的数字。 map记录下即可。 代码12345678class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; hs; for (int&amp; x: nums) if (++hs[x] &gt;= 2) return true; return false; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode231 Power of Two","slug":"leetcode231-power-of-two","date":"2017-02-01T16:00:00.000Z","updated":"2019-02-08T10:26:00.422Z","comments":true,"path":"posts/leetcode231-power-of-two/","link":"","permalink":"https://orzyt.cn/posts/leetcode231-power-of-two/","excerpt":"","text":"描述Given an integer, write a function to determine if it is a power of two. 样例12Input: 2Output: true 思路判断一个数是否为2的次幂。 显然2次幂在二进制表示中只有一个1，所以可以用LeetCode338 Counting Bits中的方法计算1的个数。 其实还有比较简单的方法是，将这个“1”去掉，看得到的数是否为0，为0说明二进制中只有一个1。 代码12345678class Solution &#123;public: bool isPowerOfTwo(int n) &#123; int bitCount = 0; for (; n &gt; 0; n &amp;= (n-1), bitCount++); return bitCount == 1; &#125;&#125;; 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n &amp; (n-1)); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"Matlab Tutorial","slug":"matlab-tutorial","date":"2017-02-01T16:00:00.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/matlab-tutorial/","link":"","permalink":"https://orzyt.cn/posts/matlab-tutorial/","excerpt":"Basic Operations1234567891011%% 元素操作5+63-25*81/22^6 % 次方，不是异或1 == 2 % 假1 ~= 2 % 真 注意，不是用 \"!=\"1 &amp;&amp; 01 || 0xor(1,0)","text":"Basic Operations1234567891011%% 元素操作5+63-25*81/22^6 % 次方，不是异或1 == 2 % 假1 ~= 2 % 真 注意，不是用 \"!=\"1 &amp;&amp; 01 || 0xor(1,0) 1234%% 变量赋值a = 3; % 加分号就不会立即输出b = 'hi';c = 3&gt;=1; 123456789% 显示a = pidisp(a)disp(sprintf('2 decimals: %0.2f', a)) % 类似C中printfdisp(sprintf('6 decimals: %0.6f', a))format long % 改变显示的格式aformat shorta 1234567891011121314151617181920212223%% 向量和矩阵A = [1 2; 3 4; 5 6] % 3x2矩阵v = [1 2 3] % 行向量v = [1; 2; 3] % 列向量v = 1:0.1:2 % 从1到2，步长为0.1v = 1:6 % 从1到6，默认步长为1C = 2*ones(2,3) % 等同于 C = [2 2 2; 2 2 2]w = ones(1,3) % 1x3 的全一向量w = zeros(1,3) % 1x3 的全零向量w = rand(1,3) % 1x3矩阵，元素的值在(0,1)之间，产生于均匀分布w = randn(1,3) % 1x3矩阵，产生于标准正态分布w = -6 + sqrt(10)*(randn(1,10000)); hist(w) % 绘制直方图，默认10等分hist(w,50) % 绘制直方图，50等分I = eye(4) % 4x4 单位矩阵% help 函数，可以查看每个函数的说明help eyehelp randhelp help Moving Data Around1234567891011121314151617181920212223242526272829303132333435363738%% 维数sz = size(A) % 返回1x2 矩阵: [行数, 列数]size(A,1) % 行数size(A,2) % 列数length(v) % 最长维的大小%% 加载数据pwd % 显示当前路径cd 'C:\\Users\\ang\\Octave files' % 改变目录ls % 显示当前目录下的文件load q1y.dat % 也可写成 load('q1y.dat')load q1x.datwho % 显示当前工作空间的变量whos % 显示当前工作空间变量的详细信息clear q1y % 若没有指定变量名，则清空当前工作空间的全部变量v = q1x(1:10); % q1x的前10个元素 (按列数下来)save hello.mat v; % 将变量v的内容保存在hello.mat里save hello.txt v -ascii; % 以ascii码保存% fopen, fread, fprintf, fscanf %% 索引A(3,2) % (行, 列)A(2,:) % 得到第二行 % \":\" 意味着得到那一维的所有元素A(:,2) % 得到第二列A([1 3],:) % 得到第1和第3行的元素A(:,2) = [10; 11; 12] % 改变第二行的元素A = [A, [100; 101; 102]]; % 加一列A(:) % 以列向量的形式展示矩阵A中的所有元素% 将数据放在一起A = [1 2; 3 4; 5 6]B = [11 12; 13 14; 15 16] % 和A同维C = [A B] % A、B并排C = [A, B] % A、B并排C = [A; B] % A、B上下排列 Computing on Data12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455%% 初始化变量A = [1 2;3 4;5 6]B = [11 12;13 14;15 16]C = [1 1;2 2]v = [1;2;3]%% 矩阵操作A * C % 矩阵乘法A .* B % 逐元素相乘% A .* C or A * B 会得到错误 A .^ 2 % 对A中每个元素都平方1./v % 对v中每个元素取倒数% 以下三个函数，对标量、向量、矩阵都适用log(v) exp(v)abs(v)-v % -1*vv + ones(length(v), 1) % v中每个元素都加1，也可写成 v + 1A' % 矩阵转置%% 一些有用的函数% max (or min)a = [1 15 2 0.5]val = max(a)[val,ind] = max(a) % 返回最大的元素，及其第一次出现的下标val = max(A) % 返回矩阵A中每列的最大值% 比较a &lt; 3 % 检查a是否小于3find(a &lt; 3) % 找出a中所有小于3的位置, 按列数A = magic(3) % 生成3阶幻方[r,c] = find(A&gt;=7) % 返回A&gt;=7的元素的横纵坐标% sum, prodsum(a) % 按列求和prod(a) % 按列求积floor(a)% 向下取整ceil(a) % 向上取整max(rand(3),rand(3)) % 逐元素比较大小max(A,[],1) % 返回矩阵A中每列的最大值, 等于max(A)max(A,[],2) % 返回矩阵A中每行的最大值A = magic(9)sum(A,1) % 按列求和sum(A,2) % 按行求和sum(sum( A .* eye(9) )) % 主对角线求和sum(sum( A .* flipud(eye(9)) )) % 副对角线求和% 矩阵伪逆 (pseudo-inverse)pinv(A) % 等于inv(A'*A)*A' Plotting Data1234%% 绘图t = [0:0.01:0.98];y1 = sin(2*pi*4*t);plot(t,y1); % 见pic1 123y2 = cos(2*pi*4*t);hold on; % 保持当前图像，\"hold off\"关闭plot(t,y2,'r'); % 见pic2 12345xlabel('time'); % 横轴标识符ylabel('value'); % 纵轴标识符legend('sin','cos'); % 图例title('my plot'); % 标题% 见pic3 12print -dpng 'myPlot.png' % 保存当前图片close; % 关闭当前图片 12345figure(1); plot(t, y1); % 在figure1中绘制图像figure(2); plot(t, y2); % 在figure2中绘制图像figure(2), clf; % 清空figure2中的图像subplot(1,2,1); % 创建 1x2 的子图, 并访问第一个子图plot(t,y1); % 图像绘制在第一个子图上,见pic4 123subplot(1,2,2); % 创建 1x2 的子图, 并访问第二个子图plot(t,y2); % 图像绘制在第二个子图上,见pic5axis([0.5 1 -1 1]); % 改变坐标轴范围 123%% 将矩阵以图像显示,见pic6figure;imagesc(magic(15)), colorbar, colormap gray; Control statements12345678910111213141516171819202122232425262728293031% for 循环v = zeros(10,1);for i = 1:10 v(i) = 2^i;end;% while 循环i = 1;while i &lt;= 5 v(i) = 100; i = i+1;end% break、continuei = 1;while true, v(i) = 999; i = i+1; if i == 6, break; end;end% if-else 语句if v(1)==1, disp('The value is one!');elseif v(1)==2, disp('The value is two!');else disp('The value is not one or two!');end Function12345678910111213141516171819function [输出实参表] = 函数名(输入实参数) 注释部分 函数体语句end 定义:% foo.mfunction [x, y] = foo(a, b) x = a + b; y = a - b;end 调用:&gt;&gt; a = 1, b = 2;&gt;&gt; [x, y] = foo(a, b)x = 3y = -1","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"},{"name":"Matlab","slug":"Matlab","permalink":"https://orzyt.cn/tags/Matlab/"}]},{"title":"Coursera Machine Learning 多元线性回归和多项式回归","slug":"coursera-linear-regression-with-multiple-variables-and-polynomial-regression","date":"2017-01-27T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/coursera-linear-regression-with-multiple-variables-and-polynomial-regression/","link":"","permalink":"https://orzyt.cn/posts/coursera-linear-regression-with-multiple-variables-and-polynomial-regression/","excerpt":"多变量线性回归多特征 $x^{(i)}$ ：第i个训练数据 $x_j^{(i)}$ ：第$i$个数据的第$j$个特征 $m$ ：训练集大小 $n$ ：特征数量 \\begin{align*}h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n \\newline =\\begin{bmatrix}\\theta_0 \\hspace{2em} \\theta_1 \\hspace{2em} ... \\hspace{2em} \\theta_n\\end{bmatrix}\\begin{bmatrix}x_0 \\newline x_1 \\newline \\vdots \\newline x_n\\end{bmatrix}= \\theta^T x\\end{align*}若对整个数据集进行运算，有：$h_\\theta(X) = X \\theta$","text":"多变量线性回归多特征 $x^{(i)}$ ：第i个训练数据 $x_j^{(i)}$ ：第$i$个数据的第$j$个特征 $m$ ：训练集大小 $n$ ：特征数量 \\begin{align*}h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n \\newline =\\begin{bmatrix}\\theta_0 \\hspace{2em} \\theta_1 \\hspace{2em} ... \\hspace{2em} \\theta_n\\end{bmatrix}\\begin{bmatrix}x_0 \\newline x_1 \\newline \\vdots \\newline x_n\\end{bmatrix}= \\theta^T x\\end{align*}若对整个数据集进行运算，有：$h_\\theta(X) = X \\theta$ 多变量的梯度下降 Gradient Descent(梯度下降算法) \\begin{align*}& \\text{repeat until convergence:} \\; \\lbrace \\newline \\; & \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} \\; & \\text{for j := 0...n}\\newline \\rbrace\\end{align*} 矩阵形式：$\\theta := \\theta - \\frac{\\alpha}{m} X^{T} (X\\theta - \\vec{y})$ Feature Scaling(特征缩放) 用原始数据除以该数据的范围（即RANGE = MAX-MIN)，或除以标准差。 Mean Normalization(均值归一化) 用原始数据减去该数据的均值。 运用上述两种技术，得到公式：$x_i := \\dfrac{x_i - \\mu_i}{s_i}$，其中$\\mu_i$是$x$的平均值，${s_i}$是$x$的标准差。 Learning Rate(学习率) α过小：慢收敛 α过大：每次迭代可能不会使J值减小，可能因此导致发散 多项式回归有的时候线性回归不能很好的拟合数据，这个时候可以考虑用多项式回归。 比如对于 $h_\\theta(x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_1^2 + \\theta_3 x_1^3$ 这个函数来说，我们可以新建两个变量$x_2$ 、 $x_3$ 使得 $ x_2 = x_1^{2} $ 、$ x_3 = x_1^{3}$ ，从而转化成线性回归的形式，得到 $h_\\theta(x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3$ 分析法计算参数正规方程正规方程（Normal Equation） formula ：$\\theta = (X^T X)^{-1}X^T y$ 注意：其中矩阵的逆是伪逆矩阵，即Moore–Penrose pseudoinverse，在Matlab中可用pinv计算。 这个公式可以直接算出$\\theta$的值，不需要像梯度下降那样进行迭代，也不需要进行Feature scaling和Mean normalization。 对比： Gradient Descent Normal Equation Need to choose alpha No need to choose alpha Needs many iterations No need to iterate O(kn^2) O(n^3), need to calculate inverse of X^TX Works well when n is large Slow if n is very large 可逆性问题如果$X^TX$不可逆，主要有以下两种原因： 有多余的特征，且这些特征线性相关 特征过多，比如说特征数(n)比样本数(m)还多","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"}]},{"title":"LeetCode100 Same Tree","slug":"leetcode100-same-tree","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.010Z","comments":true,"path":"posts/leetcode100-same-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode100-same-tree/","excerpt":"","text":"描述Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 样例1无 思路判断两颗二叉树是否相等，必须结构相等且值也相等。 dfs时，对p和q是否为空进行分类讨论。在p、q都不为空时，再判断下节点值是否相等。 代码123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == NULL &amp;&amp; q == NULL) return true; else if (p != NULL &amp;&amp; q == NULL) return false; else if (p == NULL &amp;&amp; q != NULL) return false; else &#123; if (p-&gt;val != q-&gt;val) return false; else return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode122 Best Time to Buy and Sell Stock II","slug":"leetcode122-best-time-to-buy-and-sell-stock-ii","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.054Z","comments":true,"path":"posts/leetcode122-best-time-to-buy-and-sell-stock-ii/","link":"","permalink":"https://orzyt.cn/posts/leetcode122-best-time-to-buy-and-sell-stock-ii/","excerpt":"","text":"描述Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 样例12345Input:[1, 2, 100, 10]Output: 99 思路给出每天的股价，每天只能进行一笔交易，可以买入或卖出，问最大的盈利是多少。 如果价格在$[i, j]$天呈现 price_{i} < price_{i+1} < ... < price_{j}的趋势，那么在第i天买入，第j天卖出，至少可以使得利润不会变得更差。 代码123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(), ans = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; if (prices[i + 1] &gt; prices[i]) &#123; ans += prices[i + 1] - prices[i]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"贪心","slug":"贪心","permalink":"https://orzyt.cn/tags/贪心/"}]},{"title":"LeetCode169 Majority Element","slug":"leetcode169-majority-element","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.418Z","comments":true,"path":"posts/leetcode169-majority-element/","link":"","permalink":"https://orzyt.cn/posts/leetcode169-majority-element/","excerpt":"","text":"描述Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 样例12345Input:[1, 2, 2, 2]Output:2 思路找出数组中出现次数大于$⌊ n/2 ⌋$次的元素。 一个直观的想法是用$map$记录每个数字出现的次数然后再比较是否大于指定的次数即可。当然，分治也可以做，每次划分成子区间去找，合并的时候看那个出现的次数更多。这两个做法复杂度都是$\\mathcal{O}(nlogn)$的。 其实也有线性复杂度的做法。先讲一下位运算的做法，出现次数大于$n/2$次的元素，显然其对应的二进制位出现的次数肯定也大于$n/2$次，所以枚举二进制位然后判断一下次数即可。 然后再介绍一个神奇的算法Moore Voting Algorithm，具体可以参阅A Linear Time Majority Vote Algorithm主要思想是将两两不同的数相互抵消，剩下没有消掉的肯定是次数超过一半的数。 代码哈希： $\\mathcal{O}(nlogn)$12345678class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int times = nums.size() / 2; map&lt;int, int&gt; hashTable; for (int&amp; x: nums) if (++hashTable[x] &gt; times) return x; &#125;&#125;; 分治：$\\mathcal{O}(nlogn)$ 1234567891011121314151617class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; return find(nums, 0, nums.size()-1); &#125; int find(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l == r) return nums[l]; int m = (l + r) / 2; int lans = find(nums, l, m), rans = find(nums, m+1, r); int lcnt = 0, rcnt = 0; for (int i = l; i &lt;= r; ++i) &#123; if (nums[i] == lans) lcnt++; if (nums[i] == rans) rcnt++; &#125; return lcnt &gt; rcnt ? lans : rans; &#125;&#125;; 位运算：$\\mathcal{O}(n)$ 123456789101112class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int ans = 0, mask = 1, times = nums.size() / 2; for (int i = 0; i &lt; 32; ++i, mask &lt;&lt;= 1) &#123; // 枚举二进制位 int bitCount = 0; for (int&amp; x: nums) if (x &amp; mask) bitCount++; if (bitCount &gt; times) ans |= mask; &#125; return ans; &#125;&#125;; Moore Voting Algorithm：$\\mathcal{O}(n)$ 1234567891011class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int ans = 0, cnt = 0; for (int&amp; x: nums) &#123; if (!cnt) cnt++, ans = x; // 若没有候选答案，则把当前这个数作为候选答案 else ans == x ? cnt++ : cnt--; // 比较当前的数和候选答案是否相等，不相等则消掉 &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"},{"name":"分治","slug":"分治","permalink":"https://orzyt.cn/tags/分治/"}]},{"title":"LeetCode171 Excel Sheet Column Number","slug":"leetcode171-excel-sheet-column-number","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.474Z","comments":true,"path":"posts/leetcode171-excel-sheet-column-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode171-excel-sheet-column-number/","excerpt":"","text":"描述Given a column title as appear in an Excel sheet, return its corresponding column number. 样例1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 思路给出excel表头相应的数字。 水题…二十六进制的转换。 代码12345678class Solution &#123;public: int titleToNumber(string s) &#123; long long ans = 0; for (char c: s) ans = ans * 26 + c - 'A' + 1; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode237 Delete Node in a Linked List","slug":"leetcode237-delete-node-in-a-linked-list","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.078Z","comments":true,"path":"posts/leetcode237-delete-node-in-a-linked-list/","link":"","permalink":"https://orzyt.cn/posts/leetcode237-delete-node-in-a-linked-list/","excerpt":"","text":"描述Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. 样例123Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 思路删除链表中某个指定的结点。 一个显然的做法就是拿后继node-&gt;next去覆盖当前这个node结点。 好了，代码就一行node = node-&gt;next，但submit后WA了…orz 其实这样写虽然是将指向node的指针指向了其后继结点，但是node前驱的后继指针却没有改变，因此实际上链表根本就没有被改变。 正确的写法应该是去更改内容，而不是更改指针。即*node = *(node-&gt;next) 代码1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; *node = *(node-&gt;next) &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://orzyt.cn/tags/链表/"}]},{"title":"LeetCode258 Add Digits","slug":"leetcode258-add-digits","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.414Z","comments":true,"path":"posts/leetcode258-add-digits/","link":"","permalink":"https://orzyt.cn/posts/leetcode258-add-digits/","excerpt":"","text":"描述Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Follow up:Could you do it without any loop/recursion in O(1) runtime? 样例12Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 思路给一个非负数，每次将其替换为它的各位数字之和，直到为这个数只有一位为止。(其实就是求一个数的digital root) 直接模拟显然是可以的，那么考虑如何$\\mathcal{O}(1)$算出答案。 对任意一个数 $n$ 来说，可以将其表示为 $n = a_{n-1} \\ast 10^{n-1} + a_{n-2} \\ast 10^{n-2} + … a_{1} \\ast 10^{1} + a_{0} \\ast 10^{0}$ 同时注意到，10的任意次方模9都为1，则 $ n \\equiv a_{n-1} \\ast 1 + a_{n-2} \\ast 1 + … a_{1} \\ast 1 + a_{0} \\ast 1 (mod 9) $ 右边就是$n$的各位数之和，然后把它赋给$n$不断迭代即可。 结论： 代码12345678class Solution &#123;public: int addDigits(int num) &#123; if (num == 0) return 0; int ans = num % 9; return ans ? ans : 9; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode242 Valid Anagram","slug":"leetcode242-valid-anagram","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.238Z","comments":true,"path":"posts/leetcode242-valid-anagram/","link":"","permalink":"https://orzyt.cn/posts/leetcode242-valid-anagram/","excerpt":"","text":"描述Given two strings s and t, write a function to determine if t is an anagram of s. Note:You may assume the string contains only lowercase alphabets. 样例12s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.s = &quot;rat&quot;, t = &quot;car&quot;, return false. 思路判断两个字符串是否“相等”（即字符的顺序不重要，只需比较每个字符的个数）。 模拟，用cnt数组记录每个字符的个数，比较下即可。 代码12345678910111213class Solution &#123;public: bool isAnagram(string s, string t) &#123; int cnt1[26] = &#123;0&#125;; int cnt2[26] = &#123;0&#125;; for (char c: s) cnt1[c-'a']++; for (char c: t) cnt2[c-'a']++; for (int i = 0; i &lt; 26; ++i) &#123; if (cnt1[i] != cnt2[i]) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"},{"name":"排序","slug":"排序","permalink":"https://orzyt.cn/tags/排序/"}]},{"title":"LeetCode387 First Unique Character in a String","slug":"leetcode387-first-unique-character-in-a-string","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.210Z","comments":true,"path":"posts/leetcode387-first-unique-character-in-a-string/","link":"","permalink":"https://orzyt.cn/posts/leetcode387-first-unique-character-in-a-string/","excerpt":"","text":"描述Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. 样例12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. 思路找出在字符串中只出现过一次的字符的下标。 水题…统计一遍即可。 代码123456789101112131415class Solution &#123;public: int firstUniqChar(string s) &#123; int cnt[26] = &#123;0&#125;, i = 0, ans = -1; for (char c: s) cnt[c-'a']++; for (char c: s) &#123; if (cnt[c-'a'] == 1) &#123; ans = i; break; &#125; i++; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode404 Sum of Left Leaves","slug":"leetcode404-sum-of-left-leaves","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.014Z","comments":true,"path":"posts/leetcode404-sum-of-left-leaves/","link":"","permalink":"https://orzyt.cn/posts/leetcode404-sum-of-left-leaves/","excerpt":"","text":"描述Find the sum of all left leaves in a given binary tree. 样例1234567 3 / \\ 9 20 / \\ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 思路给一颗二叉树，求所有左叶子节点的和。 首先叶子节点比较好判断，只要知道它的左右儿子是否都为空即可。 由于函数的参数只传了该节点的信息进去，没有传入该节点是父节点的左儿子还是右儿子等信息，所以难点主要在于怎么判断一个节点是否是左叶子节点。 针对这一点，我们必须提前到父节点进行判断。 父节点只需对其左儿子进行判断，如果这个左儿子是叶子节点，则该左儿子就对答案有贡献。 代码1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; int ans = 0; if (root-&gt;left != NULL) &#123; // 左儿子不为空 // 左儿子为叶子节点 if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) ans += root-&gt;left-&gt;val; else ans += sumOfLeftLeaves(root-&gt;left); &#125; ans += sumOfLeftLeaves(root-&gt;right); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"}]},{"title":"LeetCode453 Minimum Moves to Equal Array Elements","slug":"leetcode453-minimum-moves-to-equal-array-elements","date":"2017-01-27T16:00:00.000Z","updated":"2019-02-08T10:26:00.210Z","comments":true,"path":"posts/leetcode453-minimum-moves-to-equal-array-elements/","link":"","permalink":"https://orzyt.cn/posts/leetcode453-minimum-moves-to-equal-array-elements/","excerpt":"","text":"描述Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. 样例12345678910Input:[1,2,3]Output:3Explanation:Only three moves are needed (remember each move increments two elements):[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 思路给一个非空数组，每操作一次可以给其中$n-1$个数加1，问至少要操作多少次可以让数组中每个数都相等。 （这是easy分类的题目，但是感觉身体被掏空，写了几次都WA了… 其实这题从反面来看比较好考虑，每次让$n-1$个数加1，其实等价于让一个数减1。所以问题就等价于每次让一个数减1，问要经过多少次后能让所有数相等。答案即为$sum - n * minMum$。（也就是所有数都减到最小的那个数为止） 代码123456789101112class Solution &#123;public: int minMoves(vector&lt;int&gt;&amp; nums) &#123; long long sum = 0; int minNum = INT_MAX; for (int&amp; x: nums) &#123; sum += x; minNum = min(minNum, x); &#125; return sum - nums.size() * minNum; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode349 Intersection of Two Arrays","slug":"leetcode349-intersection-of-two-arrays","date":"2017-01-25T16:00:00.000Z","updated":"2019-02-08T10:26:00.094Z","comments":true,"path":"posts/leetcode349-intersection-of-two-arrays/","link":"","permalink":"https://orzyt.cn/posts/leetcode349-intersection-of-two-arrays/","excerpt":"","text":"描述Given two arrays, write a function to compute their intersection. Note: Each element in the result must be unique. The result can be in any order. 样例1Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. 思路求两个数组的交集。注意答案中不能有重复的元素。 二分：先对nums1排序，然后遍历nums2中每个元素，对每个元素用二分查找是否存在于nums1中，去重可用map维护。 双指针：对nums1和nums2都排序，当双指针指向相同的数时加到答案里即可。 代码二分：12345678910111213141516class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); map&lt;int, bool&gt; hashTable; vector&lt;int&gt; ans; for (auto x: nums2) &#123; auto iter = lower_bound(nums1.begin(), nums1.end(), x); if (iter != nums1.end() &amp;&amp; *iter == x &amp;&amp; !hashTable.count(x)) &#123; ans.push_back(x); hashTable[x] = true; &#125; &#125; return ans; &#125;&#125;; 双指针：123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); map&lt;int, bool&gt; hashTable; vector&lt;int&gt; ans; int n = nums1.size(), m = nums2.size(), i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (nums1[i] &lt; nums2[j]) i++; else if (nums1[i] &gt; nums2[j]) j++; else &#123; if (!hashTable.count(nums1[i])) ans.push_back(nums1[i]); hashTable[nums1[i]] = true; i++; j++; &#125; &#125; return ans; &#125;&#125;; 优雅的实现：123456789class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; s(nums1.begin(), nums1.end()); vector&lt;int&gt; ans; for (auto x: nums2) if (s.erase(x)) ans.push_back(x); return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"},{"name":"二分","slug":"二分","permalink":"https://orzyt.cn/tags/二分/"},{"name":"排序","slug":"排序","permalink":"https://orzyt.cn/tags/排序/"}]},{"title":"LeetCode383 Ransom Note","slug":"leetcode383-ransom-note","date":"2017-01-25T16:00:00.000Z","updated":"2019-02-08T10:26:00.278Z","comments":true,"path":"posts/leetcode383-ransom-note/","link":"","permalink":"https://orzyt.cn/posts/leetcode383-ransom-note/","excerpt":"","text":"描述Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. 样例123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 思路给两个字符串，在第二个串中每个字母只能使用一次的情况下，问能否构造得到第一个串。 首先遍历第二个串，得到每个字母的个数，然后再遍历第一个串，看对应字母的个数是否足够即可。 代码1234567891011class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; int cnt[26] = &#123;0&#125;; for (auto&amp; ch: magazine) cnt[ch-'a']++; for (auto&amp; ch: ransomNote) &#123; if (--cnt[ch-'a'] &lt; 0) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"Coursera Machine Learning 一元线性回归和梯度下降","slug":"coursera-linear-regression-with-one-variable-and-gradient-descent","date":"2017-01-20T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/coursera-linear-regression-with-one-variable-and-gradient-descent/","link":"","permalink":"https://orzyt.cn/posts/coursera-linear-regression-with-one-variable-and-gradient-descent/","excerpt":"监督学习有监督学习，即从标签化的数据中进行训练学习。 In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.","text":"监督学习有监督学习，即从标签化的数据中进行训练学习。 In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output. 回归 (Regression)预测的值一般为连续的 分类 (Classification)预测的值一般为离散的 无监督学习无监督学习，即数据中不含有标签，一般用于聚类，相似的数据将聚合形成一个个的簇。 Unsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables. 聚类 (clustering) 模型表示 $x$ : 输入 $y$ : 输出 $m$ : 训练集大小 $(x^{(i)}, y^{(i)})$ : 训练集中第$i$个数据 $function \\ h:\\ X → Y$ : 预测的函数，也叫hypothesis 损失函数损失函数，用来评价模型的预测值与真实值的不一致程度，它是一个非负实值函数。损失函数越小，模型的性能就越好。 Squared error function： J(\\theta_0, \\theta_1) = \\dfrac {1}{2m} \\displaystyle \\sum _{i=1}^m \\left ( \\hat{y}_{i}- y_{i} \\right)^2 = \\dfrac {1}{2m} \\displaystyle \\sum _{i=1}^m \\left (h_\\theta (x_{i}) - y_{i} \\right)^2除以$m$可以排除训练集大小带来的影响，除以2是方便后面梯度下降求导数时约掉! 特别需要注意的是，下面右边的叫轮廓图，在同一个”圆圈”上的参数，其$J$值是一样的！ 梯度下降梯度下降，用来求解满足Goal的参数$\\theta_0$, $\\theta_1$ $\\alpha$ (learning rate): 学习率，过小会导致下降太慢，过大可能导致结果不收敛 算法中$\\theta_0$, $\\theta_1$需要同时更新！ 特别的，对于一元线性回归模型，有 \\begin{align*} \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}\\left((h_\\theta(x_{i}) - y_{i}) x_{i}\\right) \\end{align*}而且对于线性模型的$J$函数，它的形状类似“碗状”，只有全局最小值，因此从任意一点开始，梯度下降算法一定能够找到全局最小值！","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://orzyt.cn/tags/机器学习/"}]},{"title":"LeetCode338 Counting Bits","slug":"leetcode338-counting-bits","date":"2017-01-20T16:00:00.000Z","updated":"2019-02-08T10:26:00.182Z","comments":true,"path":"posts/leetcode338-counting-bits/","link":"","permalink":"https://orzyt.cn/posts/leetcode338-counting-bits/","excerpt":"","text":"描述Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 样例1For num = 5 you should return [0,1,1,2,1,2]. 思路求 0~n 这n+1个数，每个数的二进制表示中1的个数是多少。 首先我们来考虑，一个数的二进制表示中1的个数要怎么求 直接遍历每个二进制位： 1for (int i = 0; i &lt; 32; ++i) ans += (n &gt;&gt; i) &amp; 1; 有多少个1就遍历多少次（通过lowbit跳转）： 12int lowbit(int n) &#123; return n&amp;-n; &#125;for (; n &gt; 0; n -= lowbit(n)) ans++; 首先来说下lowbit的作用，这个是用来求一个数的二进制表示中最右边的那个“1”。举个例子比较直观，比如123n -&gt; 0000 0000 1010 1100 ↑lowbit(n) -&gt; 0000 0000 0000 0100 那么 为什么 n\\&-n 能求出lowbit呢？（注意到计算机内部以补码表示数） 假设n的第0~i位全为0，那么最右边的“1”即为第i+1位，形如 123xxxx xxxx xxx1 0000 （x可为0或1） ↑ 第i+1位 取反后则形如 (假设x取反后变为y) 123yyyy yyyy yyy0 1111 ↑ 第i+1位 再加1后则形如 123yyyy yyyy yyy1 0000 ↑ 第i+1位 两个相与（&amp;）后则求出最右边的“1” 1234 xxxx xxxx xxx1 0000 (前面提到x取反后为y，即 x &amp; y = 0)&amp; yyyy yyyy yyy1 0000--------------------- 0000 0000 0001 0000 举个例子，比如123n -&gt; 0000 0000 1010 1100-n -&gt; 1111 1111 0101 0100 (各二进制位取反再加1)n&amp;-n -&gt; 0000 0000 0000 0100 了解了lowbit之后，再来看下for (; n &gt; 0; n -= lowbit(n)) ans++;这句为什么能求出n中所有的1。不难发现，n每次减掉lowbit等价于把n最右边的那个“1”去掉。因此，循环执行这个操作的次数即为n中1的个数。 最后，推荐大家参阅 算法-求二进制数中1的个数，这篇博客囊括了几乎所有这方面的算法~ 上面提到的两个做法，复杂度近似O(nlogn)，那么如何优化到O(n)呢？不妨考虑lowbit那个做法的思路，n中1的个数等价于n - lowbit(n)这个数中1的个数再加1。至此，我们可以用动态规划的方法来递推出答案！ dp[i] = \\left\\{\\begin{matrix} 0 \\; & \\text{if i = 0}\\\\ dp[n - lowbit(n)] + 1 \\; & \\text{others}\\ \\end{matrix}\\right.代码做法一：12345678910111213class Solution &#123;public: int cal(int n) &#123; int ans = 0; for (; n; n -= n&amp;-n, ans++); return ans; &#125; vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; vec; for (int i = 0; i &lt;= num; ++i) vec.push_back(cal(i)); return vec; &#125;&#125;; 做法二：12345678class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; dp(num + 1, 0); for (int i = 1; i &lt;= num; ++i) dp[i] = dp[i-(i&amp;-i)] + 1; return dp; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"https://orzyt.cn/tags/DP/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode419 Battleships in a Board","slug":"leetcode419-battleships-in-a-board","date":"2017-01-20T16:00:00.000Z","updated":"2019-02-08T10:26:00.290Z","comments":true,"path":"posts/leetcode419-battleships-in-a-board/","link":"","permalink":"https://orzyt.cn/posts/leetcode419-battleships-in-a-board/","excerpt":"","text":"描述Given an 2D board, count how many different battleships are in it. The battleships are represented with &#39;X&#39;s, empty slots are represented with &#39;.&#39;s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships. 样例123X..X...X...X In the above board there are 2 battleships. Invalid Example: 123...XXXXX...X This is an invalid board that you will not receive - as battleships will always have a cell separating between them. Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? 思路给一个n*m的棋盘，上面有一些N×1或者是1×N的战舰（N可以为任意数，只要非零且不超过棋盘大小），其中任意两个战舰之间有一个空方块隔开，问有多少艘战舰。 这题直观的想法是求有多少个连通分量，dfs一下即可。但是这没用到”N×1或者是1×N”这个性质，思考之后发现，其实只需判断一个 ‘X’ 的左边或者是上边是否也有 ‘X’ 即可，若没有，这就说明这个 X 是属于一个新的战舰，答案加1。扫一遍棋盘即可，不用额外的数组，也不需要修改棋盘（dfs的做法则需要）。 代码DFS版：1234567891011121314151617181920212223242526272829class Solution &#123;public: int r, c; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123; board[x][y] = '.'; int dir[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int k = 0; k &lt; 4; ++k) &#123; int nx = x + dir[k][0], ny = y + dir[k][1]; if (nx &lt; 0 || nx &gt;= r || ny &lt; 0 || ny &gt;= c || board[nx][ny] == '.') continue; dfs(board, nx, ny); &#125; &#125; int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int ans = 0; r = board.size(); c = board[0].size(); for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; if (board[i][j] == 'X') &#123; dfs(board, i, j); ans++; &#125; &#125; &#125; return ans; &#125;&#125;; 扫一遍即可：12345678910111213141516class Solution &#123;public: int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int r = board.size(), c = board[0].size(); int ans = 0; for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; if (board[i][j] == 'X') &#123; if ((i - 1 &lt; 0 || i - 1 &gt;= 0 &amp;&amp; board[i - 1][j] != 'X') &amp;&amp; (j - 1 &lt; 0 || j - 1 &gt;= 0 &amp;&amp; board[i][j - 1] != 'X')) ans++; &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode104 Maximum Depth of Binary Tree","slug":"leetcode104-maximum-depth-of-binary-tree","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.486Z","comments":true,"path":"posts/leetcode104-maximum-depth-of-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode104-maximum-depth-of-binary-tree/","excerpt":"","text":"描述Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 样例123456789Input: 1 / \\ 2 3 / \\ 4 5Output：3 思路求二叉树的最大深度。 dfs遍历一遍即可，当前最大深度为左右子树深度的最大值加1！ 代码12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; else return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode136 Single Number","slug":"leetcode136-single-number","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.458Z","comments":true,"path":"posts/leetcode136-single-number/","link":"","permalink":"https://orzyt.cn/posts/leetcode136-single-number/","excerpt":"","text":"描述Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 样例12Input: [1, 2, 3, 1, 2]Output: 3 思路给一个数组，其中只有一个数出现一次，其余数字都出现两次。现在要找出只出现过一次的那个数字是多少。 考虑异或运算的性质：两个相同的数异或为0 以及 异或满足交换律 那么我们只要对数组求个异或和 ans = a_1 \\bigoplus a_2 \\bigoplus ... \\bigoplus a_n 由于出现两次的数字都异或掉了，所以最后剩下的即为答案。 代码12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto&amp; x : nums) &#123; ans ^= x; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode226 Invert Binary Tree","slug":"leetcode226-invert-binary-tree","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.358Z","comments":true,"path":"posts/leetcode226-invert-binary-tree/","link":"","permalink":"https://orzyt.cn/posts/leetcode226-invert-binary-tree/","excerpt":"","text":"描述Invert a binary tree. 样例1234567891011121314Input： 4 / \\ 2 7 / \\ / \\1 3 6 9Output： 4 / \\ 7 2 / \\ / \\9 6 3 1 思路翻转一棵二叉树。 dfs即可，每次swap左右子树。 代码12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if (root == NULL) return NULL; swap(root-&gt;left, root-&gt;right); invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"树","slug":"树","permalink":"https://orzyt.cn/tags/树/"},{"name":"DFS","slug":"DFS","permalink":"https://orzyt.cn/tags/DFS/"}]},{"title":"LeetCode283 Move Zeroes","slug":"leetcode283-move-zeroes","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.170Z","comments":true,"path":"posts/leetcode283-move-zeroes/","link":"","permalink":"https://orzyt.cn/posts/leetcode283-move-zeroes/","excerpt":"","text":"描述Given an array nums, write a function to move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 样例12For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. 思路给一个数组，现在要把所有0都移到数组的末尾，其他非零数字的相对顺序不能改变。 考虑双指针，令l为答案数组的指针，r为原数组的指针。r在移动到一个非零的数时，把它和l指向的位置的元素进行交换。 为什么可以交换呢？因为此时l指向的位置的元素只有两种情况，要么nums[l] == nums[r] (或者说是l == r) 要么 nums[l] == 0。因此交换之后就相当于把0往后移了。 代码12345678910class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(), l = 0, r = 0; while (r &lt; size) &#123; if (nums[r]) swap(nums[l++], nums[r]); r++; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"}]},{"title":"LeetCode292 Nim Game","slug":"leetcode292-nim-game","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.186Z","comments":true,"path":"posts/leetcode292-nim-game/","link":"","permalink":"https://orzyt.cn/posts/leetcode292-nim-game/","excerpt":"","text":"描述You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. 样例123For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed byyour friend. 思路给一堆石子，然后两个人轮流从堆中取走1-3个，规定取走最后一个石子的人获胜。现在给定石子的个数，问先手能否获胜。 典型的尼姆游戏，用SG函数打个表找找规律即可。可以发现当石子个数为4的倍数时，其SG函数值为0，此时先手必败。 关于NIM游戏和SG函数，可以参阅：博弈之 Nim 游戏和 sg 函数 代码123456class Solution &#123;public: bool canWinNim(int n) &#123; return n % 4; &#125;&#125;; 打表程序： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int sg[105];int getSG(int x) &#123; if (sg[x] &gt;= 0) return sg[x]; else if (x &lt;= 0) return 0; set&lt;int&gt; s; for (int i = 1; i &lt;= 3; ++i) s.insert(getSG(x - i)); for (int i = 0; ; ++i) if (!s.count(i)) return sg[x] = i;&#125;void solve() &#123; memset(sg, -1, sizeof(sg)); for (int i = 0; i &lt; 100; ++i) cout &lt;&lt; \"sg[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; getSG(i) &lt;&lt; endl;&#125;int main() &#123; solve();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"博弈论","slug":"博弈论","permalink":"https://orzyt.cn/tags/博弈论/"},{"name":"SG函数","slug":"SG函数","permalink":"https://orzyt.cn/tags/SG函数/"}]},{"title":"LeetCode371 Sum of Two Integers","slug":"leetcode371-sum-of-two-integers","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.146Z","comments":true,"path":"posts/leetcode371-sum-of-two-integers/","link":"","permalink":"https://orzyt.cn/posts/leetcode371-sum-of-two-integers/","excerpt":"","text":"描述Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. 样例1Given a = 1 and b = 2, return 3. 思路在不使用+ 和 -的情况下，求a+b。 回顾一下数逻里的加法器 其中 s_i = a_i \\bigoplus b_ic_i = a_i \\& b_i那么我们只要模拟这个过程就可实现加法运算啦！ a ^ b : 不进位求和 (a &amp; b) &lt;&lt; 1 : 把进位通过左移加到高位 递归这一过程，直到没有进位为止。 比如 a = 3, b = 5： 1234567891011121314151617181920212223242526272829第一次迭代：a -&gt; 0000 0000 0000 0011b -&gt; 0000 0000 0000 0101a ^ b -&gt; 0000 0000 0000 0110(a &amp; b) &lt;&lt; 1 -&gt; 0000 0000 0000 0010第二次迭代：a -&gt; 0000 0000 0000 0110b -&gt; 0000 0000 0000 0010a ^ b -&gt; 0000 0000 0000 0100(a &amp; b) &lt;&lt; 1 -&gt; 0000 0000 0000 0100第三次迭代：a -&gt; 0000 0000 0000 0100b -&gt; 0000 0000 0000 0100a ^ b -&gt; 0000 0000 0000 0000(a &amp; b) &lt;&lt; 1 -&gt; 0000 0000 0000 1000第四次迭代:a -&gt; 0000 0000 0000 0000b -&gt; 0000 0000 0000 1000a ^ b -&gt; 0000 0000 0000 1000(a &amp; b) &lt;&lt; 1 -&gt; 0000 0000 0000 0000第五次迭代:a -&gt; 0000 0000 0000 1000b -&gt; 0000 0000 0000 0000此时b为0，返回答案a=8 由于数字在计算机内部以补码形式表示，有 [X＋Y]补 = [X]补＋[Y]补 ，所以上述思路对于负数也适用。 代码123456class Solution &#123;public: int getSum(int a, int b) &#123; return b ? getSum(a ^ b, (a &amp; b) &lt;&lt; 1) : a; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode389 Find the Difference","slug":"leetcode389-find-the-difference","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.238Z","comments":true,"path":"posts/leetcode389-find-the-difference/","link":"","permalink":"https://orzyt.cn/posts/leetcode389-find-the-difference/","excerpt":"","text":"描述Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. 样例123456789Input:s = &quot;abcd&quot;t = &quot;abcde&quot;Output:eExplanation:&apos;e&apos; is the letter that was added. 思路给两个只含小写字母的字符串s和t，其中串t为串s打乱之后的某一排列，同时在某一随机位置新增一个字符。现在要找到这一新增的字符。 一个直观的想法是开一个数组记录s中每个字母出现的次数，然后再开一个数组也记录t中每个字母出现的次数，然后比较一下哪个字母的个数不一样，即为新增的字符。 如果之前做过LeetCode136 Single Number这道题的话，那么另一个想法就是考虑能不能把字符串也进行异或呢，剩下的不就是那个“Single Char”了吗？显然是可以的！ 代码123456789101112131415161718class Solution &#123;public: char findTheDifference(string s, string t) &#123; int cnt1[26] = &#123;0&#125;; int cnt2[26] = &#123;0&#125;; int size = s.size(); for (int i = 0; i &lt; size; ++i) &#123; cnt1[s[i] - 'a']++; cnt2[t[i] - 'a']++; &#125; cnt2[t[size] - 'a']++; for (int i = 0; i &lt; 26; ++i) &#123; if (cnt1[i] != cnt2[i]) &#123; return char(i + 'a'); &#125; &#125; &#125;&#125;; 1234567891011class Solution &#123;public: char findTheDifference(string s, string t) &#123; int size = s.size(); char ch = t[size]; for (int i = 0; i &lt; size; ++i) &#123; ch ^= s[i] ^ t[i]; &#125; return ch; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode455 Assign Cookies","slug":"leetcode455-assign-cookies","date":"2017-01-18T16:00:00.000Z","updated":"2019-02-08T10:26:00.162Z","comments":true,"path":"posts/leetcode455-assign-cookies/","link":"","permalink":"https://orzyt.cn/posts/leetcode455-assign-cookies/","excerpt":"","text":"描述Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note:You may assume the greed factor is always positive.You cannot assign more than one cookie to one child. 样例Example 1:123456789Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. Example 2: 12345678Input: [1,2], [1,2,3]Output: 2Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. 思路有n个小朋友和m块饼干，第i个小朋友至少要g[i]大小的饼干，而第i块饼干大小为s[i]，每个小朋友只能分到一块饼干，问分掉这些饼干最多能让多少个小朋友满意。 先把小朋友的需求以及饼干的大小按递增排个序。基于贪心的思想，饼干能早分掉就尽早分掉，在排完序后，如果第j块饼能满足第i个小朋友，那么肯定也能满足前i-1个小朋友，因此把饼干早分掉不会使结果变得更差。（早分掉的意思是一旦当前饼干能满足当前小朋友的需求，就分给他，而不必把饼干留到后面分） 代码12345678910111213class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int p1 = 0, p2= 0, ans = 0; while (p1 &lt; g.size() &amp;&amp; p2 &lt; s.size()) &#123; if (g[p1] &lt;= s[p2]) p1++, ans++; p2++; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"贪心","slug":"贪心","permalink":"https://orzyt.cn/tags/贪心/"},{"name":"双指针","slug":"双指针","permalink":"https://orzyt.cn/tags/双指针/"}]},{"title":"构建之法读书笔记","slug":"learning-by-doing-notes","date":"2017-01-18T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/learning-by-doing-notes/","link":"","permalink":"https://orzyt.cn/posts/learning-by-doing-notes/","excerpt":"前言 早在10月份还在上软工实践课的时候，就立了一个Flag说要读完《构建之法》。可惜当时并没有完整地将书读过一遍，而是在实践中要用什么内容就读什么内容。后来等有时间通读过一遍后，却没有记录成博客，等到邹欣老师给我留言的时候已临近期末，再加上自己的拖延症，导致该文静静地躺在草稿箱中不见天日。（这么看来，deadline真的是第一生产力…","text":"前言 早在10月份还在上软工实践课的时候，就立了一个Flag说要读完《构建之法》。可惜当时并没有完整地将书读过一遍，而是在实践中要用什么内容就读什么内容。后来等有时间通读过一遍后，却没有记录成博客，等到邹欣老师给我留言的时候已临近期末，再加上自己的拖延症，导致该文静静地躺在草稿箱中不见天日。（这么看来，deadline真的是第一生产力… 初步印象 软件工程，一开始给我的体会就如同书中二柱说的那样，”软件工程讲的净是一些奇妙玄幻的概念，拗口的专业名词加上纷繁复杂的流程，其实做软件完全没有那么难，主要靠的还是程序员自身的修养和完成工作的素质“。（摘自7.7节 练习与讨论）面对课内教材动辄二十几章的内容（还是经过改编的本科教学版），如果不是为了考试，实在是没多大兴趣翻下去。好在，栋哥在课程伊始给了一些参考书籍，其中有一本叫《构建之法——现代软件工程》，翻阅了几页之后，给我的第一印象是生动有趣，接地气！ 在开篇，作者提到了“程序 = 数据结构 + 算法”这个广为人（程序员）知的名言，我由于常敲算法题，对此深以为然。我一直以为软件和程序之间差别应该不大，所以才会有二柱那样的体会。但是后来作者通过移山公司程序员阿超的例子展现了软件和程序的区别，提出“软件 = 程序 +软件工程”这一推论。这让我对软件的认识发生了深刻的改变，会写算法和数据结构、会写能跑的程序只能算是自己的一项基本功，在此基础上，软件工程这门学问才是真正决定了软件的质量和命运。不得不说，概论部分介绍的方方面面，让我第一次对软工有一个全景式的直观感受。 虽然软件工程涉及的面非常的广，但是作者还是尽可能的囊括了软工的方方面面。“全书对软件工程内容的覆盖不逊于任何一本现行的教材”，确实，从目录中便可窥知一二。不仅包括从软件工程师的成长、团队流程、敏捷开发到项目经理、用户体验、测试发布这些软件工程的核心内容，最后还包括了IT创新和职业道德等内容，因此覆盖面广也是书中一大特点。 全书始终贯穿着情景式、对话式的对白，作者善于将一些晦涩难懂的概念透过人物生动形象、幽默有趣的对白展现出来，可谓是深入浅出。这可能跟邹老师曾投身于教学一线有关，才会了解学生在学习软工课时的痛点。在阅读对话的时候，自己也会不知不觉地融入其中，仿佛也在着参与这场讨论。在第七章讲到MSF（Microsoft Solution Framework，微软解决方案框架）时，其中有许许多多的对话内容，这对于我们这种一点都没接触过MSF的同学理解它的思想有很大的帮助。试想，如果一上来就长篇大论各种虚无缥缈的概念，第一是什么第二是什么balabala…，我想很多人是没多大兴趣看下去。即使勉强看下去，没有实际软件开发经验的学生也会看的一头雾水，到头来也还是什么也不知道。 邹老师始终强调 Learning by Doing，做中学的模式，这也是他自己在教学实践过程中总结出来的。因此，书中不仅仅流于概念和方法论的介绍，还十分注重实践过程，对于大部分内容都会配合很多的思考与练习，同时也会提供相关的评价指标。毕竟，软工如果只有理论没有实践，也就失去这门课的意义了。周筠老师在知乎专栏文章 他们说我们永远做不到，然而我们有『做中学』（Learning by doing）——来吧，IT小小鸟 里也举了一些具体的例子，说明了将该模式与软工实践结合的益处。不得不说，栋哥采用“做中学”来指导我们的软工实践课是一个正确的选择，选修了这次的软工实践课可谓是受益匪浅！ 付诸实践 在软工实践课上，也曾布置过多次博客作业（需求分析与原型设计，毕设导师智能匹配，软件产品案例分析），通过阅读书中相关内容后将其付诸于实践。其中，前两次是结对编程项目，需要和同伴一起完成。书中提到，结对编程中有两个角色：驾驶员和领航员，一个负责具体的执行，另一个负责导航、检查、护航。在实践当中也确实如此，一个人掌控键盘编写程序，一个在旁边指出程序中的错误，这在一定程度上确实能够提高代码的质量。书中为结对编程提供了“方法论”，讲述了如何进行结对编程以及两人合作的技巧等。其中给我留下深刻印象的是4.6.2小节—如何正确地给予反馈，作者将反馈分为最外层（行为和后果）、中间层（习惯和动机）和最内层（本质和固有属性），不同层次的反馈给人不同的感受。如果将反馈上升到最内层，说不定两人合作将从磨合阶段直接到解体阶段… 感谢当时的结对同伴，在结对编程的时候我们能够进行有效的交流反馈，顺利地完成任务！在结对编程的同时，我们还学习了解了PSP（Personal Software Process，个人开发流程），并估计了完成结对编程项目所需的耗时。 在软件产品案例分析中，我们不仅要充当实际用户、还要充当测试人员甚至是项目经理。这个难度看起来有点高，要一人分饰多角。其实在软件开发过程中，也常常需要这种换位思考。在进行需求分析时，书中提供了一个竞争性需求分析框架—NABCD模型，这一模型被多次用于我们的实践课程作业中。第12章用户体验中举了飞机中的遥控器等例子，强调了用户体验设计的一个重要目标就是要降低用户的认知阻力，也就是我们常说的“这款软件上手快不快”。因此在软件产品案例分析中，用户体验部分也作为我评测的一大重点。评测部分还有一项内容是“估计这个项目做到这个程度大约需要多少时间”，书中也举了一个“徒步遍历中国陆地边界”的例子，同学们给出了从50天到不可能的各种答案。除了盲目的估计，其实也有一套有章可循的项目估计的经验公式：Y = X ± X ÷ N。 在团队开发中，我们团队经历了萌芽、磨合、规范和创造阶段。当然，我们不会像王屋村“搬砖团队”那样，临时聚在一起，各自完成任务就走人，没有一个集体的目标。虽然我们组内经常戏称各种抱大腿，如下图所示。 但是我觉得，我们倒像是属于功能团队模式，大家都平等地相互协作鼓励，为了完成一个共同的目标而努力（脑海中又回想起了一次次的Scrum每日冲刺，一次次的约活动室敲代码、alpha版本发布前的通宵和发布后的事后诸葛亮会议、两次版本发布的答辩以及去教学办展示后又改需求的无奈… ）现在回想起来那几个月的历程，也算是一段难忘的经历吧。 个人建议其实吧，自己作为一名学生也没有什么实际软件开发经验，也谈不上提什么建议，所以下述内容可能也有不对的地方，还请各位批评指正。 书中的注释都放在每一章的最后，感觉翻起来不太方便，直接附在相关页的下方会不会更好？ 本书有较多的超链接，虽然封面提供了整合链接的二维码，但是有的时候读者可能仅仅对某一注释中的链接感兴趣，所以希望能够提供短链接 2.1.1小节 用VSTS写单元测试，这边给的例子是用C#编写的，但是大多数同学应该没有C#编程经验，所以建议可以更换成同学们比较熟悉的语言，如C++等。这样也可以跟第四章中关于代码规范方面用C++举例相对应起来 第七章用了一个章节讲了微软解决方案框架，如果说本书的定位是面向高校的软工教材的话，我觉得可以不用这么多篇幅，MSF这部分可能更适合作为补充延伸的阅读材料 希望能够有一个完整的项目贯穿全书始终，比如像《软件工程—实践者的研究方法》这本书中的“SafeHome”安全住宅项目，这样可能使读者更好地把各部分内容串在一起理解，融会贯通 索引部分的条目可以稍微精简一些，更加突出重点","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/categories/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/tags/软件工程/"}]},{"title":"LeetCode344 Reverse String","slug":"leetcode344-reverse-string","date":"2017-01-15T16:00:00.000Z","updated":"2019-02-08T10:26:00.034Z","comments":true,"path":"posts/leetcode344-reverse-string/","link":"","permalink":"https://orzyt.cn/posts/leetcode344-reverse-string/","excerpt":"","text":"描述Write a function that takes a string as input and returns the string reversed. 样例1Given s = &quot;hello&quot;, return &quot;olleh&quot;. 思路输出一个串的翻转串。 C++自带reverse函数，一行代码的事… 或者直接for循环到长度的一半，交换s[i]和s[size-1-i]即可。 代码1234567class Solution &#123;public: string reverseString(string s) &#123; reverse(s.begin(), s.end()); return s; &#125;&#125;; 12345678class Solution &#123;public: string reverseString(string s) &#123; int size = s.size(); for (int i = 0; i &lt; size / 2; ++i) swap(s[i], s[size-1-i]); return s; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"}]},{"title":"LeetCode412 Fizz Buzz","slug":"leetcode412-fizz-buzz","date":"2017-01-15T16:00:00.000Z","updated":"2019-02-08T10:26:00.186Z","comments":true,"path":"posts/leetcode412-fizz-buzz/","link":"","permalink":"https://orzyt.cn/posts/leetcode412-fizz-buzz/","excerpt":"","text":"描述Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. 样例1234567891011121314151617181920n = 15,Return:[ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot;] 思路找出 1 ~ n 中3的倍数、5的倍数以及15的倍数。对于3的倍数输出 “Fizz” ，5的倍数输出 “Buzz” ，15的倍数输出 “FizzBuzz” ，其余的输出对应的数字。 简单模拟，但是C++好像没有提供 int 转 string 的函数，还得自己动手写一个… 其实C++有提供int转string函数，叫to_string() ORZ… 代码1234567891011121314151617181920class Solution &#123;public: string int2Str(int num) &#123; stringstream ss; ss &lt;&lt; num; string str; ss &gt;&gt; str; return str; &#125; vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; vec; for (int i = 1; i &lt;= n; ++i) &#123; if (i % 15 == 0) vec.push_back(\"FizzBuzz\"); else if (i % 3 == 0) vec.push_back(\"Fizz\"); else if (i % 5 == 0) vec.push_back(\"Buzz\"); else vec.push_back(int2Str(i)); &#125; return vec; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数学","slug":"数学","permalink":"https://orzyt.cn/tags/数学/"}]},{"title":"LeetCode448 Find All Numbers Disappeared in an Array","slug":"leetcode448-find-all-numbers-disappeared-in-an-array","date":"2017-01-15T16:00:00.000Z","updated":"2019-02-08T10:26:00.250Z","comments":true,"path":"posts/leetcode448-find-all-numbers-disappeared-in-an-array/","link":"","permalink":"https://orzyt.cn/posts/leetcode448-find-all-numbers-disappeared-in-an-array/","excerpt":"","text":"描述Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. 样例12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 思路给出一个长度为n的数组，数组元素大小也在[1,n]内，有些数字出现1次，有些出现2次，问哪些数字没出现过。 显然，我们可以开个辅助数组标记哪些数字出现过，然后遍历辅助数组即可找到没出现过的。 但是，不开额外的数组该怎么做呢？那么就必须得充分利用原数组nums！ 因此，nums身兼二职，在不破坏原数组信息的情况下，还要肩负起辅助数组的重任！ 为了记录信息，不改变nums的值是不可能的，所以我们必须找到一个记录信息的方式，使得要用到nums原值的时候可以很方便恢复回来。一个直观的想法是取负，比如 i 这个数字出现过，则把nums[i]取负（多次出现只取负一次）。因此，想得到nums[i]的原值只需取个绝对值即可，想要知道数字 i 出现过没有只需判断nums[i]是否小于0。 代码开O(n)的辅助数组： 1234567891011121314class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;bool&gt; exist(nums.size() + 5, false); for (int i = 0; i &lt; nums.size(); ++i) &#123; exist[nums[i]] = true; &#125; vector&lt;int&gt; ans; for (int i = 1; i &lt;= nums.size(); ++i) &#123; if (!exist[i]) ans.push_back(i); &#125; return ans; &#125;&#125;; 不开额外的空间： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ans; int size = nums.size(); for (int i = 0; i &lt; size; ++i) &#123; int index = abs(nums[i]) - 1; if (nums[index] &gt; 0) nums[index] *= -1; &#125; for (int i = 0; i &lt; size; ++i) &#123; if (nums[i] &gt; 0) ans.push_back(i + 1); &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode463 Island Perimeter","slug":"leetcode463-island-perimeter","date":"2017-01-15T16:00:00.000Z","updated":"2019-02-08T10:26:00.246Z","comments":true,"path":"posts/leetcode463-island-perimeter/","link":"","permalink":"https://orzyt.cn/posts/leetcode463-island-perimeter/","excerpt":"","text":"描述You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. 样例123456[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16 Explanation: The perimeter is the 16 yellow stripes in the image below: 思路给一个地图，含有水和陆地，陆地为一个联通块（四方向联通，且联通块内部不会包含水），问联通块的周长。 首先一块陆地（1*1大小）对周长的贡献是4，只有当它在某个方向上的邻居也是陆地时，这个贡献被抵消掉。因此只要遍历每块陆地的4个方向，判断一下是否有贡献即可。 代码12345678910111213141516171819202122class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int r = grid.size(), c = grid[0].size(); int perimeter = 0; int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; // 四个方向 for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; if (grid[i][j] == 1) &#123; for (int k = 0; k &lt; 4; ++k) &#123; int x = i + dir[k][0], y = j + dir[k][1]; // 邻居坐标 // 若越界 或者 是水 ，则加上该方向上的贡献 if (x &lt; 0 || x &gt;= r || y &lt; 0 || y &gt;= c || grid[x][y] == 0) &#123; perimeter++; &#125; &#125; &#125; &#125; &#125; return perimeter; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"}]},{"title":"LeetCode476 Number Complement","slug":"leetcode476-number-complement","date":"2017-01-15T16:00:00.000Z","updated":"2019-02-08T10:26:00.294Z","comments":true,"path":"posts/leetcode476-number-complement/","link":"","permalink":"https://orzyt.cn/posts/leetcode476-number-complement/","excerpt":"","text":"描述Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. 样例Example 1: 1234Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: 1234Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. 思路求一个32-bit正数各二进制位取反后的数。 位运算的简单操作。通过移位运算符取得num第i位上的数，再用异或操作取反（与1进行异或），最后用或运算加到ans的第i位上即可。 另一个思路是，用二进制位数和num一样且各位都为1的数与num异或即为答案。 比如 1234 10101 &lt;- num^ 11111 &lt;- 二进制全为1------- 01010 代码12345678910class Solution &#123;public: int findComplement(int num) &#123; int ans = 0; for (int i = 0; num; num &gt;&gt;= 1, ++i) &#123; ans |= (((num &amp; 1) ^ 1) &lt;&lt; i); &#125; return ans; &#125;&#125;; 12345678class Solution &#123;public: int findComplement(int num) &#123; unsigned int ans = 1; while (ans &lt;= num) ans &lt;&lt;= 1; return (ans - 1) ^ num; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode2 Add Two Numbers","slug":"leetcode2-add-two-numbers","date":"2017-01-14T16:00:00.000Z","updated":"2019-02-08T10:26:00.430Z","comments":true,"path":"posts/leetcode2-add-two-numbers/","link":"","permalink":"https://orzyt.cn/posts/leetcode2-add-two-numbers/","excerpt":"","text":"描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. 样例12Input:(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 12Output: 7 -&gt; 0 -&gt; 8 思路给两个数位链表，输出求和之后的链表。类似于高精度加法的过程，边求和边进位。为了处理起来方便，可以把小数加到大数上（无需得到真实大小，仅根据链表长度判断大小即可），然后由大数统一处理进位即可。(唉，太久没写链表了，思路不清晰的话调试起来好痛苦…) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int len1 = 0; // l1的长度 int len2 = 0; // l2的长度 ListNode* ptrL1 = l1; // 指向l1 ListNode* ptrL2 = l2; // 指向l2 while (ptrL1) &#123; // 得到l1的长度 len1++; ptrL1 = ptrL1-&gt;next; &#125; while (ptrL2) &#123; // 得到l2的长度 len2++; ptrL2 = ptrL2-&gt;next; &#125; if (len1 &lt; len2) swap(l1, l2); // 将“大数”放在l1上 ptrL1 = l1; ptrL2 = l2; while (ptrL2) &#123; // 由于l2指向“小数”，故仅需判断l2是否为空即可 ptrL1-&gt;val += ptrL2-&gt;val; // l2 加到 l1 上 if (ptrL1-&gt;val &gt;= 10) &#123; // 处理进位 if (ptrL1-&gt;next == NULL) ptrL1-&gt;next = new ListNode(0); ptrL1-&gt;next-&gt;val += (ptrL1-&gt;val) / 10; ptrL1-&gt;val %= 10; &#125; // 指向后继 ptrL1 = ptrL1-&gt;next; ptrL2 = ptrL2-&gt;next; &#125; // 处理后续的进位 while (ptrL1 &amp;&amp; ptrL1-&gt;val &gt;= 10) &#123; if (ptrL1-&gt;next == NULL) ptrL1-&gt;next = new ListNode(0); ptrL1-&gt;next-&gt;val += (ptrL1-&gt;val) / 10; ptrL1-&gt;val %= 10; ptrL1 = ptrL1-&gt;next; &#125; return l1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://orzyt.cn/tags/链表/"}]},{"title":"LeetCode461 Hamming Distance","slug":"leetcode461-hamming-distance","date":"2017-01-14T16:00:00.000Z","updated":"2019-02-08T10:26:00.358Z","comments":true,"path":"posts/leetcode461-hamming-distance/","link":"","permalink":"https://orzyt.cn/posts/leetcode461-hamming-distance/","excerpt":"","text":"描述The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. 0 ≤ x, y &lt; 2^31. 样例12345678910Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 思路给两个32-bit数，求它们有多少个不同的二进制位。判断数x的第i为是否为1：(x &gt;&gt; i) &amp; 1异或运算性质：0 ^ 0 = 1 ^ 1 = 0 1 ^ 0 = 0 ^ 1 = 1 代码12345678910class Solution &#123;public: int hammingDistance(int x, int y) &#123; int ans = 0; for (int i = 0; i &lt; 32; ++i) &#123; if (((x &gt;&gt; i) &amp; 1) ^ ((y &gt;&gt; i) &amp; 1)) ans++; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"https://orzyt.cn/tags/位运算/"}]},{"title":"LeetCode485 Max Consecutive Ones","slug":"leetcode485-max-consecutive-ones","date":"2017-01-14T16:00:00.000Z","updated":"2019-02-08T10:26:00.022Z","comments":true,"path":"posts/leetcode485-max-consecutive-ones/","link":"","permalink":"https://orzyt.cn/posts/leetcode485-max-consecutive-ones/","excerpt":"","text":"描述Given a binary array, find the maximum number of consecutive 1s in this array. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 样例1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. 思路给一个0-1数组，求数组中最长的连续1的个数。循环模拟一遍，遇到非1的数字，更新最长的答案即可。 代码123456789101112131415class Solution &#123;public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; nums.push_back(-1); // 为了方便处理，在数组末尾加入一个非1的数字 int ans = 0, cnt = 0; for (auto x : nums) &#123; if (x == 1) cnt++; else &#123; ans = max(ans, cnt); cnt = 0; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://orzyt.cn/tags/数组/"}]},{"title":"LeetCode1 Two Sum","slug":"leetcode1-two-sum","date":"2017-01-13T16:00:00.000Z","updated":"2019-02-08T10:26:00.146Z","comments":true,"path":"posts/leetcode1-two-sum/","link":"","permalink":"https://orzyt.cn/posts/leetcode1-two-sum/","excerpt":"","text":"描述Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. 样例123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路给定一个数组和一个目标数字，若数组中某两个数字之和等于目标数字，输出它们两个的下标。 一个直观的想法是通过暴力枚举。复杂度$\\mathcal{O}(n^2)$ 另一个想法是把数组中的元素放入哈希表中，当枚举到array[i]时，只要查询 target - array[i] 是否存在于哈希表中即可。复杂度$\\mathcal{O}(nlogn)$ 代码暴力版： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int size = nums.size(), flag = 0; vector&lt;int&gt; index; for (int i = 0; i &lt; size; ++i) &#123; for (int j = 0; j &lt; size; ++j) &#123; if (i != j &amp;&amp; nums[i] + nums[j] == target) &#123; index.push_back(i); index.push_back(j); flag = 1; break; &#125; &#125; if (flag) break; &#125; return index; &#125;&#125;; 哈希表版： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; hashTable; int size = nums.size(); for(int i = 0; i &lt; size; ++i) &#123; hashTable[nums[i]] = i; &#125; vector&lt;int&gt; index; for (int i = 0; i &lt; size; ++i) &#123; int num = target - nums[i]; if (hashTable.find(num) != hashTable.end()) &#123; if (i != hashTable[num]) &#123; index.push_back(i); index.push_back(hashTable[num]); break; &#125; &#125; &#125; return index; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://orzyt.cn/tags/LeetCode/"},{"name":"哈希","slug":"哈希","permalink":"https://orzyt.cn/tags/哈希/"}]},{"title":"软件工程实践总结","slug":"software-engineering-summary","date":"2016-12-29T16:00:00.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/software-engineering-summary/","link":"","permalink":"https://orzyt.cn/posts/software-engineering-summary/","excerpt":"再回首1、对比现在的你和开学初博客开篇的课程目标和期待 开学的目标 现在的情况 学习软件开发的完整过程 经过一个学期理论和实践的学习，在经历过需求分析、系统设计、编码、测试、交付验收等环节以及alpha和beta版本的开发，大体上掌握了软件（web）开发的基本流程。 增强团队协作与沟通交流的能力 加入了“我说的都队”小组，在强大的pm的带领下，小伙伴们配合得相当默契，团队成员之间有充分的沟通与交流，经常约在活动室一起敲代码。 掌握各种开发工具的使用 能初步掌握常用的开发工具，详情请见第2点“学习和使用的新软件和新工具”。 合理安排时间、项目进度 在两个版本的冲刺中，由于pm的合理安排和计划，我们小组仅仅在alpha版本发布前通宵过一次，其他时间基本按照计划走，稳得不行！","text":"再回首1、对比现在的你和开学初博客开篇的课程目标和期待 开学的目标 现在的情况 学习软件开发的完整过程 经过一个学期理论和实践的学习，在经历过需求分析、系统设计、编码、测试、交付验收等环节以及alpha和beta版本的开发，大体上掌握了软件（web）开发的基本流程。 增强团队协作与沟通交流的能力 加入了“我说的都队”小组，在强大的pm的带领下，小伙伴们配合得相当默契，团队成员之间有充分的沟通与交流，经常约在活动室一起敲代码。 掌握各种开发工具的使用 能初步掌握常用的开发工具，详情请见第2点“学习和使用的新软件和新工具”。 合理安排时间、项目进度 在两个版本的冲刺中，由于pm的合理安排和计划，我们小组仅仅在alpha版本发布前通宵过一次，其他时间基本按照计划走，稳得不行！ 2、总结这门课程的实践给你带来的提升： （1）学习和使用的新软件 原型设计工具Axure RP、MockingBot Windows下的Markdown书写软件Typora 分布式版本控制软件git以及托管平台github /coding.net Microsoft Visio画流程图、类图 sublime text编写前端代码 WAMP搭建本地web服务器 （2）学习和使用的新工具 浏览器自带的开发者工具（说实话之前没怎么碰过这个… JavaScript单元测试框架——Qunit 在线思维导图——百度脑图 阿里巴巴矢量图标库——iconfont 在线教程网学习前端知识——w3school （3）学习和掌握的新语言、新平台 html、css、JavaScript （4）统计一下，你在这门软件工程实践中，完成了多少行的代码 不到1k行代码。主要原因还是在于中间出去参加了两场ACM比赛，大概有十几天不在学校。所以PM考虑实际情况后，分配给我的编码工作量比较少。 （5）学习和掌握的新方法 面向搜索引擎编程 前端没学过，只好边学边用 （6）其他的提升 大学第一次通宵献给软工，竟不觉得困… 写前端界面，然后强迫症又加深了… 人月神话1、经验总结 别试图想先学完一个语言，再开始进行编码工作，直接上手才是硬道理 文档工作不是表面功夫，认真对待对后期将有极大的帮助 团队成员之间的沟通交流非常重要，特别是前后端的配合 对pm分配的任务，觉得有疑问的地方要及时提出 站立式会议时间不长，要充分利用机会进行总结，三省吾身 项目进度安排要合理，将各个功能点分配好，避免出现熬夜赶工现象 团队成员聚在活动室一起敲代码，效率绝对比自己一个人敲要高 2、实例分析 主要说说沟通交流方面。 齐民要试验php后台连接cpp编写的分配算法，于是直接跑到他的宿舍去，按照他要求的输出格式对代码进行修改，在有效的沟通交流之下，很快就可以改好了，比在QQ上一来一回的效率高到不知哪里去。 跟胡总的前后端配合，前端页面写完了，后台要接上来，比如分页什么的有问题了就得找下后台，界面布局有问题了又得找下前端，因此前后端之间的交流是必不可少的！ 某个前端页面出现莫名其妙的bug，最底下有一大片空白的页面，关键是只有这个页面有这个问题，然后用浏览器自带的开发者工具查了半天也没发现，后来直接请教前端大佬，不用一会就解决了。所以有时候多跟经验丰富的同学交流是很有帮助的，会让你少走一些弯路。 个人建议 想认真学习软件工程这门课，选栋哥的课准是没错的 想水的可以考虑出门右转了，这个课注定不适合你… 万事开头难，不要轻言放弃，既然选择了hard模式，就请坚持下去 利用空余时间，提前简单了解git和github的使用，不让其成为团队协作的障碍 多与团队成员沟通交流，不要单打独斗，记住软工是一个team 要求有较强的自学能力，软工不会教你某一门具体的编程语言 学会learning by doing，不懂没关系，以做促学 善用Google、StackOverflow等网站，能解决你开发中面临的大部分问题 懂得合理安排时间，不要赶在deadline前才临门一脚 编码不是软工的全部，不要排斥写文档、写博客，用文字记录点滴是有益的 团队分析 阶段 对应时期 主要表现 萌芽 组队 虽然小组成员都是来自计2和计3，但是平常也没多少机会接触。所以组好队之后还是有一个熟悉与融合的过程。在此期间，每个人对自己在团队中所担负的职责、角色定位还不是很清楚。 磨合 选题 在组队初期，我们小组的技能点就是往Android开发方向的，就想着在软工实践课能够开发出一款实用有情怀的app。在选题方面，一开始想过做一款为学校部门、社团服务的app，但是团队成员有着自己不同的想法，以致于出现了较大的意见分歧。后来，选题又改成了类似“赏金猎人”的东西。但是再后来，万万没想到，我们接手了导师互选系统的网页端项目。选题一改再改，团队也在此期间得到不断的磨合。 规范 alpha 选题确定，需求确定，等一切都稳定了下来，大家开始慢慢地配合，慢慢明确了自己的角色和职责。开发、讨论、交流也慢慢变得规范起来，都能够遵守相应的规矩。 创造 beta 构建之法中说，达到创造阶段的团队知道为何而战。哈哈，我们的目标一开始就很明确，是为了栋哥的自助餐而战的，因此大家在每个环节都努力做到最好。“高度自治，不需要领导的实时教诲和介入”，确实，PM通过在github上发布121个issues来计划整个项目，给每个人分配任务和功能点，大家都能够自觉主动地去完成。 综上，我认为我们的团队可以算是达到了创造阶段！ 阅读笔记题目：Open source software development should strive for even greater code maintainability（开源软件的发展需要有更好的代码可维护性） 大意：对开源环境下源代码可维护性的研究结果进行探讨 主旨：开源软件的发展关键在于软件发布之后的维护 文章指出，代码维护主要有以下两种： corrective maintenance：对已经存在的功能进行排错 perfective maintenance：为系统添加新的特性 作者通过测量五款开源软件的可维护性指数（Maintainability Index，MI）来评价各个软件的可维护性，MI值越高说明软件的可维护性越好，并得出了以下结论： 在实现相同功能的情况下，开源软件的代码质量要好于或至少等同于闭源软件的代码质量。 对于开源软件在不同版本可维护性上的表现（MI值波动明显），同时考虑到20%的代码产生80%的维护问题，因此对开源软件需要做更细致独立的分析。 随着时间的推移，开源软件的可维护性也会逐渐降低，因此需要考虑预防性维护（preventive maintenance）。 读完论文之后，发现代码的可维护性是十分重要的。回过头来再看自己编写的代码，主要分为三块，C++编写的分配算法，html写的前端界面，JavaScript编写的测试代码，这三部分代码的可维护性应该是逐渐降低的…主要原因还是在于对语言的掌握程度，掌握的不深入不能够灵活运用，很多时候仅仅只是为了完成一个功能而去编写代码，没有考虑到以后的扩展性以及维护性。但是说大泥球吧，应该也还不至于，至少在提出需求变更的时候，还能看得懂一个多月前写的代码，并进行相应的修改和扩展。 学会软工1、研发出符合用户需求的软件 毕设导师互选是每个高校都必须面临的问题，开发此系统是符合潜在的用户需求的。而且该系统以后可能会被用于数计学院的工作中。 2、通过一系列工具，流程，团队合作，能够在预计的时间内发布 “足够好” 的软件 我们团队有完整的项目规划，并且定时发布项目的进度。 时间 主题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2016-09-25 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 团队选题报告&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2016-10-16 任务计划 2016-10-22 需求规格说明书 2016-10-29 系统设计 2016-11-07~18 Alpha版本十天冲刺集结令 2016-11-19 Alpha版本项目测试 2016-11-19 Alpha版本项目总结 2016-11-24 Alpha版本之事后诸葛亮 2016-12-03 Beta版本之冲刺计划及安排 2016-12-08~16 Beta版本七天冲刺集结令 2016-12-19 Beta版本项目测试 2016-12-19 用户试用与调研报告 2016-12-29 宣传推广方案 3、展现软件是可以维护和继续发展的 github链接:点我跳转仓库里有完整的软件需求说明书等文档，详细的commit记录以及issues，方便维护和继续发展。","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/categories/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/tags/软件工程/"}]},{"title":"2016ACM区域赛青岛赛区总结","slug":"2016-acmicpc-qingdao-summary","date":"2016-11-25T14:59:17.000Z","updated":"2018-11-10T11:47:16.903Z","comments":true,"path":"posts/2016-acmicpc-qingdao-summary/","link":"","permalink":"https://orzyt.cn/posts/2016-acmicpc-qingdao-summary/","excerpt":"这是今年我们队参加的最后一场比赛，被分配到了青岛赛区。","text":"这是今年我们队参加的最后一场比赛，被分配到了青岛赛区。 据说这个赛区有300+队伍参赛，其中不乏很多ACM圈内“偶像级”的大佬，如清华Deep Dark Fantasy队（杜教、cls、jcvb）、北师大的Q神等等，能够亲眼见到他们还是很开心的（乘机%%%，orz）。 比赛前夕，从福州坐绿皮火车，慢悠悠走了29个小时才到达青岛，再一次突破记录！ 热身赛三道题，一人一道，结束后我们队排在前十。热身赛冲在这么前面，队友们纷纷说明天正式赛该掉RP了，orz。 第二天的正式赛，同样前期一人一道，还算顺利。 后来gy大佬在一个人在搞网络流，debug期间，又顺手开了一道KD树，一发AC，就这样我们冲到了银牌区！ 比赛结束后，我被叫去排队领奖，期间瞄到了工作人员手里的榜单。 看来封榜后排名没有什么大的变化，我们队依然坚挺在银牌区。 其实这场比赛对我来说，不仅仅是今年的最后一场比赛，而且应该也是自己参加的最后一场ACM-ICPC区域赛。 大二第一次参加ACM-ICPC区域赛，在北京赛区遗憾打铁 一年后，天时地利人和，CCPC合肥赛区夺银、ICPC青岛赛区夺银 虽然热爱ACM，但是自己还是没办法（没勇气）把时间全投入在上面 明年，应该不能再留校集训了，得开始准备保研的事情 虽然退役了，但是对算法的追求不会停止","categories":[{"name":"随笔","slug":"随笔","permalink":"https://orzyt.cn/categories/随笔/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://orzyt.cn/tags/ACM/"}]},{"title":"2016中国大学生程序设计竞赛总结","slug":"2016-ccpc-hefei-summary","date":"2016-10-29T13:22:00.000Z","updated":"2018-11-10T11:47:16.903Z","comments":true,"path":"posts/2016-ccpc-hefei-summary/","link":"","permalink":"https://orzyt.cn/posts/2016-ccpc-hefei-summary/","excerpt":"最近事情比较多，所以这份比赛总结姗姗来迟。趁今晚有空，总结之。","text":"最近事情比较多，所以这份比赛总结姗姗来迟。趁今晚有空，总结之。 CCPC合肥比赛是在10.15-16两天，第一天热身赛有3题，题面是中文的（后来有人发clarification问正式赛是否也是中文题面，得到肯定的回复后，全场沸腾。果然是中国大学生程序设计竞赛，题面都用中文写，就不用带厚重的字典啦…）三道题目，刚好一人写一道热身，之后就测了下比赛环境，特别是$pc^2$的使用，我们队伍是第一次使用这个软件。在热身赛时，$pc^2$好像评测的特别慢，基本上是提交了半个小时之后才返回结果，如果正式赛也这样，那将大大影响发挥。还好，后来从志愿者那得知，正式赛会有人工评测，评测的速度将会提上去。 第二天正式赛，这个就有点意思了，恰好遇上了更高级别的赛事——国际铁人三项比赛，导致我们的比赛从九点开始一再顺延，期间走到半路又折返回酒店休息，整个上午处在比较奔波折腾的状态，好在十一点多比赛顺利开始了。首先我负责登录系统，准备好编译器，然后开始找水题，由于是中文题面，迅速都扫了一遍，好像没发现特别水的题目。zt开了H题，不过由于种种原因卡住了，我跟gy讨论I题（之后看来，I题应该是最水的一道），也讨论了半个多小时之久。一个小时过去了，一道题都没过，zt让出机位给我敲I题，终于在71min时过了I题，算是吃了一颗定心丸。后来H题好像一直调不出来，zt心里就有点急了，于是换gy上机又重新写了一遍，终于跌跌撞撞在106min过了H题。在gy敲H题的时候，我跟zt在看过的最多的E题，应该是一个麻烦的递推，zt在推E的递推关系，我则在旁边辅助他。推完后，zt上机敲，测了几个样例就交了，然而返回了WA，我跟他检查了半天，他改了之后在177min时过了E题。然后，我跟gy说了A题的题意，是关于图论的一道判定性问题，说完题意之后，我顺口说了一句这道题可以用rand去跑（这也为后面埋下了伏笔…）不过嘛这显然不是正解，被gy给搁置在一边。本着不浪费机时的原则，gy就上机边想边敲。此时过得比较多的还有C题，是关于一个树上博弈的题目，虽然我在队内有负责博弈论，但是在树上的博弈我还是接触的比较少的。于是，先放下这题，又看了其他几道题，不过也基本上都没什么想法。到了封榜的时候，我们队只过了3道题，由于过题晚+罚时多，大约处于铁牌区。封榜后的前半个小时，A、C两道题毫无进展，此时我的心态也近乎崩溃，感觉这次比赛估计又得打铁了。大约还剩25min时，我又跟gy提了下A题rand的想法，于是gy迅速写完了rand的版本。我们先rand了10w次，返回TLE，于是改rand1w次，然后“情理之中，意料之外”地就过了…情理之中是指这道题是一道判定性问题，它的输出只有Yes和No，因此只要找到一个反例不满足题目的条件即可判No，所以采用随机的办法可以有很大的概率找到反例从而得出正确的答案（暑假训练赛的时候也遇到过一题判定性问题，那题的正解就是随机判定）。意料之外就不多说了…于是我们在284min过了A题。现在，我们手上还有一道完全没想法的C题（虽然我盯着样例已经研究看了一个小时了），zt表示要不把树上的博弈用树链剖分弄成线段，再去博弈。然而C题的博弈不仅有询问，还有修改操作，每次询问的树根又都不一样，数据规模又很大，我表示依然没办法处理。此时离比赛结束还有15min，突然间，可能是刷过博弈论专题带给我的“灵感”，一般博弈论都会往一个变量的奇偶性上去靠，而且数据规模很大，询问和修改操作只能在$\\mathcal{O}(1)$或$\\mathcal{O}(logn)$内处理出来，肯定这个处理不会太复杂。于是，我凭直觉猜了个结论，然后我们就马上上机敲了，zt写好建树部分，我则写博弈部分。写完后发现还剩不到3min，于是立马提交。回过神来，发现程序还没有编译，也没测样例。在等待$pc^2$返回结果的间隙，我们赶紧编译一下，还好没有编译错误。接着测了一发样例，都正确！我们在紧张地等待评测结果，最终返回了绿色的Yes！ 284min过A题，297min过C题，最后这几分钟，我们没有放弃，反而让我们如过山车般地从铁牌到银牌，这真是我打过最紧张刺激的比赛！后来，我们打趣说到，C题应该等299min再交，说不定还能拿个顽强拼搏奖（当然，这都是后话了…） 总结一下这场比赛，前期基本处于血崩状态，水题找的慢，找到了也被卡住很久，三道水题写了三个小时。前期失常的发挥特别影响心态以及中后期的发挥，好像这属于我们队的通病，出去打比赛经常这样。这次能够拿到银牌，除去运气成分来说，我觉得应该归功于暑假的训练，正因为暑假训练遇到过一题正解是随机算法的题目，才让我们更有底气去过A题，同时因为在暑假训练的时候刷过博弈论专题（只算是入门专题，没涉及到树上博弈），C题才能找准方向，得到的结论才会比较靠谱… 简而言之，比赛心态重要，题目见多识广也重要！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://orzyt.cn/categories/随笔/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://orzyt.cn/tags/ACM/"}]},{"title":"Build to Win!获得小黄衫的感想","slug":"build-to-win!-summary","date":"2016-10-09T16:00:00.000Z","updated":"2018-11-10T11:47:16.927Z","comments":true,"path":"posts/build-to-win!-summary/","link":"","permalink":"https://orzyt.cn/posts/build-to-win!-summary/","excerpt":"前言&amp;背景从大一上C++课程开始，栋哥就开始安利他大三的软工实践课。时间过得飞快，大学转眼就过去一半了，我也成为了一名大三汪~本来以为软工的课程会如 邹欣老师 微博上的软件工程 这篇博文所展示的一般，又成为了大学生涯中的一门“水课”。然而，栋哥说不会让我们失望的！在安利的时候，说会带来结合《构建之法》、采用“做中学”（learning by doing）、面向实战，理论和实践相结合的课程内容，满满干货！不过嘛，当我第一次听到上面这些时，也没太在意，毕竟能学到什么还得实践了才知道。但是，当提到了《构建之法》的作者是邹欣老师时，突然觉得这个名字好熟悉。:)","text":"前言&amp;背景从大一上C++课程开始，栋哥就开始安利他大三的软工实践课。时间过得飞快，大学转眼就过去一半了，我也成为了一名大三汪~本来以为软工的课程会如 邹欣老师 微博上的软件工程 这篇博文所展示的一般，又成为了大学生涯中的一门“水课”。然而，栋哥说不会让我们失望的！在安利的时候，说会带来结合《构建之法》、采用“做中学”（learning by doing）、面向实战，理论和实践相结合的课程内容，满满干货！不过嘛，当我第一次听到上面这些时，也没太在意，毕竟能学到什么还得实践了才知道。但是，当提到了《构建之法》的作者是邹欣老师时，突然觉得这个名字好熟悉。:) 哈哈，没错！翻了翻我的微博关注列表，原来我早就关注了邹欣老师以及周筠老师。之前由于能在两位老师的微博里了解到IT行业的相关知识，所以就关注了。没想到原来这位微博上的“大V”微软研发经理还是一名软件工程的教师，更没想到他写的书会成为我这学期软工的辅助教材，想想就有点小激动呢！ 读《构建之法》的体会在软工的第二次作业中，栋哥就布置我们阅读《构建之法》的第3章——软件工程师的成长 和第8章——需求分析 来完成我们的结对编程项目。在最近的一次个人作业中，也布置阅读了相关章节。说来惭愧，目前《构建之法》整本书还没有读完，所以谈的体会可能还是比较片面的吧。首先谈谈书的封面，个人比较喜欢简洁的风格，所以第一次看到这本书的封面时，简洁的封皮配上互相啮合的鲁班锁，简直大爱。对于书的风格，我觉得用“幽默风趣，有血有肉”来形容再恰当不过了。不同于国外翻译过来的教材（就比如说我们的主教材…），虽然经典，但是比较晦涩不接地气。同时，这本书采用了对话，举例等方式来讲解，特别是创造了王屋村软件学院、移山公司和阿超、小飞等人物使软工的内容不再枯燥乏味，跃然于纸上。目前从书中学会了需求分析中的NABCD模型以及个人开发流程（PSP）等实用的知识，并能够在实践中得到一定的应用。希望在接下来的阅读中，能够学习到更多有用的软工知识！ 获得小黄衫的感受很幸运到目前为止个人积分暂列第一 :)，达成成就 获得 Build to win 小黄衫一件！ 据说拿到小黄衫，是拥有“黄色领骑衫”含义的一种优胜荣誉喔~ 但革命尚未成功，同志仍需努力！ XD 进一步的计划 阅读完《构建之法》 定位自己在团队中的角色 提升个人的编程实力 致谢感谢栋哥开设的这门软工实践课，干货满满！感谢邹欣老师以及周筠老师出版的《构建之法》这本书，将会有更多的学生受益！感谢各位助教老师辛勤的工作，点评、统计分数也挺不容易的！感谢我的小组 “我说的都队”，一起赶选题报告很开心！感谢我的结对编程搭档 小VV ,结对编程的感觉真好！最后，感谢替我拍照的舍友 :)","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/categories/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/tags/软件工程/"}]},{"title":"结对编程之毕设导师智能匹配","slug":"pair-programming-tutor-distribution","date":"2016-09-29T16:00:00.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/pair-programming-tutor-distribution/","link":"","permalink":"https://orzyt.cn/posts/pair-programming-tutor-distribution/","excerpt":"问题描述 编码实现一个毕设导师的智能匹配的程序 输入: 30个老师（包含带学生数的要求的上限，单个数值，在[0,8]内） 100个学生（包含绩点信息），每个学生有5个导师志愿（志愿的导师可以重复但不能空缺） 输出: 导师和学生间的匹配信息（一个学生只能有一个确认导师，一个导师可以带少于等于其要求的学生数的学生） 未被分配到学生的导师 未被导师选中的学生","text":"问题描述 编码实现一个毕设导师的智能匹配的程序 输入: 30个老师（包含带学生数的要求的上限，单个数值，在[0,8]内） 100个学生（包含绩点信息），每个学生有5个导师志愿（志愿的导师可以重复但不能空缺） 输出: 导师和学生间的匹配信息（一个学生只能有一个确认导师，一个导师可以带少于等于其要求的学生数的学生） 未被分配到学生的导师 未被导师选中的学生 问题分析学生角度:根据学生对导师喜爱的程度，将五个志愿按照优先级排序,优先考虑志愿靠前的导师对于每个学生有 $student_{i}:choice_{1}&gt;choice_{2}&gt;choice_{3}&gt;choice_{4}&gt;choice_{5}$ 导师角度:由于输入数据只有 绩点 这一评价标准，故每个导师在所有选他的学生中优先考虑绩点高的(后期可以根据学生的专业知识修养、兴趣方向（学生想从事哪方面的研究）、创新能力等等综合信息来形成评价标准）对于每个导师有 $teacher_{i}:student_{1}&gt;student_{2}&gt;student_{3}&gt;…&gt;student_{n}$ 由于导师的分配会因为学生的偏好造成导师志愿的分布不均匀，这可能会导致有些学生分配不到导师，或者有的导师没有分配到学生，这就需要一些算法对此加以控制以达到最优匹配。 采用的算法由于笔者有参加ACM竞赛，看到这个问题联想到图论中的 稳定婚姻问题(Stable marriage problem) 。查找了相关的文献资料后，发现导师分配问题是属于该问题的一个变形。而对于该问题，通常用 Gale-Shapley 算法来解决。 Gale-Shapley 算法简称 G-S 算法，也被称为延迟接受算法。该算法由 Gale 和 Shapley 提出，他们研究学校申请与婚姻稳定的匹配问题，并用 G-S算法得到了稳定的匹配， 这种匹配是帕累托最优。该算法只需在信息完全且充分的情况下，选择的双方按照自己的偏好进行排序，且一方先进行选择即可得出最优稳定匹配。 Gale-Shapley 算法的核心思想：在信息对称且完全的情况下， 存在需要相互选择的集合 $T = \\lbrace T_{1}, T_{2}, T_{3}, …, T_{m} \\rbrace$ 与 $S = \\lbrace S_{1}, S_{2}, S_{3}, …, S_{n} \\rbrace$， 集合 $S$ 中的个体 $S_{i}$ 对 $T$ 中的个体存在偏好如 $S_{i} = \\lbrace T_{2}, T_{1}, T_{5}, …, T_{m} \\rbrace$，表示对于 $S_{i}$ 的第一选择为 $T_{2}$，第二选择为 $T_{1}$，第三选择为 $T_{5}$，依次类推。 $T$ 中个体 $T_{r}$ 对 $S$ 中的个体存在偏好 $T_{r} = \\lbrace S_{6}, S_{3}, …, S_{n} \\rbrace$。 让 $S$ 对 $T$ 做出选择，即发出信息（如申请学校或求婚）。 当 $T$ 接收信息的容量低于自己的需求量 $K$ 时，全部暂时接受。 当 $T$ 的接收信息容量超过自己需求量 $K$ 时，$T$ 根据自己的偏好从中进行选择，暂时接受其中处于偏好前面的 $K$ 个，拒绝其他。被拒绝个体根据自己的第二偏好进行选择，并发出信息。若第二偏好的 $T_{r}$ 未饱和，则暂时接受。若第二偏好的 $T_{r}$ 饱和， 则 $T_{r}$ 对包括上次选择的所有给自己发出信息的人按照偏好再次进行选择，并确定暂时接受的人和拒接的人。 被拒绝的人按照偏好顺序再次选择下一个偏好，依次类推……直到没有人剩下，整个匹配结束。 作为发出信息选择的一方占相对优势，被选择的一方占相对劣势。 但是随着选择次数的增多，稳定匹配时发出信息的一方会越处于偏好后方，而被选择的一方会越处于偏好前方。 算法步骤根据原始的 Gale-Shapley 算法, 我们稍加修改后即可适用于原问题。 分配步骤： 按照学生在数据中的顺序根据当前志愿分配导师，若导师的学生数未满则直接把此学生分配给该导师；否则将此学生和已分配给该导师的学生中绩点最低的那个学生比较，若是此学生的绩点低于绩点最低的那个学生，则进入下一轮分配（下一轮分配考虑此生的下一个志愿）；否则如果此学生的绩点高于绩点最低的那个学生，则将此生分配给该导师，绩点最低的那个学生则不再属于该导师，并将该学生的状态改为未分配。一直循环上述步骤，直到考虑了所有学生的所有志愿。 流程图： 伪代码： 12345678910111213141516function Matching &#123; Initialize all s ∈ Student and t ∈ Teacher to free while ∃ a free Student s who still has a choice t to choose &#123; t = first teacher on s' list to whom s has not yet chose if t is free distribute(s, t) else some pair (s', t) already exists if t prefers s to s' distribute(s, t) set s' to free else remain(s', t) else set s to free &#125;&#125; 代码实现实现语言：C++ 学生类 1234567struct Student &#123; int student_id; // 学生编号 int teacher_id; // 中选的导师编号 int cur; // 当前分配进程正在考虑第cur个志愿 int want[5]; // 五个志愿 float point; // 绩点&#125;; 导师类 123456struct Teacher &#123; int teacher_id; // 导师编号 int want_num; // 期望的学生数 int chose_num; // 已中选的学生数 int student_id[10]; // 中选的学生编号&#125;; 分配系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class DistributeSystem &#123; private: int student_number; // 学生总人数 int teacher_number; // 导师总人数 Student* stu; Teacher* tch; public: // 构造函数与析构函数 DistributeSystem() &#123;&#125; DistributeSystem(int stu_num, int tch_num) &#123;&#125; ~DistributeSystem() &#123;&#125; // 随机生成导师信息 void generate_teacher_information() &#123;&#125; // 随机生成学生信息 void generate_student_information() &#123;&#125; // 根据导师编号返回他在数组中的下标 int get_teacher_index(int teacher_id) &#123;&#125; // 根据学生编号返回他在数组中的下标 int get_student_index(int student_id) &#123;&#125; // 使用Gale–Shapley算法进行分配 void distribute() &#123; queue&lt;Student&gt; Que; //未分配到导师的学生队列 for (int i = 0; i &lt; student_number; ++i) &#123; Que.push(stu[i]); // 初始都是未分配状态，都加进队列 &#125; while (!Que.empty()) &#123; Student&amp; s = stu[get_student_index(Que.front().student_id)]; Que.pop(); // 考虑学生s的第cur个志愿（导师为t） Teacher&amp; t = tch[get_teacher_index(s.want[s.cur++])]; if (t.want_num &gt; t.chose_num) &#123; // 如果导师t还有剩余名额，直接中选 t.student_id[t.chose_num++] = s.student_id; s.teacher_id = t.teacher_id; &#125; else &#123; int min_stu_id = -1; // 导师t中绩点最低的学生编号 int pos = -1; // 以及他在导师的中选列表中的下标 float min_point = 5.0; for (int i = 0; i &lt; t.chose_num; ++i) &#123; // 在导师t中查找绩点最低的学生编号 Student tmp = stu[get_student_index(t.student_id[i])]; if (min_point &gt; tmp.point) &#123; min_point = tmp.point; min_stu_id = tmp.student_id; pos = i; &#125; &#125; // 如果导师t不带学生 或者 学生s的绩点比导师t所有已经中选学生的最低绩点还低，那么学生t只好再等下轮 if (t.want_num == 0 || s.point &lt; min_point) &#123; if (s.cur &lt; 5) &#123; // 如果五个志愿还没考虑完毕的话，放入队列中继续参与分配 Que.push(s); &#125; &#125; else &#123; // 不然学生t就直接替换掉绩点最低的那个学生 Student&amp; min_stu = stu[get_student_index(min_stu_id)]; min_stu.teacher_id = -1; if (min_stu.cur &lt; 5) &#123; // 被替换掉的学生再放入未分配的队列中去 Que.push(min_stu); &#125; t.student_id[pos] = s.student_id; s.teacher_id = t.teacher_id; &#125; &#125; &#125; &#125; // 从导师角度查看分配结果 void get_teacher_result(bool flag) &#123;&#125; // 从学生角度查看分配结果 void get_student_result(bool flag) &#123;&#125;&#125;; 代码分析对于我们的代码，分配的结果概括起来大概是这样： 分配导师的时候志愿的顺序很重要，只要绩点不是太低，且自己喜欢志愿顺序靠前，就会分配到自己喜欢的导师 分配的轮数越多，越是对导师有利（如果选这个导师的人比较多留下的都是绩点比较高的） 结果评估为了评估该算法的实际效果，笔者随机生成了 10000 个样本对其进行测试。 样本约定： 导师的人数在 30 ~ 100 人之间 学生的人数为导师的 1 ~ 4 倍 将 10000 个样本分为 10 组，每组 1000 个，得到的结果如下表所示： 学生未分配率： 样本组数 最好情况 最坏情况 平均情况 1 &nbsp; &nbsp; &nbsp; 0.0000% &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 22.4806% &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.5869%&nbsp; &nbsp; &nbsp; 2 0.0000% 16.9675% 1.5230% 3 0.0000% 20.1681% 1.6781% 4 0.0000% 18.6992% 1.7076% 5 0.0000% 18.2609% 1.5168% 6 0.0000% 28.0000% 1.6612% 7 0.0000% 18.7500% 1.5338% 8 0.0000% 18.0180% 1.6950% 9 0.0000% 21.1180% 1.6605% 10 0.0000% 22.5131% 1.7302% 平均 0.0000% 20.4975% 1.6293% 学生中选志愿顺序： 样本组数 最好情况 最坏情况 平均情况 1 &nbsp; &nbsp; &nbsp; 1.03030 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.00000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.43622&nbsp; &nbsp; &nbsp; 2 1.05714 2.08264 1.42591 3 1.01818 2.01935 1.43242 4 1.02941 2.07207 1.43448 5 1.02857 1.97177 1.42840 6 1.04110 2.14433 1.43085 7 1.00000 2.04717 1.42317 8 1.06796 2.04819 1.43239 9 1.02041 2.15789 1.43456 10 1.02273 2.03759 1.43417 平均 1.03158 2.05810 1.43126 分析： 从上面可以看出，该算法的总体效果非常好。对于学生未分配率来说，在最好情况下，所有学生都能得到分配。而在最坏情况竟然达到20%左右，这个数据一开始令笔者较为吃惊！后来在调试的过程中，将最坏情况下的输入数据进行输出查看，发现基本上都是出现在 学生的数量为导师的3倍多到4倍左右 以及 导师所期望带的学生数较少 这种极限数据情况下。对于通常情况，基本上学生的未分配率保持在1.6%左右。另一方面，对于学生中选的志愿，最好情况能够保证在第一志愿即可录取，而最差情况下也能够第二志愿录取。当然，没中选的学生是没有统计到该数据当中的（因为落选了，中选志愿更无从谈起）。 小结与感受 vvxyz: 总的来说这次作业抱了大腿，搭档是ACM的大神，这次编程的思路基本是按照搭档的思路走的，代码主要是搭档编写的，我们结对编程的时候，基本就是搭档是主力，我在旁边辅助，帮他纠正一些细节上的错误，改bug的时候帮助分析错误。这次结对编程的代码并没有很多难理解的地方，但是编程的过程中感受到了搭档强大清晰的逻辑思维以及扎实的c++基本功，这是值得我学习与思考的地方。 orzyt: 其实本次作业一开始搭档是想用 Java 配合数据库来写的，但由于我平常都是用C++来写算法，因此搭档为了配合我，后来就订下用C++编写。这里对搭档说一声感谢！对于此次结对编程题目，很切合实际，因为上学期我们刚刚经历过学生选导师这一环节。然后我是把这次作业当做一道ACM算法题目来写的（栋哥不要打我…），但是嘛，这次不只是为了AC这么简单。为了代码的规范性，以及更容易维护，我将算法的主要功能都封装在DistributeSystem类中。然后不得不说的就是debug的过程！在结对编程的第一天，我将代码的整体框架编写完毕，本地测试了学生数=100，导师数=30，以及其他几组数据，查看结果基本上符合预期，就将代码推送到git上去了。第二天，为了更好地评估该算法的实际效果，于是我就随机生成了一万个测试样本（详情见第七节），然后基本上程序跑着跑着就奔溃了。于是开始了漫长的debug过程，花费了一个晚上，进行各种花式调试，最终发现是 程序不能正确处理 导师期望数为0 的这种情况！！吐血…总之，在此次结对编程中，从建模、查文献、实现算法、样本测试一步步走过来，收获还是挺大的！ 结对过程的闪光点 能够对原问题进行抽象建模 搭档之间相互支持鼓励，能够进行有效的沟通交流 懂得查找相关参考文献、学术论文等资料 代码仓库点击查看：Distribute System 参考文献 Wikipedia. 稳定婚姻问题(Stable marriage problem) D. Gale and L. S. Shapley. College Admissions and the Stability of Marriage 向 冰,刘文君. 硕士研究生与导师的双向选择的最优匹配 刘汝佳, 陈锋. 算法竞赛入门经典—训练指南","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/categories/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://orzyt.cn/tags/软件工程/"},{"name":"结对编程","slug":"结对编程","permalink":"https://orzyt.cn/tags/结对编程/"},{"name":"Gale-Shapley算法","slug":"Gale-Shapley算法","permalink":"https://orzyt.cn/tags/Gale-Shapley算法/"}]},{"title":"2015ACM区域赛及省赛总结","slug":"2015-acmicpc-beijing-summary","date":"2015-12-21T16:00:00.000Z","updated":"2018-11-10T11:47:16.903Z","comments":true,"path":"posts/2015-acmicpc-beijing-summary/","link":"","permalink":"https://orzyt.cn/posts/2015-acmicpc-beijing-summary/","excerpt":"2015ACM-ICPC亚洲区域赛（北京赛区） 首先是11月份的北京区域赛，有幸集训队能给予这次难得的机会让我们出去锻炼。第一次正式参加比赛，心情是比较复杂的，兴奋、忐忑、激动、不安等夹杂着。 第一天参加热身赛，由于没有熟悉的CodeBlocks，有点慌张，一开始的时间都花在应该用哪个IDE上，后面只好用相对友好的Geany来写代码。热身赛写了2道题，感觉发挥的中规中矩，之后稍微测了下hihoCoder的环境，没发现有什么特别的地方。","text":"2015ACM-ICPC亚洲区域赛（北京赛区） 首先是11月份的北京区域赛，有幸集训队能给予这次难得的机会让我们出去锻炼。第一次正式参加比赛，心情是比较复杂的，兴奋、忐忑、激动、不安等夹杂着。 第一天参加热身赛，由于没有熟悉的CodeBlocks，有点慌张，一开始的时间都花在应该用哪个IDE上，后面只好用相对友好的Geany来写代码。热身赛写了2道题，感觉发挥的中规中矩，之后稍微测了下hihoCoder的环境，没发现有什么特别的地方。 第二天正式比赛，我先负责登录，然后开始看题，刷榜后发现有人过了G题后，我和队友zt开始读G题，G题是给四块矩形选择其中三块，问这三块矩形能不能拼成更大的矩形。读完后队友zt开始推可能的组合情况，推完后上去敲，提交后WA，打印之后检查出判断条件写错了，后来再交还是WA，我跟他检查感觉没什么问题，无奈把题意跟另一个队友gy说了之后，他想了一会说可能是漏了一种情况，果然，加上去之后AC了！大概1个小时左右才过1题，这是很危险的。然后目光锁定在J，J此时过的人数也非常多，应该是签到题。队友gy说他看了第一遍题目后，没能理解题意。当我看完之后，也是一头雾水，只好又重新看了一遍，这时稍微理解了，题目是给一系列游戏操作（操作种类有3种），问得到顶级评价的次数最多有几次。然后我就按照自己的理解推样例，发现可以过，于是开始上机敲代码，提交后WA…，心想签到题不应该有坑才对，于是开始考虑各种边界情况，以为是边界没处理好的问题，然后修改了几次后，提交依旧是WA…这时离比赛开始已经过了2个多小时了，整个队的心情都是很沉重的，我只好让出机位给队友gy敲A题。A题队友敲的是线段树，写的有点冗长，写完开始调试，发现自己构造的数据过不了，然后不断地修改，队友zt在看其他可做的题，我在一旁在纸上写着J的代码，等队友gy思考不用机时的时候，我把纸上的代码交了一发，还是WA…内心是崩溃的…于是开始怀疑题目是不是看错了，因为这题题意不太好看懂，所以我跟另外两位队友无法就细节地方进行交流。我于是沉下心，把题目再读了一遍，发现那3种操作，有2种操作是要看成同一种的，知道之后马上把刚才那个充满“补丁”的代码全删了，然后只敲了短短几行就AC了。此时已经快接近封榜了，才把所谓的签到题做出来，真的是无地自容。然后队友gy依旧在敲A，队友zt跟我讲了下他刚才看的几道题的题意，听完后，都没有什么思路，于是封榜之后我跟队友gy都在看A，直到比赛结束还是没做出来。后来知道A只要二分就可以了，线段树有点小题大做了… 从北京赛区公布奖牌比例之后，知道拿牌希望渺茫，但是没想到会打得这么惨。第一次参加现场赛，暴露出了我们队很多问题，一方面我们心理素质不够硬，导致在卡题时不能够有效地应对，放下卡住的签到题去想其它更难的题又不甘心，不放下又陷入自己的思路之中无法自拔。另一方面我们的知识面还太窄，队友之间的讨论也很局限，很多题目看了没有思路，而且限于时间，三个人目前专注的方向基本上没有交叉，因此很多时候一道题只有一个人在想，这也是一个弊端。 2015第六届福建省大学生程序设计竞赛 北京区域赛结束到省赛之间，大概间隔一个月左右。在这期间，我们开始尝试做些个人训练，参加了一两场的Codeforces和BestCoder比赛，主要目的在于对前几题这种较简单的题能够快速准确的写出来。然后组队训练做了大概近3年的省赛题目，自我感觉还算良好。 对于12月的省赛，因为难度比区域赛来说肯定简单不少，再结合组队训练的结果来看，我们将目标订在了银奖。由于六级的原因，我们队热身赛只去了一个人，然后现场做出了3题（共5题），后来等队友都到齐后，在宾馆研究了剩下的2题，理论AK之后就去休息了，到此时，我们对省赛还是充满了信心。 第二天正式赛开始后，队友gy迅速看了下A，思路跟我讲了下，觉得可行，交了之后1Y。然后B发现是水的计算几何，队友zt分类讨论下，我上去敲代码，交了也1Y。在我敲B的时候，队友zt则在想C，并在纸上写好了C的代码，B一过，马上把机子让给他，敲完之后，C也1Y。此时离比赛开始还不到50min，3题都1次AC，我们队排在金牌区，开局十分顺利！然后我们把目光都投在J题，根据目前过题人数来看，应该也是一道简单题。J是一道类似博弈的题，我跟队友gy讨论下博弈的策略，觉得策略应该没错，于是上机敲了下，返回WA…然后我们又重新讨论下，再次提交，依然WA…然后队友zt也一起来想J题，按照他的策略交了一发，还是WA…，看着J题过题人数不断上升，我们却依然陷在了自己的思路之中，感觉这又是一场噩梦，从10点到12点这2个小时中，整个队伍都在想J题，明明那么多队过了，为什么我们无限WA…难道说题目又看错了？！我们对存疑的地方进行了提问，但是得到的回复却是我们理解的没错！无奈只好留队友gy一个人继续磕这题，我跟队友zt继续看其他题，我把E题大题跟队友zt说下，我们感觉是一道动态规划的题目，然后剩下的时间队友在敲E，我继续看其他题。敲完E后，发现样例过不了，我帮他检查了一下，发现转移方程是有后效性的，不能这样写。但是我们依旧认为这是道dp的题，队友zt继续考虑状态方程要怎么设计，于是打印代码，把机子让给了队友gy。J的进展依旧不顺利，在提交了十几次以后，封榜时我们终于过了J，这是我们过的第4道题目，距离第3道题目已经过了三个多小时…此时早已掉到铜牌区…我跟队友zt继续抢救E，但是发现不管怎样转移，都是有问题的，直到最后十几分钟，我开始换了一种思路，感觉是可行的（事后题解也确实是这种方法），但迫于时间，最终没有写成… 比赛结束之后，我们心情很沉重，没想到我们又死在了所谓的“签到题”上。虽然我们队伍在实验室做比赛可以做得相对不错，但是到了现场之后，我们卡题之后的心理素质问题依旧暴露无遗，仅有的一点实力也发挥不出来，真是可悲。 经过这两次的比赛，我觉得今后锻炼的方向不应该仅仅是知识的水平，编码的水平，更多的是心理素质要提高。心理素质不过硬，再有实力发挥不出来也无济于事。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://orzyt.cn/categories/随笔/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://orzyt.cn/tags/ACM/"}]},{"title":"Manacher算法","slug":"manacher-algorithm","date":"2015-10-26T16:00:00.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/manacher-algorithm/","link":"","permalink":"https://orzyt.cn/posts/manacher-algorithm/","excerpt":"首先用一个非常巧妙的方式，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如 $#a#b#a#。 下面以字符串 12212321 为例，经过上一步，变成了 s = $#1#2#2#1#2#3#2#1# ;然后用一个数组 p[i] 来记录以字符 S[i] 为中心的最长回文子串向左/右扩张的长度（包括 s[i] ），比如 s[i] 和 p[i] 的对应关系： s[i] # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 # p[i] 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1 (从上表可以看出，p[i]-1 正好是原字符串中回文串的总长度）","text":"首先用一个非常巧妙的方式，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如 $#a#b#a#。 下面以字符串 12212321 为例，经过上一步，变成了 s = $#1#2#2#1#2#3#2#1# ;然后用一个数组 p[i] 来记录以字符 S[i] 为中心的最长回文子串向左/右扩张的长度（包括 s[i] ），比如 s[i] 和 p[i] 的对应关系： s[i] # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 # p[i] 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1 (从上表可以看出，p[i]-1 正好是原字符串中回文串的总长度） 那么怎么计算 p[i] 呢？该算法增加两个辅助变量 id 和 mxid : 表示右边界最远的回文子串中心的位置 (注:貌似很多blog说 id 表示最大回文子串中心的位置，我觉得是不对的）mx : 则为 id+p[id]，也就是上述回文子串的右边界。 然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了： 如果 mx &gt; i，那么 p[i] &gt;= min(p[2 * id - i], mx - i) ，其中 i 与 j 关于 id 对称。 123456// 上述结论可写成如下代码：// 记 j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点。if (mx - i &gt; P[j]) P[i] = P[j];else // P[j] &gt;= mx - i P[i] = mx - i; // P[i] &gt;= mx - i，取最小值，之后再匹配更新。 (1) 当 mx - i &gt; p[j] 时， 由 id 的定义知，红色线段的字符串是以 id 为中心的最长回文串!同时， j 是 i 关于 id 的对称点，由于红色字符串是回文字符串，所以关于 j 对称的回文子串 和 关于 i 对称的回文子串 是完全一样的!!(即图中两段绿色的线条)而满足 mx-i&gt;p[j] 时, 说明此时 j 的回文子串半径 小于 j 到 mx 对称的左端点的差，此时可以初始化 p[i] = p[j] 。 (2) 当 mx-i &lt;= p[j] 时， 由于 mx-i&lt;=p[j] ,说明此时$j$的回文子串半径 大于或等于 j 到 mx 对称的左端点的差. 在目前最长回文串（即红色所示）的范围内，关于 i 对称的回文串可能的长度为 mx-i , 此时可以初始化 p[i]=mx-i . 而对于红色范围之外的（即超过mx的字符），它是否关于 i 对称呢？ 因此，还需再对 p[i] 的回文子串半径进行进一步的增大!! (3) 当 mx&lt;=i 时，对于 mx&lt;=i 的情况，无法对 p[i] 做更多的假设，只能令 p[i] = 1 ，然后再去匹配了. 代码实现： 123456789// 转换字符串str， 比如将字符串 123 转换成 $#1#2#3#void Transform (char* str) &#123; int l = 0; s[l++] = '$'; s[l++] = '#'; for (int i = 0; str[i]; ++i) &#123; s[l++] = str[i]; s[l++] = '#'; &#125; s[l] = 0;&#125; 12345678910111213141516int Manacher (char* str) &#123; Transform(str); int mx = 0, id = 0, ans = 0; memset (p, 0, sizeof(p)); for (int i = 1; s[i]; ++i) &#123; p[i] = mx &gt; i ? min(p[2*id-i], mx-i) : 1; // 如上所述 while (s[i+p[i]] == s[i-p[i]]) p[i]++; //以i为中心，p[i]为半径，查找是否还有可能构成回文的情况 if (i + p[i] &gt; mx) &#123; // 更新最远的右边界 mx = i+p[i]; id = i; &#125; ans = max(ans, p[i]-1); // 答案即为所有的p[i]-1中的最大值 &#125; return ans;&#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://orzyt.cn/categories/算法与数据结构/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"},{"name":"算法","slug":"算法","permalink":"https://orzyt.cn/tags/算法/"},{"name":"Manacher","slug":"Manacher","permalink":"https://orzyt.cn/tags/Manacher/"},{"name":"回文","slug":"回文","permalink":"https://orzyt.cn/tags/回文/"}]},{"title":"Trie字典树总结","slug":"trie-summary","date":"2015-10-24T16:00:00.000Z","updated":"2018-11-10T11:47:16.931Z","comments":true,"path":"posts/trie-summary/","link":"","permalink":"https://orzyt.cn/posts/trie-summary/","excerpt":"字典树概念字典树——又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。","text":"字典树概念字典树——又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 有三种基本的性质： 根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同. 字典树定义与操作静态数组版（以一棵26个小写字母组成的Trie为例）： 123456789101112131415161718192021222324252627282930313233343536373839struct Trie &#123; Trie* next[26]; // 指向26个儿子节点 bool flag; // 从根节点到当前节点是否构成单词 ...... // 附加相关信息 &#125; node[MAX_N]; int num; // 当前分配的节点编号 // 初始化 void init () &#123; num = 0; memset(node, 0, sizeof(node)); &#125; // 得到字符c相对于'a'的编号 int getid (char c) &#123; return c - 'a'; &#125; // 在Trie中插入字符串s void insert (char* s) &#123; Trie* head = &amp;node[0]; // node[0]为根节点 while (*s) &#123; // 遍历字符串 int id = getid(*s++); if ((head-&gt;next[id]) == NULL) // 若该儿子不存在，则分配新的节点 head-&gt;next[id] = &amp;node[++num]; head = head-&gt;next[id]; // 指针指向儿子节点 &#125; head-&gt;flag = true; // 最后做上标记 &#125; // 在Trie中查找字符串s bool search(char* s) &#123; Trie* head = &amp;node[0]; while (*s) &#123; int id = getid(*s++); if (head-&gt;next[id] == NULL) return false; head = head-&gt;next[id]; &#125; return head-&gt;flag; &#125; 动态分配版： 12345678910111213141516171819202122232425262728293031struct Trie &#123; Trie* next[26]; int cnt; int getid(char c) &#123; return c - 'a'; &#125; Trie* newnode() &#123;return (Trie*) calloc(1, sizeof(Trie)); &#125; void insert(Trie* root, char* s) &#123; Trie* head = root; while (*s) &#123; int id = getid(*s++); if (head-&gt;next[id] == NULL) head-&gt;next[id] = newnode(); head = head-&gt;next[id]; (head-&gt;cnt)++; &#125; &#125; bool search(Trie* root, char* s) &#123; Trie* head = root; while (*s) &#123; int id = getid(*s++); if (head-&gt;next[id] == NULL) return false; head = head-&gt;next[id]; &#125; return head-&gt;flag; &#125; void del(Trie* root) &#123; Trie* head = root; for (int i = 0; i &lt; 26; ++i) if (head-&gt;next[i] != NULL) del(head-&gt;next[i]); free(root); &#125;&#125; trie; 字典树的应用 1) 串的快速检索 Q：给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。 A： 我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。 2) “串”排序 Q：给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。 A：用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。 3) 最长公共前缀 A： 对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数。于是，问题就转化为公共祖先问题。 字典树的例题 HDU 1251 统计难题POJ 3630 Phone ListPOJ 2503 BabelfishHDU 1075 What Are You Talking AboutHDU 1247 Hat’s WordsPOJ 1056 IMMEDIATE DECODABILITYHDU 3172 Virtual FriendsPOJ 2001 Shortest PrefixesPOJ 1204 Word PuzzlesHDU 1800 Flying to the MarsHDU 1298 T9","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://orzyt.cn/categories/算法与数据结构/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://orzyt.cn/tags/字符串/"},{"name":"算法","slug":"算法","permalink":"https://orzyt.cn/tags/算法/"},{"name":"字典树","slug":"字典树","permalink":"https://orzyt.cn/tags/字典树/"}]},{"title":"素数筛法","slug":"seive-of-prime-numbers","date":"2015-02-23T16:00:00.000Z","updated":"2019-02-07T15:10:57.582Z","comments":true,"path":"posts/seive-of-prime-numbers/","link":"","permalink":"https://orzyt.cn/posts/seive-of-prime-numbers/","excerpt":"Eratosthenes筛法先用第一个质数2去筛，2留下，把2的倍数剔除掉。再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉。接下去用下一个素数5筛，把5留下，把5的倍数剔除掉。不断重复下去，最后剩下来的都是质数。","text":"Eratosthenes筛法先用第一个质数2去筛，2留下，把2的倍数剔除掉。再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉。接下去用下一个素数5筛，把5留下，把5的倍数剔除掉。不断重复下去，最后剩下来的都是质数。 12345678910111213//判断前N个质数 bool isPrime[N];int prime[N/2], tot = 0;memset(isPrime, true, sizeof(isPrime));for (int i = 2; i &lt;= N; i++) &#123; if (isPrime[i]) &#123; prime[tot++] = i; // 把 i 的倍数都筛掉 for (int j = i*2; j &lt;= N; j += i) &#123; isPrime[j] = false; &#125; &#125;&#125; 时间复杂度：$\\mathcal{O}(nloglogn)$ 但是Eratosthenes筛法存在一个问题，就是一个合数有可能会被多个质因子筛去。比如15，既会被3筛一遍，又会被5筛一遍，所以该算法还有进一步的提升空间。 Euler筛法欧拉筛法是一种线性算法，保证每一个合数只被筛一次。比如15，现在只会被3筛掉，而不会被5再筛一遍。原因在于欧拉筛法只让每个合数被它最小的质因数筛掉。 1234567891011121314bool isPrime[N];int prime[N/2], tot = 0;memset(isPrime, true, sizeof(isPrime));for (int i = 2; i &lt;= N; i++) &#123; if (isPrime[i]) prime[tot++] = i; for (int j = 0; j &lt; tot; j++) &#123; //超过最大范围，跳出 if (i * prime[j] &gt; N) break; //将倍数筛除 isPrime[i * prime[j]] = false; //保证只筛到以prime[j]为最小质因数的数 if (i % prime[j] == 0) break; &#125;&#125; 接下来做两点说明： 保证每个合数都会被筛掉 不妨将合数$x$做质因数分解，得到$x = p_{1}^{k1}p_{2}^{k2}\\dots p_{m}^{km}$，其中$p_{i}$都是质数，并按从小到大排列。 则合数$x$必然在 for循环枚举到 $i = p_{1}^{k1-1}p_{2}^{k2}\\dots p_{m}^{km}$的时候，被质数$prime[j] = p_{1}$筛掉。 保证每个合数只被筛一次 假设存在另一个质因数$p_t$$(t\\neq1)$也筛掉了$n$，那么此时$i$就应该等于$p_{1}^{k1}p_{2}^{k2}\\dots p_{t}^{kt-1}\\dots p_{m}^{km}$。 但注意到，$i$也被$p_1$整除，那么在内层for循环枚举$j$，当枚举到$prime[j] = p_1$时，便根据语句i % prime[j] == 0跳出内层循环，根本枚举不到$prime[j] = p_t$，让$p_t$筛掉$n$。 时间复杂度：$\\mathcal{O}(n)$","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://orzyt.cn/categories/算法与数据结构/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://orzyt.cn/tags/算法/"},{"name":"数论","slug":"数论","permalink":"https://orzyt.cn/tags/数论/"}]}]}