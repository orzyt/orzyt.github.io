<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-01-25T07:02:26.073Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-01-25T07:02:26.073Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="./fr_system.png" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="./arch.png" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="./archs.png" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="./loss.png" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="./lfw.png" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="./triplet_loss.png" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="./center_loss.png" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="./center_invariant_loss.png" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="./l_softmax.png" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="./a_softmax.png" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="./am_softmax.png" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="./lmc.png" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="./arcface.png" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="./ring_loss.png" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/LeetCode575-Distribute-Candies/"/>
    <id>https://orzyt.cn/posts/LeetCode575-Distribute-Candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/LeetCode566-Reshape-the-Matrix/"/>
    <id>https://orzyt.cn/posts/LeetCode566-Reshape-the-Matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/LeetCode563-Binary-Tree-Tilt/"/>
    <id>https://orzyt.cn/posts/LeetCode563-Binary-Tree-Tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/LeetCode561-Array-Partition-I/"/>
    <id>https://orzyt.cn/posts/LeetCode561-Array-Partition-I/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/LeetCode557-Reverse-Words-in-a-String-III/"/>
    <id>https://orzyt.cn/posts/LeetCode557-Reverse-Words-in-a-String-III/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ssh本地端口转发的应用</title>
    <link href="https://orzyt.cn/posts/ssh-port-forwarding/"/>
    <id>https://orzyt.cn/posts/ssh-port-forwarding/</id>
    <published>2018-01-13T07:34:17.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;SSH有三种端口转发模式，&lt;strong&gt;本地端口转发(Local Port Forwarding)&lt;/strong&gt;，&lt;strong&gt;远程端口转发(Remote Port Forwarding)&lt;/strong&gt;以及&lt;strong&gt;动态端口转发(Dynamic Port Forwarding)&lt;/strong&gt;。本文只简单介绍&lt;strong&gt;本地端口转发&lt;/strong&gt;，用于实现本机访问远程服务器上的&lt;code&gt;jupyter notebook&lt;/code&gt;、&lt;code&gt;TensorBoard&lt;/code&gt;等服务。&lt;/p&gt;
&lt;h2 id=&quot;什么是本地端口转发？&quot;&gt;&lt;a href=&quot;#什么是本地端口转发？&quot; class=&quot;headerlink&quot; title=&quot;什么是本地端口转发？&quot;&gt;&lt;/a&gt;什么是本地端口转发？&lt;/h2&gt;&lt;p&gt;所谓本地端口转发，就是&lt;strong&gt;将发送到本地端口的请求，转发到目标端口&lt;/strong&gt;。这样，就可以通过访问本地端口，来访问目标端口的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="端口转发" scheme="https://orzyt.cn/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="jupyter notebook" scheme="https://orzyt.cn/tags/jupyter-notebook/"/>
    
      <category term="tensorboard" scheme="https://orzyt.cn/tags/tensorboard/"/>
    
  </entry>
  
  <entry>
    <title>简化ssh连接服务器流程</title>
    <link href="https://orzyt.cn/posts/ssh-login/"/>
    <id>https://orzyt.cn/posts/ssh-login/</id>
    <published>2018-01-13T03:02:26.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>登录远程服务器一般采用<code>ssh</code>（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。</p><h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h2><p>在本机的终端中执行命令 <code>ssh-keygen</code> ，然后根据提示操作即可在目录（默认为<code>~/.ssh</code>）中生成<code>id_rsa</code>（私钥） 和 <code>id_rsa.pub</code>（公钥）文件。</p><a id="more"></a><h2 id="添加-ssh-config-文件"><a href="#添加-ssh-config-文件" class="headerlink" title="添加 ssh config 文件"></a>添加 ssh config 文件</h2><p>根据下列内容，修改（或新建）本机中的<code>~/.ssh/config</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host fastlogin                 # 随便取个名字，用于登录</span><br><span class="line">    HostName xxx.xxx.xxx.xxx   # 主机地址 </span><br><span class="line">    User username              # 用户名</span><br><span class="line">    Port 1234                  # 端口号</span><br></pre></td></tr></table></figure><h2 id="向服务器中添加公钥"><a href="#向服务器中添加公钥" class="headerlink" title="向服务器中添加公钥"></a>向服务器中添加公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在本机中执行]：将公钥文件上传到服务器的用户目录</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表</span></span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p>配置好之后，只需执行下列命令即可快速登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastlogin 为之前在ssh config中定义的名字</span></span><br><span class="line">ssh fastlogin</span><br></pre></td></tr></table></figure><h2 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h2><p>现在，如果想要复制本机的文件到服务器上，可以更加简便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本机源地址 fastlogin:服务器目标地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;登录远程服务器一般采用&lt;code&gt;ssh&lt;/code&gt;（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。&lt;/p&gt;
&lt;h2 id=&quot;生成-ssh-key&quot;&gt;&lt;a href=&quot;#生成-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;生成 ssh key&quot;&gt;&lt;/a&gt;生成 ssh key&lt;/h2&gt;&lt;p&gt;在本机的终端中执行命令 &lt;code&gt;ssh-keygen&lt;/code&gt; ，然后根据提示操作即可在目录（默认为&lt;code&gt;~/.ssh&lt;/code&gt;）中生成&lt;code&gt;id_rsa&lt;/code&gt;（私钥） 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;（公钥）文件。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="scp" scheme="https://orzyt.cn/tags/scp/"/>
    
  </entry>
  
  <entry>
    <title>常用软件更换国内镜像源</title>
    <link href="https://orzyt.cn/posts/change-mirrors/"/>
    <id>https://orzyt.cn/posts/change-mirrors/</id>
    <published>2018-01-13T02:45:51.000Z</published>
    <updated>2018-11-10T11:47:16.927Z</updated>
    
    <content type="html"><![CDATA[<hr><p>由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。</p><p>以下基于<code>Ubuntu</code>系统介绍相应的换源方式。</p><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>修改（或新建）文件：<code>~/.pip/pip.conf</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。&lt;/p&gt;
&lt;p&gt;以下基于&lt;code&gt;Ubuntu&lt;/code&gt;系统介绍相应的换源方式。&lt;/p&gt;
&lt;h2 id=&quot;pip&quot;&gt;&lt;a href=&quot;#pip&quot; class=&quot;headerlink&quot; title=&quot;pip&quot;&gt;&lt;/a&gt;pip&lt;/h2&gt;&lt;p&gt;修改（或新建）文件：&lt;code&gt;~/.pip/pip.conf&lt;/code&gt;，添加以下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[global]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index-url = https://pypi.tuna.tsinghua.edu.cn/simple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pip" scheme="https://orzyt.cn/tags/pip/"/>
    
      <category term="npm" scheme="https://orzyt.cn/tags/npm/"/>
    
      <category term="anaconda" scheme="https://orzyt.cn/tags/anaconda/"/>
    
      <category term="镜像源" scheme="https://orzyt.cn/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode543 Diameter of Binary Tree</title>
    <link href="https://orzyt.cn/posts/LeetCode543-Diameter-of-Binary-Tree/"/>
    <id>https://orzyt.cn/posts/LeetCode543-Diameter-of-Binary-Tree/</id>
    <published>2018-01-09T05:14:50.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">      </span><br><span class="line">Output:</span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的直径</p><p>普通树的直径需要<a href="https://www.cnblogs.com/wuyiqi/archive/2012/04/08/2437424.html" target="_blank" rel="noopener">两遍DFS</a>，而二叉树因为结构特殊只需一次DFS即可</p><p>假设二叉树中共有$n$个节点，第$i$个节点的左子树树高为$l_i$，右子树树高为$r_i$，则以第$i$个节点为子树的直径$d_i = l_i + r_i  $，最终整棵二叉树的直径$D = max\{d_i | i=1..n\}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> dep - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归求解左子树深度及右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> l = dfs(u-&gt;left, dep + <span class="number">1</span>), r = dfs(u-&gt;right, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 因为当前深度是相对于root来说的，如果相对于u来说，其左右子树树高需要减去u的深度</span></span><br><span class="line">        <span class="comment">// 即 d = l - dep + r - dep = l + r - 2 * dep</span></span><br><span class="line">        ans = max(ans, l + r - <span class="number">2</span> * dep);</span><br><span class="line">        <span class="keyword">return</span> max(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the &lt;strong&gt;longest&lt;/strong&gt; path between any two nodes in a tree. This path may or may not pass through the root.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The length of path between two nodes is represented by the number of edges between them.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode541 Reverse String II</title>
    <link href="https://orzyt.cn/posts/LeetCode541-Reverse-String-II/"/>
    <id>https://orzyt.cn/posts/LeetCode541-Reverse-String-II/</id>
    <published>2018-01-09T05:04:49.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><p><strong>Restrictions:</strong></p><ol><li>The string consists of lower English letters only.</li><li>Length of the given string and k will in the range [1, 10000]</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个字符串和一个整数$k$，需要每$2k$个字符就把前$k$个字符翻转，如果少于$k$个字符就都翻转，如果多等于$k$个而于少于$2k$个字符，就翻转前$k$个而剩下的不变。</p><p>按题意模拟一下即可…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; i += <span class="number">2</span>*k) rev(s, i, min(i + k - <span class="number">1</span>, siz - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restrictions:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The string consists of lower English letters only.&lt;/li&gt;
&lt;li&gt;Length of the given string and k will in the range [1, 10000]&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode530 Minimum Absolute Difference in BST</title>
    <link href="https://orzyt.cn/posts/LeetCode530-Minimum-Absolute-Difference-in-BST/"/>
    <id>https://orzyt.cn/posts/LeetCode530-Minimum-Absolute-Difference-in-BST/</id>
    <published>2018-01-09T04:50:30.000Z</published>
    <updated>2018-11-10T11:47:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary search tree with non-negative values, find the minimum <a href="https://en.wikipedia.org/wiki/Absolute_difference" target="_blank" rel="noopener">absolute difference</a> between values of any two nodes.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求节点为非负整数的二叉搜索树中，任意两个节点绝对差值的最小值。</p><p>根据二叉搜索树的性质，对其进行中序遍历即可得到一个有序（从小到大）的结果。由于结果是有序的，因此只需要考虑相邻两个元素之间的差值来获得最小值。</p><p>比如对如下的二叉搜索树进行中序遍历，得到 <code>[3, 5, 7, 8, 10]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> /   \</span><br><span class="line">3     8</span><br><span class="line">     / \</span><br><span class="line">    7  10</span><br></pre></td></tr></table></figure><p>然后答案即为相邻元素的最小差值，ans = min {<code>5-3</code>, <code>7-5</code>, <code>8-7</code>, <code>10-8</code>} = 1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans, pre;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        ans = min(ans, root-&gt;val - pre);</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = INT_MAX; </span><br><span class="line">        pre = <span class="number">-0x3f3f3f3f</span>; <span class="comment">// 记录中序遍历时当前节点的前驱</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary search tree with non-negative values, find the minimum &lt;a href=&quot;https://en.wikipedia.org/wiki/Absolute_difference&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;absolute difference&lt;/a&gt; between values of any two nodes.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="BST" scheme="https://orzyt.cn/tags/BST/"/>
    
      <category term="二叉搜索树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode155 Min Stack</title>
    <link href="https://orzyt.cn/posts/LeetCode155-Min-Stack/"/>
    <id>https://orzyt.cn/posts/LeetCode155-Min-Stack/</id>
    <published>2018-01-02T04:47:09.000Z</published>
    <updated>2018-11-10T11:47:16.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>模拟一个栈，在<strong>常数时间</strong>内支持<code>进栈push</code>、<code>出栈pop</code>、<code>输出栈顶元素top</code>、<code>输出栈内最小元素getMin</code>四种操作</p><p>我们知道，普通的栈对于前三种操作已经是常数时间了，但是如何实现常数时间内找到栈内最小元素呢？</p><p>可能一开始会想，不是可以$\mathcal{O}(1)$维护一个栈内最小元素的下标吗？<code>getMin</code>的时候直接根据下标输出不就好了</p><p>emm…是这样的没错。但是，一旦最小元素出栈后，我们就得找出栈内第二小元素来更新下标 </p><p>这个该怎么处理呢，肯定不能把栈遍历一遍啊（时间复杂度不满足要求…</p><hr><p>其实，只要维护一个<strong>单调栈</strong>即可（非严格单调递减），单调栈的栈顶就是<strong>原栈中最小的元素</strong></p><p>其中stack A为原栈，stack B为辅助栈，# 表示栈底方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">stack A: # | 10 |               // 元素10进栈</span><br><span class="line">stack B: # | 10 |               // 当前最小元素为10</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 |          // 元素12进栈</span><br><span class="line">stack B: # | 10 |               // 由于维护的是单调递减栈，当前最小元素仍然为10</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 | 9 |      // 元素9进栈</span><br><span class="line">stack B: # | 10 | 9 |           // 满足单调栈，当前最小元素更新为9</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 | 9 | 14 | // 元素14进栈</span><br><span class="line">stack B: # | 10 | 9 |           // 不满足单调栈，当前最小元素仍为9</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 | 9 |      // 元素14出栈</span><br><span class="line">stack B: # | 10 | 9 |           // 不影响辅助栈，当前最小元素仍为9</span><br><span class="line"></span><br><span class="line">stack A: # | 10 | 12 |          // 元素9出栈</span><br><span class="line">stack B: # | 10 |               // 辅助栈栈顶的9同时出栈，当前最小元素更新为10</span><br><span class="line"></span><br><span class="line">stack A: # | 10 |               // 元素12出栈</span><br><span class="line">stack B: # | 10 |               // 不影响辅助栈，当前最小元素仍为10</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 原栈进栈的同时，看满不满足辅助栈的单调性质</span></span><br><span class="line">        <span class="keyword">if</span> (b.empty() || x &lt;= getMin()) b.push(x);</span><br><span class="line">        a.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原栈出栈的同时，看影不影响辅助栈的栈顶</span></span><br><span class="line">        <span class="keyword">if</span> (a.top() == getMin()) b.pop();</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出原栈的栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> a.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出辅助栈栈顶元素，即为原栈中的最小元素</span></span><br><span class="line">        <span class="keyword">return</span> b.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) — Push element x onto stack.&lt;/li&gt;
&lt;li&gt;pop() — Removes the element on top of the stack.&lt;/li&gt;
&lt;li&gt;top() — Get the top element.&lt;/li&gt;
&lt;li&gt;getMin() — Retrieve the minimum element in the stack.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="栈" scheme="https://orzyt.cn/tags/%E6%A0%88/"/>
    
      <category term="单调栈" scheme="https://orzyt.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Algorithms&#39; Solutions</title>
    <link href="https://orzyt.cn/posts/leetcode-algorithms-solutions/"/>
    <id>https://orzyt.cn/posts/leetcode-algorithms-solutions/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>“ <strong>Talk is cheap, show me the code!</strong> ”<br>— <em>Linus Torvalds</em></p></blockquote><ul><li>如果题解中有谬误或疑问的地方，欢迎大家留言交流！<a id="more"></a> </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>Title</th><th style="text-align:center">Acceptance</th><th style="text-align:center">Difficulty</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><a href="/posts/LeetCode1-Two-Sum/">Two Sum</a></td><td style="text-align:center">36.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">2</td><td><a href="/posts/LeetCode2-Add-Two-Numbers/">Add Two Numbers</a></td><td style="text-align:center">28.2%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">7</td><td><a href="/posts/LeetCode7-Reverse-Integer/">Reverse Integer</a></td><td style="text-align:center">24.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">8</td><td><a href="/posts/LeetCode8-String-to-Integer-(atoi)/">String to Integer (atoi)</a></td><td style="text-align:center">13.9%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">9</td><td><a href="/posts/LeetCode9-Palindrome-Number/">Palindrome Number</a></td><td style="text-align:center">35.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">13</td><td><a href="/posts/LeetCode13-Roman-to-Integer/">Roman to Integer</a></td><td style="text-align:center">47.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">20</td><td><a href="/posts/LeetCode20-Valid-Parentheses/">Valid Parentheses</a></td><td style="text-align:center">33.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">21</td><td><a href="/posts/LeetCode21-Merge-Two-Sorted-Lists/">Merge Two Sorted Lists</a></td><td style="text-align:center">39.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">27</td><td><a href="/posts/LeetCode27-Remove-Element/">Remove Element</a></td><td style="text-align:center">40.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">28</td><td><a href="/posts/LeetCode28-Implement-strStr/">Implement strStr()</a></td><td style="text-align:center">28.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">35</td><td><a href="/posts/LeetCode35-Search-Insert-Position/">Search Insert Position</a></td><td style="text-align:center">39.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">50</td><td><a href="/posts/LeetCode50-Pow(x,n)/">Pow(x, n)</a></td><td style="text-align:center">26.0%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">53</td><td><a href="/posts/LeetCode53-Maximum-Subarray-Element/">Maximum Subarray</a></td><td style="text-align:center">40.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">69</td><td><a href="/posts/LeetCode69-Sqrt(x)/">Sqrt(x)</a></td><td style="text-align:center">28.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">70</td><td><a href="/posts/LeetCode70-Climbing-Stairs/">Climbing Stairs</a></td><td style="text-align:center">40.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">83</td><td><a href="/posts/LeetCode83-Remove-Duplicates-from-Sorted-List/">Remove Duplicates from Sorted List</a></td><td style="text-align:center">40.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">84</td><td><a href="/posts/LeetCode84-Largest-Rectangle-in-Histogram/">Largest Rectangle in Histogram</a></td><td style="text-align:center">27.3%</td><td style="text-align:center"><span class="label label-danger round"><p style="display: none;">3</p>Hard</span></td></tr><tr><td style="text-align:center">100</td><td><a href="/posts/LeetCode100-Same-Tree/">Same Tree</a></td><td style="text-align:center">47.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">101</td><td><a href="/posts/LeetCode101-Symmetric-Tree/">Symmetric Tree</a></td><td style="text-align:center">39.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">102</td><td><a href="/posts/LeetCode102-Binary-Tree-Level-Order-Traversal/">Binary Tree Level Order Traversal</a></td><td style="text-align:center">41.3%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">104</td><td><a href="/posts/LeetCode104-Maximum-Depth-of-Binary-Tree/">Maximum Depth of Binary Tree</a></td><td style="text-align:center">53.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">107</td><td><a href="/posts/LeetCode107-Binary-Tree-Level-Order-Traversal-II/">Binary Tree Level Order Traversal II</a></td><td style="text-align:center">41.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">108</td><td><a href="/posts/LeetCode108-Convert-Sorted-Array-to-Binary-Search-Tree/">Convert Sorted Array to Binary Search Tree</a></td><td style="text-align:center">43.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">112</td><td><a href="/posts/LeetCode112-Path-Sum/">Path Sum</a></td><td style="text-align:center">34.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">118</td><td><a href="/posts/LeetCode118-Pascals-Triangle/">Pascal’s Triangle</a></td><td style="text-align:center">39.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">119</td><td><a href="/posts/LeetCode119-Pascals-Triangle-II/">Pascal’s Triangle II</a></td><td style="text-align:center">37.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">121</td><td><a href="/posts/LeetCode121-Best-Time-to-Buy-and-Sell-Stock/">Best Time to Buy and Sell Stock</a></td><td style="text-align:center">42.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">122</td><td><a href="/posts/LeetCode122-Best-Time-to-Buy-and-Sell-Stock-II/">Best Time to Buy and Sell Stock II</a></td><td style="text-align:center">47.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">125</td><td><a href="/posts/LeetCode125-Valid-Palindrome/">Valid Palindrome</a></td><td style="text-align:center">26.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">136</td><td><a href="/posts/LeetCode136-Single-Number/">Single Number</a></td><td style="text-align:center">55.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">153</td><td><a href="/posts/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/">Find Minimum in Rotated Sorted Array</a></td><td style="text-align:center">40.5%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">154</td><td><a href="/posts/LeetCode154-Find-Minimum-in-Rotated-Sorted-Array-II/">Find Minimum in Rotated Sorted Array II</a></td><td style="text-align:center">37.6%</td><td style="text-align:center"><span class="label label-danger round"><p style="display: none;">3</p>Hard</span></td></tr><tr><td style="text-align:center">155</td><td><a href="/posts/LeetCode155-Min-Stack/">Min Stack</a></td><td style="text-align:center">30.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">167</td><td><a href="/posts/LeetCode167-Two-Sum-II-Input-array-is-sorted/">Two Sum II - Input array is sorted</a></td><td style="text-align:center">47.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">168</td><td><a href="/posts/LeetCode168-Excel-Sheet-Column-Title/">Excel Sheet Column Title</a></td><td style="text-align:center">26.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">169</td><td><a href="/posts/LeetCode169-Majority-Element/">Majority Element</a></td><td style="text-align:center">47.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">171</td><td><a href="/posts/LeetCode171-Excel-Sheet-Column-Number/">Excel Sheet Column Number</a></td><td style="text-align:center">47.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">172</td><td><a href="/posts/LeetCode172-Factorial-Trailing-Zeroes/">Factorial Trailing Zeroes</a></td><td style="text-align:center">36.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">189</td><td><a href="/posts/LeetCode189-Rotate-Array/">Rotate Array</a></td><td style="text-align:center">25.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">190</td><td><a href="/posts/LeetCode190-Reverse-Bits/">Reverse Bits</a></td><td style="text-align:center">29.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">191</td><td><a href="/posts/LeetCode191-Number-of-1-Bits/">Number of 1 Bits</a></td><td style="text-align:center">40.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">202</td><td><a href="/posts/LeetCode202-Happy-Number/">Happy Number</a></td><td style="text-align:center">41.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">204</td><td><a href="/posts/LeetCode204-Count-Primes/">Count Primes</a></td><td style="text-align:center">26.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">206</td><td><a href="/posts/LeetCode206-Reverse-Linked-List/">Reverse Linked List</a></td><td style="text-align:center">46.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">217</td><td><a href="/posts/LeetCode217-Contains-Duplicate/">Contains Duplicate</a></td><td style="text-align:center">46.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">226</td><td><a href="/posts/LeetCode226-Invert-Binary-Tree/">Invert Binary Tree</a></td><td style="text-align:center">52.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">231</td><td><a href="/posts/LeetCode231-Power-of-Two/">Power of Two</a></td><td style="text-align:center">40.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">237</td><td><a href="/posts/LeetCode237-Delete-Node-in-a-Linked-List/">Delete Node in a Linked List</a></td><td style="text-align:center">47.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">242</td><td><a href="/posts/LeetCode242-Valid-Anagram/">Valid Anagram</a></td><td style="text-align:center">47.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">258</td><td><a href="/posts/LeetCode258-Add-Digits/">Add Digits</a></td><td style="text-align:center">51.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">263</td><td><a href="/posts/LeetCode263-Ugly-Number/">Ugly Number</a></td><td style="text-align:center">39.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">264</td><td><a href="/posts/LeetCode264-Ugly-Number-II/">Ugly Number II</a></td><td style="text-align:center">33.1%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">268</td><td><a href="/posts/LeetCode268-Missing-Number/">Missing Number</a></td><td style="text-align:center">44.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">278</td><td><a href="/posts/LeetCode278-First-Bad-Version/">First Bad Version</a></td><td style="text-align:center">25.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">283</td><td><a href="/posts/LeetCode283-Move-Zeroes/">Move Zeroes</a></td><td style="text-align:center">50.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">292</td><td><a href="/posts/LeetCode292-Nim-Game/">Nim Game</a></td><td style="text-align:center">55.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">303</td><td><a href="/posts/LeetCode303-Range-Sum-Query-Immutable/">Range Sum Query - Immutable</a></td><td style="text-align:center">31.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">307</td><td><a href="/posts/LeetCode307-Range-Sum-Query-Mutable/">Range Sum Query - Mutable</a></td><td style="text-align:center">21.7%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">326</td><td><a href="/posts/LeetCode326-Power-of-Three/">Power of Three</a></td><td style="text-align:center">40.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">338</td><td><a href="/posts/LeetCode338-Counting-Bits/">Counting Bits</a></td><td style="text-align:center">61.9%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">342</td><td><a href="/posts/LeetCode342-Power-of-Four/">Power of Four</a></td><td style="text-align:center">38.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">344</td><td><a href="/posts/LeetCode344-Reverse-String/">Reverse String</a></td><td style="text-align:center">59.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">345</td><td><a href="/posts/LeetCode345-Reverse-Vowels-of-a-String/">Reverse Vowels of a String</a></td><td style="text-align:center">38.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">349</td><td><a href="/posts/LeetCode349-Intersection-of-Two-Arrays/">Intersection of Two Arrays</a></td><td style="text-align:center">47.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">350</td><td><a href="/posts/LeetCode350-Intersection-of-Two-Arrays-II/">Intersection of Two Arrays II</a></td><td style="text-align:center">44.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">367</td><td><a href="/posts/LeetCode367-Valid-Perfect-Square/">Valid Perfect Square</a></td><td style="text-align:center">38.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">371</td><td><a href="/posts/LeetCode371-Sum-of-Two-Integers/">Sum of Two Integers</a></td><td style="text-align:center">51.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">383</td><td><a href="/posts/LeetCode383-Ransom-Note/">Ransom Note</a></td><td style="text-align:center">47.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">387</td><td><a href="/posts/LeetCode387-First-Unique-Character-in-a-String/">First Unique Character in a String</a></td><td style="text-align:center">47.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">389</td><td><a href="/posts/LeetCode389-Find-the-Difference/">Find the Difference</a></td><td style="text-align:center">51.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">401</td><td><a href="/posts/LeetCode401-Binary-Watch/">Binary Watch</a></td><td style="text-align:center">44.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">404</td><td><a href="/posts/LeetCode404-Sum-of-Left-Leaves/">Sum of Left Leaves</a></td><td style="text-align:center">47.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">405</td><td><a href="/posts/LeetCode405-Convert-a-Number-to-Hexadecimal/">Convert a Number to Hexadecimal</a></td><td style="text-align:center">41.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">409</td><td><a href="/posts/LeetCode409-Longest-Palindrome/">Longest Palindrome</a></td><td style="text-align:center">45.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">412</td><td><a href="/posts/LeetCode412-Fizz-Buzz/">Fizz Buzz</a></td><td style="text-align:center">58.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">413</td><td><a href="/posts/LeetCode413-Arithmetic-Slices/">Arithmetic Slices</a></td><td style="text-align:center">54.6%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">414</td><td><a href="/posts/LeetCode414-Third-Maximum-Number/">Third Maximum Number</a></td><td style="text-align:center">28.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">415</td><td><a href="/posts/LeetCode415-Add-Strings/">Add Strings</a></td><td style="text-align:center">41.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">419</td><td><a href="/posts/LeetCode419-Battleships-in-a-Board/">Battleships in a Board</a></td><td style="text-align:center">62.5%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">437</td><td><a href="/posts/LeetCode437-Path-Sum-III/">Path Sum III</a></td><td style="text-align:center">40.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">442</td><td><a href="/posts/LeetCode442-Find-All-Duplicates-in-an-Array/">Find All Duplicates in an Array</a></td><td style="text-align:center">56.6%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">447</td><td><a href="/posts/LeetCode447-Number-of-Boomerangs/">Number of Boomerangs</a></td><td style="text-align:center">45.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">448</td><td><a href="/posts/LeetCode448-Find-All-Numbers-Disappeared-in-an-Array/">Find All Numbers Disappeared in an Array</a></td><td style="text-align:center">51.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">451</td><td><a href="/posts/LeetCode451-Sort-Characters-By-Frequency/">Sort Characters By Frequency</a></td><td style="text-align:center">51.4%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">453</td><td><a href="/posts/LeetCode453-Minimum-Moves-to-Equal-Array-Elements/">Minimum Moves to Equal Array Elements</a></td><td style="text-align:center">47.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">455</td><td><a href="/posts/LeetCode455-Assign-Cookies/">Assign Cookies</a></td><td style="text-align:center">47.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">459</td><td><a href="/posts/LeetCode459-Repeated-Substring-Pattern/">Repeated Substring Pattern</a></td><td style="text-align:center">38.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">461</td><td><a href="/posts/LeetCode461-Hamming-Distance/">Hamming Distance</a></td><td style="text-align:center">69.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">463</td><td><a href="/posts/LeetCode463-Island-Perimeter/">Island Perimeter</a></td><td style="text-align:center">57.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">476</td><td><a href="/posts/LeetCode476-Number-Complement/">Number Complement</a></td><td style="text-align:center">61.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">479</td><td><a href="/posts/LeetCode479-Largest-Palindrome-Product/">Largest Palindrome Product</a></td><td style="text-align:center">24.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">485</td><td><a href="/posts/LeetCode485-Max-Consecutive-Ones/">Max Consecutive Ones</a></td><td style="text-align:center">54.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">492</td><td><a href="/posts/LeetCode492-Construct-the-Rectangle/">Construct the Rectangle</a></td><td style="text-align:center">48.3%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">496</td><td><a href="/posts/LeetCode496-Next-Greater-Element-I/">Next Greater Element I</a></td><td style="text-align:center">56.6%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">500</td><td><a href="/posts/LeetCode500-Keyboard-Row/">Keyboard Row</a></td><td style="text-align:center">59.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">501</td><td><a href="/posts/LeetCode501-Find-Mode-in-Binary-Search-Tree/">Find Mode in Binary Search Tree</a></td><td style="text-align:center">37.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">504</td><td><a href="/posts/LeetCode504-Base-7/">Base 7</a></td><td style="text-align:center">44.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">506</td><td><a href="/posts/LeetCode506-Relative-Ranks/">Relative Ranks</a></td><td style="text-align:center">46.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">513</td><td><a href="/posts/LeetCode513-Find-Bottom-Left-Tree-Value/">Find Bottom Left Tree Value</a></td><td style="text-align:center">56.1%</td><td style="text-align:center"><span class="label label-warning round"><p style="display: none;">2</p>Medium</span></td></tr><tr><td style="text-align:center">520</td><td><a href="/posts/LeetCode520-Detect-Capital/">Detect Capital</a></td><td style="text-align:center">52.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">530</td><td><a href="/posts/LeetCode530-Minimum-Absolute-Difference-in-BST/">Minimum Absolute Difference in BST</a></td><td style="text-align:center">47.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">541</td><td><a href="/posts/LeetCode541-Reverse-String-II/">Reverse String II</a></td><td style="text-align:center">43.7%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">543</td><td><a href="/posts/LeetCode543-Diameter-of-Binary-Tree/">Diameter of Binary Tree</a></td><td style="text-align:center">44.9%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">557</td><td><a href="/posts/LeetCode557-Reverse-Words-in-a-String-III/">Reverse Words in a String III</a></td><td style="text-align:center">59.8%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">561</td><td><a href="/posts/LeetCode561-Array-Partition-I/">Array Partition I</a></td><td style="text-align:center">66.5%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">563</td><td><a href="/posts/LeetCode563-Binary-Tree-Tilt/">Binary Tree Tilt</a></td><td style="text-align:center">47.1%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">566</td><td><a href="/posts/LeetCode566-Reshape-the-Matrix/">Reshape the Matrix</a></td><td style="text-align:center">58.2%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">575</td><td><a href="/posts/LeetCode575-Distribute-Candies/">Distribute Candies</a></td><td style="text-align:center">58.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">669</td><td><a href="/posts/LeetCode669-Trim-a-Binary-Search-Tree/">Trim a Binary Search Tree</a></td><td style="text-align:center">58.4%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr><tr><td style="text-align:center">671</td><td><a href="/posts/LeetCode671-Second-Minimum-Node-In-a-Binary-Tree/">Second Minimum Node In a Binary Tree</a></td><td style="text-align:center">42.0%</td><td style="text-align:center"><span class="label label-success round"><p style="display: none;">1</p>Easy</span></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;“ &lt;strong&gt;Talk is cheap, show me the code!&lt;/strong&gt; ”&lt;br&gt;— &lt;em&gt;Linus Torvalds&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果题解中有谬误或疑问的地方，欢迎大家留言交流！
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://orzyt.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>条件生成对抗网络(Conditional GANs)</title>
    <link href="https://orzyt.cn/posts/conditional-gan/"/>
    <id>https://orzyt.cn/posts/conditional-gan/</id>
    <published>2017-12-26T04:39:58.000Z</published>
    <updated>2018-11-10T11:47:16.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在原始的生成对抗网络论文中，作者指出了一个可能的拓展:</p><blockquote><p>A conditional generative model $p(x|c)$ can be obtained by adding $c$ as input to both $G$ and $D$</p></blockquote><p>于是同年11月，Mirza等人便提出了<a href="https://arxiv.org/abs/1411.1784" target="_blank" rel="noopener">Conditional Generative Adversarial Networks</a>，这是一种带条件约束的生成模型。<br><a id="more"></a><br>它在生成器 $G$ 和 判别器 $D$ 中均引入了条件变量 $y$，这里 $y$ 可以是任何的辅助信息（比如说，类别标签、其它模态的数据等等）。使用这个额外的条件变量，对生成器数据的生成具有指导作用。因此，该项工作可以看成是把无监督的GAN变成有监督模型的一种改进。</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p><img src="https://tuchuang001.com/images/2017/12/27/cgan.png" alt="Conditional GANs的基本框架" width="60%" height="60%"></p><p><code>Conditional GANs</code>的基本框架非常地简单，只需在原始GAN的生成器和判别器的输入中，加入额外的条件信息即可。</p><p>显然地，目标函数改为：</p><script type="math/tex; mode=display">\mathop{\min}_{G}\mathop{\max}_{D}V(D,G)=\mathbb{E}_{\boldsymbol{x}\sim p_{\text{data}}}\left[\log D(\boldsymbol{x}|\boldsymbol{y})\right]+\mathbb{E}_{\boldsymbol{z}\sim p_z(\boldsymbol{z})}\left[\log(1-D(G(\boldsymbol{z}|\boldsymbol{y})|\boldsymbol{y}))\right]</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在论文中，作者做了两个实验，一个是单模态的<code>MNIST</code>手写数字生成，另一个是基于多模态的图像自动标注。</p><p><img src="https://tuchuang001.com/images/2017/12/27/mnist.png" alt="mnist手写数字生成(论文原图)" width="70%" height="70%"></p><p>在<code>MNIST</code>数据集的实验中，生成器 $G$ 的输入分为两部分：</p><ul><li>噪声 $z$：<code>100维</code> 服从均匀分布的向量</li><li>条件 $y$：类别标签的<code>one hot编码</code></li></ul><p>然后将噪声 $z$ 和 标签 $y$ 分别映射到隐层(<strong>200</strong>和<strong>1000units</strong>)，在映射到第二层前，连接所有<strong>1200units</strong>。最终，用一个<code>sigmoid</code>层输出<strong>784</strong>维(<strong>28*28</strong>)的单通道图像。</p><p>判别器 $D$ 把输入图像 $x$ 映射到一个有<strong>240units</strong>和<strong>5pieces</strong>的<code>maxout layer</code>，把标签 $y$ 映射到有<strong>50units</strong>和<strong>5pieces</strong>的<code>maxout layer</code>。同时，把所有隐层连接成为一个有<strong>240units</strong>和<strong>4pieces</strong>的<code>maxout layer</code>。最后送入<code>sigmoid</code>层，该层的输出即为在条件 $y$ 下，输入图像 $x$ 为真实样本的概率。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Github地址：<a href="https://github.com/orzyt/Generative-Adversarial-Nets/tree/master/conditional-gan" target="_blank" rel="noopener">(orzyt/Generative-Adversarial-Nets/conditional-gan)</a></p><p>具体实现细节与论文有所不同，网络架构使用的是<a href="https://arxiv.org/abs/1511.06434" target="_blank" rel="noopener">DCGAN</a>，效果会比论文中的好（毕竟DCGAN是在CGAN之后才提出的…</p><p>让我们看下代码跑出来的效果</p><p><img src="https://tuchuang001.com/images/2017/12/27/mnist.gif" alt="mnist手写数字生成(实测效果)" width="60%" height="60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在原始的生成对抗网络论文中，作者指出了一个可能的拓展:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A conditional generative model $p(x|c)$ can be obtained by adding $c$ as input to both $G$ and $D$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是同年11月，Mirza等人便提出了&lt;a href=&quot;https://arxiv.org/abs/1411.1784&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Conditional Generative Adversarial Networks&lt;/a&gt;，这是一种带条件约束的生成模型。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://orzyt.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="cgan" scheme="https://orzyt.cn/tags/cgan/"/>
    
      <category term="conditional gan" scheme="https://orzyt.cn/tags/conditional-gan/"/>
    
      <category term="条件生成对抗网络" scheme="https://orzyt.cn/tags/%E6%9D%A1%E4%BB%B6%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>生成对抗网络(Generative Adversarial Nets)</title>
    <link href="https://orzyt.cn/posts/generative-adversarial-nets/"/>
    <id>https://orzyt.cn/posts/generative-adversarial-nets/</id>
    <published>2017-12-18T23:16:14.000Z</published>
    <updated>2018-11-10T11:47:16.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>生成对抗网络</strong>（Generative Adversarial Nets, GANs）是由 Ian Goodfellow 等人于2014年6月提出的一种生成模型，至今仍是非常热门的研究方向。深度学习领域泰斗级人物 Yann LeCun 曾如此评价道：<em>“GANs and the variations that are now being proposed is the most interesting idea in the last 10 years in ML, in my opinion.”</em>，从中可见GAN的强大之处！</p><a id="more"></a><hr><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>生成对抗网络的主要框架基于博弈论中的<a href="https://en.wikipedia.org/wiki/Zero-sum_game" target="_blank" rel="noopener">二人零和博弈游戏</a>（zero-sum game）</p><p>在该游戏中，两位博弈方的利益之和为零或一个常数，即一方有所得，另一方必有所失。而在生成对抗网络中，这两个博弈的角色分别为：<strong>生成器</strong>（generator）和<strong>判别器</strong>（discriminator），作用如下：</p><p>生成器 $G$：接受随机噪声（noise）输入，生成尽可能真实的样本<br>判别器 $D$：接受任意样本 $x$，输出 $D(x)$ 代表 $x$ 为真实样本的概率</p><p>在训练过程中，生成器 $G$ 的目标就是<strong>尽量生成真实的样本去欺骗判别器$D$</strong>，而判别器 $D$ 的目标就是<strong>尽量把生成器$G$生成的假样本和真实的样本区分开来</strong>。如此一来，生成器 $G$ 和判别器 $D$ 就构成了一个动态的“博弈过程”</p><p>在理想的情况下，博弈的结果是：<strong>生成器 $G$ 所拟合的分布 $p_\it{g}$ 可以无限接近于真实样本中的分布 $p_\it{data}$</strong> ，足以生成以假乱真的样本。而判别器 $D$ 无法再区分出样本的真假，因此对任意样本 $x$ ，都有 $D(x)=\frac{1}{2}$</p><p>最终，我们得到了一个生成模型 $G$！</p><p><img src="https://tuchuang001.com/images/2017/12/19/2.png" alt="GAN的基本框架"></p><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>GAN的优化目标函数如下：</p><script type="math/tex; mode=display">\min_G \max_D V(D, G) = \mathbb{E}_{x \sim p_{data}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D(G(z)))] \tag{1}</script><p>其中，</p><ul><li>$x$：真实样本</li><li>$p_{data}(x)$：真实样本的分布</li><li>$z$：随机噪声</li><li>$p_{z}(z)$：随机噪声的分布，一般采用<em>高斯分布</em></li><li>$G(z)$：生成器根据随机噪声 $z$ 生成的假样本</li><li>$D(x)$：样本 $x$ 为真实样本的概率</li></ul><p>上述目标函数是一个<strong>极小化极大</strong>的过程。对于判别器 $D$ 来说，它的目标是极大化 $V(D, G)$，那么必然导致 $D(x) \to 1$ 且 $D(G(z)) \to 0$，也就是前面提到的尽可能把生成的假样本和真样本正确地区分开来。而对于生成器 $G$ 来说，它的目标是极小化最优的判别器，同样地，有 $D(G(z)) \to 1$，即生成器尽量生成真实的样本去欺骗判别器</p><hr><p>那么，对于固定的生成器 $G$，最优的判别器 $D^*$ 是多少呢？</p><script type="math/tex; mode=display">\begin{align}D^* &= \max_D V(D, G) \nonumber \\&= \max_D \mathbb{E}_{x \sim p_{data}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D(G(z))] \nonumber \\&= \max_D \mathbb{E}_{x \sim p_{data}(x)}[\log D(x)] + \mathbb{E}_{x \sim p_{G}(x)}[\log (1 - D(x))] \nonumber \\ &= \max_D \int_x P_{data}(x) \log D(x)dx + \int_x P_{G}(x) \log (1-D(x))dx \nonumber \\ &= \max_D \int_x \left[ P_{data}(x) \log D(x)+ P_{G}(x) \log (1-D(x)) \right]dx \nonumber \\\end{align}</script><p>想要极大化 $V(D, G)$，那么对每一个样本 $x$，都令 $P_{data}(x) \log D(x)+ P_{G}(x) \log (1-D(x))$ 取到极大值即可。</p><p>由于给定了 $x$, 那么 $P_{data}(x)$ 和 $P_{G}(x)$ 都为定值，分别记作 $a$ 和 $b$<br>对于函数 $f(D)=a\log D + b\log (1-D)$，令 $\frac{df(D)}{dD} = a \cdot \frac{1}{D}-b \cdot \frac{1}{1-D} = 0 $，解得 $D^* = \frac{a}{a + b} = \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}$</p><p>即对于固定的生成器 $G$，最优的判别器为</p><script type="math/tex; mode=display">D^*  = \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)} \tag{2}</script><hr><p>现在，考虑生成器 $G$ 的目标，极小化最优的判别器，得到最优生成器 $G^*$</p><script type="math/tex; mode=display">\begin{align}G^* &= \min_G V(D^*, G) \nonumber \\&= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log D^*(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D^*(G(z))] \nonumber \\&= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log D^*(x)] + \mathbb{E}_{x \sim p_{G}(x)}[\log (1 - D^*(x))] \nonumber \\ &= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}] + \mathbb{E}_{x \sim p_{G}(x)}[\log (1 - \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)})] \nonumber \\ &= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log \frac{P_{data}(x)}{P_{data}(x) + P_{G}(x)}] + \mathbb{E}_{x \sim p_{G}(x)}[\log ( \frac{P_{G}(x)}{P_{data}(x) + P_{G}(x)})] \nonumber \\ &= \min_G \mathbb{E}_{x \sim p_{data}(x)}[\log \frac{P_{data}(x)}{\frac{P_{data}(x) + P_{G}(x)}{2}}] + \mathbb{E}_{x \sim p_{G}(x)}[\log ( \frac{P_{G}(x)}{\frac{P_{data}(x) + P_{G}(x)}{2}})] -2\log2 \nonumber \\ &= \min_G KL(P_{data}||\frac{P_{data}(x) + P_{G}(x)}{2}) + KL(P_{G}||\frac{P_{data}(x) + P_{G}(x)}{2}) - 2\log2 \nonumber \\&= \min_G 2JS(P_{data}||P_{G}) - 2\log 2 \tag{3} \end{align}</script><p>其中，$KL$表示<a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence" target="_blank" rel="noopener">Kullback–Leibler divergence</a>，$JS$表示<a href="https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence" target="_blank" rel="noopener">Jensen–Shannon divergence</a>，都是用来度量两个分布的相似性<br>对于$JS$散度来说，其取值范围为$[0, \log2]$，当且仅当两个分布相等时取到最小值0</p><p>因此，最优生成器 $G^* = \min_G 2JS(P_{data}||P_{G}) - 2\log 2$ ，当且仅当 $P_{data} = P_{G}$ 时，取到最小值 $-2\log2$</p><hr><p>由上述分析可知，该极小化极大的博弈对抗过程确实可以让生成器学习到真实的数据分布！</p><hr><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>根据前面 $V(D,G)$ 的定义，我们需要求两个数学期望，即 $\mathbb{E}_{x \sim p_{data}(x)}[\log D(x)]$ 和 $\mathbb{E}_{z \sim p_{z}(z)}[\log (1 - D(G(z)))]$。但在实践中，我们是没办法利用积分来求这两个数学期望的，所以一般只能从数据集中做采样以逼近真实的数学期望</p><script type="math/tex; mode=display">\tilde{V}(D, G) = \frac{1}{m} \sum_{i=1}^{m} \log D(\boldsymbol{x}^i) + \frac{1}{m} \sum_{i=1}^{m} \log (1 - D(G(\boldsymbol{z}^i))</script><p><img src="https://tuchuang001.com/images/2017/12/19/3.png" alt="GAN的算法流程"></p><hr><p><strong>训练判别器</strong> $D$ （训练 $k$ 次）：<br>每次采样一组噪声变量 $\{z^1,z^2, \dots,z^m\}$ 和 一组真实数据 $\{x^1,x^2, \dots,x^m\}$，计算 $\theta_d$ 的梯度：</p><script type="math/tex; mode=display">\nabla_{\boldsymbol{\theta}_d} \frac{1}{m} \sum_{i=1}^{m} \left[ \log(D(\boldsymbol{x}^i)) + \log(1 - D(G(\boldsymbol{z}^i))) \right]</script><p>然后使用<strong>梯度上升</strong>算法更新$\theta_d$</p><p><strong>训练生成器</strong> $G$ （训练 $1$ 次）：<br>每次采样一组噪声变量 $\{z^1,z^2, \dots,z^m\}$，计算 $\theta_g$ 的梯度：</p><script type="math/tex; mode=display">\nabla_{\boldsymbol{\theta}_g} \frac{1}{m} \sum_{i=1}^{m} \log(1 - D(G(\boldsymbol{z}^i)))</script><p>然后使用<strong>梯度下降</strong>算法更新$\theta_g$</p><hr><blockquote><p>Q：<em>为什么判别器要训练k次，而生成器才训练1次？</em><br>A：因为优化生成器D的前提是判别器G要达到最优的状态。如果判别器比较弱的话，那么它将给生成器错误的引导，使得生成器的优化方向不对</p><p>Q：<em>为什么生成器的梯度只有后一项？</em><br>A：因为 $\tilde{V}$ 的前一项与参数 $\theta_g$ 无关</p></blockquote><hr><p>此外在论文中，作者针对生成器的训练提出了一个 “<strong>$-\log(D)$ trick</strong>“：<br><em>将最小化 $\log (1-D(G(z)))$ 改为 最小化 $-\log D(G(z))$</em></p><p>我们先来观察一下二者的函数图像</p><p><img src="https://tuchuang001.com/images/2017/12/19/5.jpg" alt="log(1-D(x))和-log(x)函数图像"></p><p>作者指出，在训练的早期，判别器 $G$ 可以轻易地区分出假样本，使得$D(G(z)) \to 0$。观察图像发现，$\log (1-D(x))$这个函数在 $x \to 0$ 时比较平滑，梯度也比较小，这就会导致生成器 $G$ 的训练变得十分地缓慢。而改为优化 $-\log(D(x))$ 后，在训练的早期能提供比较高的梯度，从而提高了训练速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;生成对抗网络&lt;/strong&gt;（Generative Adversarial Nets, GANs）是由 Ian Goodfellow 等人于2014年6月提出的一种生成模型，至今仍是非常热门的研究方向。深度学习领域泰斗级人物 Yann LeCun 曾如此评价道：&lt;em&gt;“GANs and the variations that are now being proposed is the most interesting idea in the last 10 years in ML, in my opinion.”&lt;/em&gt;，从中可见GAN的强大之处！&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://orzyt.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GAN" scheme="https://orzyt.cn/tags/GAN/"/>
    
      <category term="生成对抗网络" scheme="https://orzyt.cn/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用TensorFlow实现逻辑回归</title>
    <link href="https://orzyt.cn/posts/use-tensorflow-to-implement-logistic-regression/"/>
    <id>https://orzyt.cn/posts/use-tensorflow-to-implement-logistic-regression/</id>
    <published>2017-12-02T03:31:49.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><blockquote><p>使用TensorFlow实现小批量梯度下降的逻辑回归。<br>数据集：<a href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html" target="_blank" rel="noopener"><code>moons dataset</code></a><br><em>— From《Hands-on Machine Learning with Scikit-Learn and TensorFlow》Chapter9 Exercise12</em></p></blockquote><a id="more"></a><hr><p><strong>*附加功能：</strong></p><blockquote><p>• 在<code>logistic_regression()</code>函数中定义计算图，以便复用<br>• 在训练的时候定期保存检查点，并在训练结束的时候保存最终的模型<br>• 若训练中断，则从检查点中恢复<br>• 使用命名域来定义图<br>• 增加summaries日志记录，在TensorBoard中可视化学习曲线<br>•  调参（如，学习率、批数据大小等）并观察学习曲线</p></blockquote><hr><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>首先载入数据集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons</span><br><span class="line">m = <span class="number">1000</span>  <span class="comment"># 样本数量</span></span><br><span class="line"><span class="comment"># 载入数据集</span></span><br><span class="line">X_moons, y_moons = make_moons(m, noise=<span class="number">0.1</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure></p><p>接着将数据集可视化，以便有一个直观的感受<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># y_moons == 1提取正样本的索引</span></span><br><span class="line">plt.plot(X_moons[y_moons == <span class="number">1</span>, <span class="number">0</span>], X_moons[y_moons == <span class="number">1</span>, <span class="number">1</span>], <span class="string">'go'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">plt.plot(X_moons[y_moons == <span class="number">0</span>, <span class="number">0</span>], X_moons[y_moons == <span class="number">0</span>, <span class="number">1</span>], <span class="string">'r^'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/12/02/moons_dataset.png" alt="moons dataset"></p><p>为每个样本在第0维上添加<code>bias</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加bias</span></span><br><span class="line">X_moons_with_bias = np.c_[np.ones((m, <span class="number">1</span>)), X_moons]</span><br></pre></td></tr></table></figure></p><p>标签形状需要从<code>(m, )</code>reshape为<code>(m, 1)</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据标签从 1-D reshape成 2-D</span></span><br><span class="line">y_moons_column_vector = y_moons.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>从整个数据集中以<code>8:2</code>的比例，划分出训练集和测试集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试集占整个数据集的比例</span></span><br><span class="line">test_ratio = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试样本数量</span></span><br><span class="line">test_size = int(m * test_ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集</span></span><br><span class="line">X_train = X_moons_with_bias[:-test_size]</span><br><span class="line">y_train = y_moons_column_vector[:-test_size]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分测试集</span></span><br><span class="line">X_test = X_moons_with_bias[-test_size:]</span><br><span class="line">y_test = y_moons_column_vector[-test_size:]</span><br></pre></td></tr></table></figure></p><p>定义一个随机划分批数据函数，方便后续训练<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_batch</span><span class="params">(X_train, y_train, batch_size)</span>:</span></span><br><span class="line">    <span class="string">''' # 随机划分批数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X_train: 整个训练集样本</span></span><br><span class="line"><span class="string">    :param y_train: 整个训练集标签</span></span><br><span class="line"><span class="string">    :param batch_size: 每个batch的大小</span></span><br><span class="line"><span class="string">    :return: 样本和标签的批数据</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    rnd_indices = np.random.randint(<span class="number">0</span>, len(X_train), size=batch_size)</span><br><span class="line">    X_batch = X_train[rnd_indices]</span><br><span class="line">    y_batch = y_train[rnd_indices]</span><br><span class="line">    <span class="keyword">return</span> X_batch, y_batch</span><br></pre></td></tr></table></figure></p><hr><h2 id="构造计算图阶段"><a href="#构造计算图阶段" class="headerlink" title="构造计算图阶段"></a>构造计算图阶段</h2><p>moons dataset的特征只有2个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特征数量</span></span><br><span class="line">n_inputs = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>构造计算图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入数据</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_inputs + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权值初始化</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n_inputs + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>, seed=<span class="number">42</span>), name=<span class="string">'theta'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算logits</span></span><br><span class="line">logits = tf.matmul(X, theta, name=<span class="string">'logits'</span>)</span><br></pre></td></tr></table></figure></p><p>sigmod函数的计算方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一（根据定义）</span></span><br><span class="line">y_proba = <span class="number">1</span> / (<span class="number">1</span> + tf.exp(-logits))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二（内建函数）</span></span><br><span class="line">y_proba = tf.sigmoid(logits)</span><br></pre></td></tr></table></figure></p><p>计算逻辑回归的损失函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一（根据定义）</span></span><br><span class="line">epsilon = <span class="number">1e-7</span> <span class="comment"># 避免运算溢出</span></span><br><span class="line">loss = -tf.reduce_mean(y * tf.log(y_proba + epsilon) + (<span class="number">1</span> - y) * tf.log(<span class="number">1</span> - y_proba + epsilon), name = <span class="string">'loss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二（内建函数）</span></span><br><span class="line">loss = tf.losses.log_loss(y, y_proba, epsilon=epsilon)</span><br></pre></td></tr></table></figure></p><p>定义学习率、梯度下降优化器及变量初始化节点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降优化器</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line"><span class="comment"># 训练节点</span></span><br><span class="line">training_op = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure></p><p>训练相关的参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练的epoch次数（即遍历epoch次整个数据集）</span></span><br><span class="line">n_epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次批训练的样本数量</span></span><br><span class="line">batch_size = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成一次epoch所需要的批训练次数</span></span><br><span class="line">n_batches = int(np.ceil(m / batch_size))</span><br></pre></td></tr></table></figure></p><hr><h2 id="运行计算图阶段"><a href="#运行计算图阶段" class="headerlink" title="运行计算图阶段"></a>运行计算图阶段</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">            <span class="comment"># 获取批数据</span></span><br><span class="line">            X_batch, y_batch = random_batch(X_train, y_train, batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        loss_val = loss.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br><span class="line">        <span class="comment"># 每训练100个epoch打印当前的loss值</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch:'</span>, epoch, <span class="string">'\tLoss:'</span>, loss_val)</span><br><span class="line">    <span class="comment"># 在测试集上预测</span></span><br><span class="line">    y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br></pre></td></tr></table></figure><p>将概率大等于0.5的样本预测为正类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_pred = (y_proba_val &gt;= <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></p><hr><h2 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h2><p>使用准确率（precision）和召回率（recall）来评价模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准确率</span></span><br><span class="line">p_score = precision_score(y_test, y_pred)</span><br><span class="line"><span class="comment"># 召回率</span></span><br><span class="line">r_score = recall_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Precision score:'</span>, p_score)</span><br><span class="line">print(<span class="string">'Recall score:'</span>, r_score)</span><br></pre></td></tr></table></figure></p><hr><h2 id="可视化预测结果"><a href="#可视化预测结果" class="headerlink" title="可视化预测结果"></a>可视化预测结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_pred_idx = y_pred.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X_test[y_pred_idx, <span class="number">1</span>], X_test[y_pred_idx, <span class="number">2</span>], <span class="string">'go'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">plt.plot(X_test[~y_pred_idx, <span class="number">1</span>], X_test[~y_pred_idx, <span class="number">2</span>], <span class="string">'r^'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/result1.png" alt="预测结果可视化"></p><hr><h2 id="实现附加功能"><a href="#实现附加功能" class="headerlink" title="实现附加功能"></a>实现附加功能</h2><p>由于逻辑回归是一个线性分类器（从上面可视化的预测结果也可看出），效果不是特别好。<br>因此，我们使用多项式回归，即额外增加4个特征($x_{1}^2$、$x_{2}^2$、$x_{1}^3$、$x_{2}^3$)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加4个特征</span></span><br><span class="line">X_train_enhanced = np.c_[X_train, X_train[:, <span class="number">1</span>] ** <span class="number">2</span>,</span><br><span class="line">                         X_train[:, <span class="number">2</span>] ** <span class="number">2</span>,</span><br><span class="line">                         X_train[:, <span class="number">1</span>] ** <span class="number">3</span>,</span><br><span class="line">                         X_train[:, <span class="number">2</span>] ** <span class="number">3</span>,]</span><br><span class="line">X_test_enhanced = np.c_[X_test,</span><br><span class="line">                        X_test[:, <span class="number">1</span>] ** <span class="number">2</span>,</span><br><span class="line">                        X_test[:, <span class="number">2</span>] ** <span class="number">2</span>,</span><br><span class="line">                        X_test[:, <span class="number">1</span>] ** <span class="number">3</span>,</span><br><span class="line">                        X_test[:, <span class="number">2</span>] ** <span class="number">3</span>,]</span><br></pre></td></tr></table></figure><p>将逻辑回归封装成一个函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression</span><span class="params">(X, y, initializer=None, seed=<span class="number">42</span>, learning_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    <span class="string">''' 逻辑回归</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X: 样本</span></span><br><span class="line"><span class="string">    :param y: 标签</span></span><br><span class="line"><span class="string">    :param initializer: 权值初始化器</span></span><br><span class="line"><span class="string">    :param seed: 随机数种子</span></span><br><span class="line"><span class="string">    :param learning_rate: 学习率</span></span><br><span class="line"><span class="string">    :return: sigmod概率, 损失函数, 训练节点, loss日志记录, 保存器</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    n_inputs_with_bias = int(X.get_shape()[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'logistic_regression'</span>): <span class="comment"># 使用命名域</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'model'</span>):</span><br><span class="line">            <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                initializer = tf.random_uniform([n_inputs_with_bias, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>, seed=seed)</span><br><span class="line">            theta = tf.Variable(initializer, name=<span class="string">'theta'</span>)</span><br><span class="line">            logits = tf.matmul(X, theta)</span><br><span class="line">            y_proba = tf.sigmoid(logits)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">            loss = tf.losses.log_loss(y, y_proba, scope=<span class="string">'loss'</span>)</span><br><span class="line">            optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">            training_op = optimizer.minimize(loss)</span><br><span class="line">            loss_summary = tf.summary.scalar(<span class="string">'log_loss'</span>, loss)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'init'</span>):</span><br><span class="line">            init = tf.global_variables_initializer()</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'save'</span>):</span><br><span class="line">            saver = tf.train.Saver()</span><br><span class="line">    <span class="keyword">return</span> y_proba, loss, training_op, loss_summary, init, saver</span><br></pre></td></tr></table></figure></p><p>构造日志文件目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_dir</span><span class="params">(prefix=<span class="string">''</span>)</span>:</span></span><br><span class="line">    now = datetime.utcnow().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line">    root_logdir = <span class="string">'tf_logs'</span></span><br><span class="line">    <span class="keyword">if</span> prefix:</span><br><span class="line">        prefix += <span class="string">'-'</span></span><br><span class="line">    name = prefix + <span class="string">'run-'</span> + now</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;/&#123;&#125;/'</span>.format(root_logdir, name)</span><br></pre></td></tr></table></figure></p><p>构造计算图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特征数量，注意额外增加了4个特征</span></span><br><span class="line">n_inputs = <span class="number">2</span> + <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件目录</span></span><br><span class="line">logdir = log_dir(<span class="string">'logreg'</span>)</span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_inputs + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装好logistic_regression，直接调用</span></span><br><span class="line">y_proba, loss, training_op, loss_summary, init, saver = logistic_regression(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存计算图结构</span></span><br><span class="line">file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph())</span><br></pre></td></tr></table></figure></p><p>运行计算图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">n_epochs = <span class="number">10001</span></span><br><span class="line">batch_size = <span class="number">50</span></span><br><span class="line">n_batches = int(np.ceil(m / batch_size))</span><br><span class="line"></span><br><span class="line">checkpoint_path = <span class="string">'./tmp/my_logreg_model.ckpt'</span></span><br><span class="line">checkpoint_epoch_path = checkpoint_path + <span class="string">'.epoch'</span></span><br><span class="line">final_model_path = <span class="string">'./my_logreg_model'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 判断checkpoint_epoch_path文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(checkpoint_epoch_path):</span><br><span class="line">        <span class="keyword">with</span> open(checkpoint_epoch_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 文件记录了最后一次保存的epoch编号</span></span><br><span class="line">            start_epoch = int(f.read())</span><br><span class="line">        print(<span class="string">'Training was interrupted. Continuing at epoch'</span>, start_epoch)</span><br><span class="line">        <span class="comment"># 恢复会话</span></span><br><span class="line">        saver.restore(sess, checkpoint_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 重新开始</span></span><br><span class="line">        start_epoch = <span class="number">0</span></span><br><span class="line">        sess.run(init)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(start_epoch, n_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">            X_batch, y_batch = random_batch(X_train_enhanced, y_train, batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 计算每个epoch的loss值及其日志记录</span></span><br><span class="line">        loss_val, summary_str = sess.run([loss, loss_summary], feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)</span><br><span class="line">        <span class="comment"># 追加loss日志记录,注意当前epoch的编号也要记录</span></span><br><span class="line">        file_writer.add_summary(summary_str, epoch)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每500个epoch保存checkpoint</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch:'</span>, epoch, <span class="string">'\tLoss:'</span>, loss_val)</span><br><span class="line">            saver.save(sess, checkpoint_path)</span><br><span class="line">            <span class="comment"># 每次覆盖写入新的epoch编号</span></span><br><span class="line">            <span class="keyword">with</span> open(checkpoint_epoch_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">b'%d'</span> % (epoch + <span class="number">1</span>))</span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 保存最终模型            </span></span><br><span class="line">    saver.save(sess, final_model_path)</span><br><span class="line">    <span class="comment"># 在测试集上进行预测</span></span><br><span class="line">    y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)</span><br><span class="line">    <span class="comment"># 若训练未中断,则删除checkpoint_epoch_path文件</span></span><br><span class="line">    os.remove(checkpoint_epoch_path)</span><br></pre></td></tr></table></figure></p><p>预测结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_pred = (y_proba_val &gt;= <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></p><p>输出准确率和召回率<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Precision score:'</span>, precision_score(y_test, y_pred))</span><br><span class="line">print(<span class="string">'Recall score:'</span>, recall_score(y_test, y_pred))</span><br></pre></td></tr></table></figure></p><p>可视化预测结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_pred_idx = y_pred.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X_test[y_pred_idx, <span class="number">1</span>], X_test[y_pred_idx, <span class="number">2</span>], <span class="string">'go'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">plt.plot(X_test[~y_pred_idx, <span class="number">1</span>], X_test[~y_pred_idx, <span class="number">2</span>], <span class="string">'r^'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://tuchuang001.com/images/2017/12/02/result2.png" alt="可视化预测结果"></p><p>可以看出，增加额外4个特征，能够显著提高预测结果</p><hr><p>开始对<code>learning rate</code>和<code>batch size</code>进行玄学调参…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> reciprocal</span><br><span class="line"></span><br><span class="line">n_search_iterations = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> search_iteration <span class="keyword">in</span> range(n_search_iterations):</span><br><span class="line">    batch_size = np.random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># reciprocal为倒数分布</span></span><br><span class="line">    <span class="comment"># 详见https://en.wikipedia.org/wiki/Reciprocal_distribution</span></span><br><span class="line">    <span class="comment"># 一般来说，如果对超参数的最优量级没把握的话，可以使用该分布进行调参</span></span><br><span class="line">    learning_rate = reciprocal.rvs(<span class="number">0.0001</span>, <span class="number">0.1</span>, random_state=search_iteration)</span><br><span class="line">    </span><br><span class="line">    n_inputs = <span class="number">2</span> + <span class="number">4</span></span><br><span class="line">    logdir = log_dir(<span class="string">'logdir'</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'Iteration'</span>, search_iteration)</span><br><span class="line">    print(<span class="string">'  logdir:'</span>, logdir)</span><br><span class="line">    print(<span class="string">'  batch size:'</span>, batch_size)</span><br><span class="line">    print(<span class="string">'  learning rate:'</span>, learning_rate)</span><br><span class="line">    print(<span class="string">'  training: '</span>, end=<span class="string">''</span>)</span><br><span class="line">    </span><br><span class="line">    X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_inputs + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">    y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line">    </span><br><span class="line">    y_proba, loss, training_op, loss_summary, init, saver = logistic_regression(X, y, learning_rate=learning_rate)</span><br><span class="line">    </span><br><span class="line">    file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph())</span><br><span class="line">    </span><br><span class="line">    n_epochs = <span class="number">10001</span></span><br><span class="line">    n_batches = int(np.ceil(m / batch_size))</span><br><span class="line">    </span><br><span class="line">    final_model_path = <span class="string">'./model/my_logreg_model_%d'</span> % search_iteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(init)</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">            <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">                X_batch, y_batch = random_batch(X_train_enhanced, y_train, batch_size)</span><br><span class="line">                sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">            loss_val, summary_str = sess.run([loss, loss_summary], feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)    </span><br><span class="line">            file_writer.add_summary(summary_str, epoch)</span><br><span class="line">            <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'.'</span>, end=<span class="string">''</span>)</span><br><span class="line">        print()</span><br><span class="line">        </span><br><span class="line">        saver.save(sess, final_model_path)</span><br><span class="line">        </span><br><span class="line">        y_proba_val = y_proba.eval(feed_dict=&#123;X: X_test_enhanced, y: y_test&#125;)</span><br><span class="line">        y_pred = (y_proba_val &gt;= <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">'  Precision:'</span>, precision_score(y_test, y_pred))</span><br><span class="line">        print(<span class="string">'  Recall:'</span>, recall_score(y_test, y_pred))</span><br></pre></td></tr></table></figure><p>打印训练信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Iteration 0</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202101244/</span><br><span class="line">  batch size: 54</span><br><span class="line">  learning rate: 0.00443037524522</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.979797979798</span><br><span class="line">  Recall: 0.979797979798</span><br><span class="line">Iteration 1</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202101623/</span><br><span class="line">  batch size: 22</span><br><span class="line">  learning rate: 0.00178264971514</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.979797979798</span><br><span class="line">  Recall: 0.979797979798</span><br><span class="line">Iteration 2</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202102501/</span><br><span class="line">  batch size: 74</span><br><span class="line">  learning rate: 0.00203228544324</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.969696969697</span><br><span class="line">  Recall: 0.969696969697</span><br><span class="line">Iteration 3</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202102742/</span><br><span class="line">  batch size: 58</span><br><span class="line">  learning rate: 0.00449152382514</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.979797979798</span><br><span class="line">  Recall: 0.979797979798</span><br><span class="line">Iteration 4</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103106/</span><br><span class="line">  batch size: 61</span><br><span class="line">  learning rate: 0.0796323472178</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.980198019802</span><br><span class="line">  Recall: 1.0</span><br><span class="line">Iteration 5</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103417/</span><br><span class="line">  batch size: 92</span><br><span class="line">  learning rate: 0.000463425058329</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.912621359223</span><br><span class="line">  Recall: 0.949494949495</span><br><span class="line">Iteration 6</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103630/</span><br><span class="line">  batch size: 74</span><br><span class="line">  learning rate: 0.0477068184194</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.98</span><br><span class="line">  Recall: 0.989898989899</span><br><span class="line">Iteration 7</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202103916/</span><br><span class="line">  batch size: 58</span><br><span class="line">  learning rate: 0.000169404470952</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.9</span><br><span class="line">  Recall: 0.909090909091</span><br><span class="line">Iteration 8</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202104242/</span><br><span class="line">  batch size: 61</span><br><span class="line">  learning rate: 0.0417146119941</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.980198019802</span><br><span class="line">  Recall: 1.0</span><br><span class="line">Iteration 9</span><br><span class="line">  logdir: tf_logs/logdir-run-20171202104602/</span><br><span class="line">  batch size: 92</span><br><span class="line">  learning rate: 0.000107429229684</span><br><span class="line">  training: .....................</span><br><span class="line">  Precision: 0.882352941176</span><br><span class="line">  Recall: 0.757575757576</span><br></pre></td></tr></table></figure></p><p>  让我们打开<code>TensorBoard</code>观察10次训练的学习曲线</p><p>  <img src="https://tuchuang001.com/images/2017/12/02/result3.png" alt="10次训练的学习曲线"></p><p>  可以看出，第4次（从0开始）的<code>loss</code>值最小<br>  最终，找到的超参数为</p><div class="table-container"><table><thead><tr><th style="text-align:center">超参数</th><th style="text-align:center">取值</th></tr></thead><tbody><tr><td style="text-align:center">learning rate</td><td style="text-align:center">0.0796323472178</td></tr><tr><td style="text-align:center">batch size</td><td style="text-align:center">61</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用TensorFlow实现小批量梯度下降的逻辑回归。&lt;br&gt;数据集：&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;moons dataset&lt;/code&gt;&lt;/a&gt;&lt;br&gt;&lt;em&gt;— From《Hands-on Machine Learning with Scikit-Learn and TensorFlow》Chapter9 Exercise12&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TensorFlow" scheme="https://orzyt.cn/categories/TensorFlow/"/>
    
    
      <category term="机器学习" scheme="https://orzyt.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hands-on ML" scheme="https://orzyt.cn/tags/hands-on-ML/"/>
    
      <category term="逻辑回归" scheme="https://orzyt.cn/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="TensorFlow" scheme="https://orzyt.cn/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Hands-on Machine learning 之 TensorFLow入门</title>
    <link href="https://orzyt.cn/posts/hands-on-ml-up-and-running-tensorflow/"/>
    <id>https://orzyt.cn/posts/hands-on-ml-up-and-running-tensorflow/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2018-11-10T11:47:16.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://blog.rescale.com/wp-content/uploads/2017/02/markblogtensorflow.png" alt=""></p><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener"><strong>TensorFlow</strong></a>是Google在2015年11月份开源的人工智能系统，是之前所开发的深度学习基础架构<code>DistBelief</code>的改进版本，该系统可以被用于语音识别、图像识别等多个领域。本文将介绍<code>TensorFlow</code>的基本概念和常见用法。</p><a id="more"></a><hr><h2 id="创建图并在会话中运行"><a href="#创建图并在会话中运行" class="headerlink" title="创建图并在会话中运行"></a>创建图并在会话中运行</h2><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_036.png" alt="一个简单的数据流图"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入tensorflow</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量x，y及计算节点f</span></span><br><span class="line">x = tf.Variable(<span class="number">3</span>, name=<span class="string">'x'</span>)</span><br><span class="line">y = tf.Variable(<span class="number">4</span>, name=<span class="string">'y'</span>)</span><br><span class="line">f = x * x * y + y + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>值得注意的是，上述代码并没有进行任何的运算，仅仅是创建了一个<code>计算图</code>（computation graph）而已。实际上，连变量都还没有被初始化。</p><p>为了对该计算图进行运算，我们必须创建一个<code>会话</code>（session）。然后在会话中初始化变量，以及计算<code>f</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.Session() <span class="comment"># 创建会话</span></span><br><span class="line">sess.run(x.initializer) <span class="comment"># 初始化变量x</span></span><br><span class="line">sess.run(y.initializer) <span class="comment"># 初始化变量y</span></span><br><span class="line">result = sess.run(f) <span class="comment"># 计算f</span></span><br><span class="line">print(result) <span class="comment"># 打印结果</span></span><br><span class="line">&gt;&gt; <span class="number">42</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sess.close() <span class="comment"># 关闭会话</span></span><br></pre></td></tr></table></figure><p>重复使用<code>sess.run(...)</code>可能有点繁琐，有一个更好的方式是使用python的<a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" target="_blank" rel="noopener"><code>with</code></a>语句。</p><p>在<code>with</code>语句块开始时，创建的会话会成为计算图的默认会话。在语句块结束时，创建的会话也会自动结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个会话并命名为sess</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    x.initializer.run() <span class="comment"># 等同于 sess.run(x.initializer)</span></span><br><span class="line">    y.initializer.run() <span class="comment"># 等同于 sess.run(y.initializer)</span></span><br><span class="line">    result = f.eval() <span class="comment"># result = sess.run(f)</span></span><br></pre></td></tr></table></figure><p>除了手动初始化每个变量，也可以使用<code>global_variables_initializer()</code>函数初始化所有变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，并没有立即将变量初始化，而是创建一个初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run() <span class="comment"># 在这里才真正初始化</span></span><br><span class="line">    result = f.eval()</span><br></pre></td></tr></table></figure><hr><h2 id="管理计算图"><a href="#管理计算图" class="headerlink" title="管理计算图"></a>管理计算图</h2><p>所有创建的<code>节点</code>（node）都会自动添加进默认图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 = tf.Variable(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 判断变量x1所在的图是否是默认图</span></span><br><span class="line">x1.graph <span class="keyword">is</span> tf.get_default_graph()</span><br><span class="line">&gt;&gt; <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>但是，有的时候需要管理多个独立的图。我们便可以创建一个临时的图，并在<code>with</code>语句块内将其设置为默认图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph = tf.Graph() <span class="comment"># 创建图</span></span><br><span class="line"><span class="comment"># 在with内将graph设置为默认图</span></span><br><span class="line"><span class="keyword">with</span> graph.as_default(): </span><br><span class="line">    <span class="comment"># 此时创建的变量应该在图graph里</span></span><br><span class="line">    x2 = tf.Variable(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断x2所在的图，是不是真的在graph里</span></span><br><span class="line">x2.graph <span class="keyword">is</span> graph</span><br><span class="line">&gt;&gt; <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样，判断x2是不是在全局的默认图里(显然不是的)</span></span><br><span class="line">x2.graph <span class="keyword">is</span> tf.get_default_graph()</span><br><span class="line">&gt;&gt; <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>若想要将默认图重置（删除图中所有的节点），可以使用<code>tf.reset_default_graph()</code>函数。</p><hr><h2 id="节点的生命周期"><a href="#节点的生命周期" class="headerlink" title="节点的生命周期"></a>节点的生命周期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的图</span></span><br><span class="line">w = tf.constant(<span class="number">3</span>)</span><br><span class="line">x = w + <span class="number">2</span></span><br><span class="line">y = x + <span class="number">5</span></span><br><span class="line">z = x * <span class="number">3</span></span><br><span class="line"><span class="comment"># 在会话中计算图</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(y.eval()) <span class="comment"># 10</span></span><br><span class="line">    print(z.eval()) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><p>在会话中，为了计算<code>y</code>，会自动检测出<code>y</code>依赖于<code>x</code>，而<code>x</code>又依赖于<code>w</code>。那么，将会依次计算<code>w</code>和<code>x</code>，最后再计算<code>y</code>。而为了计算<code>z</code>，也同样会依次计算<code>w</code>和<code>x</code>。</p><p>注意在此过程中，<code>w</code>和<code>x</code>的值<strong>并不会被重复使用</strong>！也就是说，上述代码总共对<code>w</code>和<code>x</code>计算了两次(即使两次的结果都是一样的)。</p><p>因此，对于同一张图的多次运算，除了<code>tf.Variable()</code>变量外，其他节点的值在一次运行结束后都会被丢弃，不会被重复使用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点类型</th><th style="text-align:center">生命周期</th></tr></thead><tbody><tr><td style="text-align:center"><code>tf.Variable()</code></td><td style="text-align:center">整个会话</td></tr><tr><td style="text-align:center"><code>others</code></td><td style="text-align:center">会话的某次运行</td></tr></tbody></table></div><p>为了高效地求得<code>y</code>和<code>z</code>的值，可以在会话的一次运行内同时计算它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 同时计算y和z，此时w和x只计算一次</span></span><br><span class="line">    y_val, z_val = sess.run([y, z])</span><br><span class="line">    print(y_val) <span class="comment"># 10</span></span><br><span class="line">    print(z_val) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><hr><h2 id="使用TensorFlow进行线性回归"><a href="#使用TensorFlow进行线性回归" class="headerlink" title="使用TensorFlow进行线性回归"></a>使用TensorFlow进行线性回归</h2><p>TensorFlow的操作（operations，记作ops）可以接收任意多个输入，可以产生任意多个输出。</p><p>比如<code>addition</code>和<code>multiplication</code>可以接受2个输入，产生1个输出。<br>而被成为<strong>源操作</strong>（source ops）的<code>Constants</code>和<code>variables</code>，则没有输入。</p><p>其中，输入和输出都是多维数组，称之为<strong>张量</strong>（tensor）。</p><hr><p>接下来，将使用<a href="http://scikit-learn.org/stable/index.html" target="_blank" rel="noopener">sklearn</a>的<a href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.fetch_california_housing.html" target="_blank" rel="noopener">加利福尼亚房屋数据</a>来进行线性回归。</p><p>对于线性回归参数<code>theta</code>的拟合，将使用正规方程（Normal Equation）计算：$\theta = (X^T X)^{-1}X^T y$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_california_housing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入sklearn自带的加利福尼亚房屋数据</span></span><br><span class="line">housing = fetch_california_housing()</span><br><span class="line"><span class="comment"># 样本数及特征数</span></span><br><span class="line">m, n = housing.data.shape</span><br><span class="line"><span class="comment"># 添加bias</span></span><br><span class="line">housing_data_plus_bias = np.c_[np.ones((m, <span class="number">1</span>)), housing.data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的常量节点X和y，分别用来存放样本和标签</span></span><br><span class="line">X = tf.constant(housing_data_plus_bias, dtype=tf.float32, name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.constant(housing.target.reshape(<span class="number">-1</span>, <span class="number">1</span>), dtype=tf.float32, name=<span class="string">'y'</span>)</span><br><span class="line"><span class="comment"># 计算X的转置</span></span><br><span class="line">XT = tf.transpose(X)</span><br><span class="line"><span class="comment"># 使用正规方程计算theta</span></span><br><span class="line">theta = tf.matmul(tf.matmul(tf.matrix_inverse(tf.matmul(XT, X)), XT), y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次注意，上述代码并没有进行实际的运算，只是在构建计算图而已</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 在会话中计算theta的值</span></span><br><span class="line">    theta_value = theta.eval()</span><br></pre></td></tr></table></figure><hr><h2 id="实现梯度下降"><a href="#实现梯度下降" class="headerlink" title="实现梯度下降"></a>实现梯度下降</h2><p>接下来将使用<strong>批梯度下降</strong>（Batch Gradient Descent）方法来进行线性回归参数的拟合。</p><p>使用梯度下降方法一般要先对特征进行<strong>标准化</strong>（normalize，即减均值，除方差）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaled_housing_data = scaler.fit_transform(housing.data)</span><br><span class="line">scaled_housing_data_plus_bias = np.c_[np.ones((m, <span class="number">1</span>)), scaled_housing_data]</span><br></pre></td></tr></table></figure><hr><h3 id="手动计算梯度"><a href="#手动计算梯度" class="headerlink" title="手动计算梯度"></a>手动计算梯度</h3><p>$\theta := \theta - \frac{\alpha}{m} X^{T} (X\theta - \vec{y})$<br>其中，$\alpha$是学习率，$m$是批样本数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">n_epochs = <span class="number">1000</span> <span class="comment"># 遍历1000次数据集</span></span><br><span class="line">learning_rate = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的常量节点X和y，分别用来存放样本和标签</span></span><br><span class="line"><span class="comment"># 特征已经过normalize，并加上了bias</span></span><br><span class="line">X = tf.constant(scaled_housing_data_plus_bias, dtype=tf.float32, name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.constant(housing.target.reshape(<span class="number">-1</span>, <span class="number">1</span>), dtype=tf.float32, name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的变量节点theta，用来存放待求解的参数（使用均匀分布初始化节点）</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>), name=<span class="string">'theta'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建预测节点</span></span><br><span class="line">y_pred = tf.matmul(X, theta, name=<span class="string">'predictions'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建误差节点</span></span><br><span class="line">error = y_pred - y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建损失函数节点，使用均方根误差（mean square error）</span></span><br><span class="line">mse = tf.reduce_mean(tf.square(error), name=<span class="string">'mse'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建梯度计算节点</span></span><br><span class="line">gradients = <span class="number">1</span> / m * tf.matmul(tf.transpose(X), error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建赋值节点，即 theta = theta - learning_rate * gradients</span></span><br><span class="line">training_op = tf.assign(theta, theta - learning_rate * gradients)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建变量初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="comment"># 每100个epoch打印当前的loss值</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch'</span>, epoch, <span class="string">'MSE='</span>, mse.eval())</span><br><span class="line">        <span class="comment"># 进行梯度下降更新参数theta</span></span><br><span class="line">        sess.run(training_op)</span><br><span class="line">    <span class="comment"># 训练完成后，计算最终的theta参数值</span></span><br><span class="line">    best_theta = theta.eval()</span><br></pre></td></tr></table></figure><hr><h3 id="使用autodiff"><a href="#使用autodiff" class="headerlink" title="使用autodiff"></a>使用autodiff</h3><p>在前面的代码中，需要我们事先手动计算好loss function（MSE）的梯度才能进行训练。<br>虽然在线性回归里面求解梯度还不算复杂，但是对于深度神经网络来说，梯度的求解将会让人十分头疼。</p><p>在TensorFlow中，提供了<code>autodiff</code>能够帮助我们自动计算梯度。</p><p>只需将之前的梯度计算替换为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradients = tf.gradients(mse, [theta])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p><code>gradients()</code>函数接受一个操作节点（如，<code>mse</code>损失函数计算节点），以及一系列需要求解梯度的变量（如，<code>theta</code>），最终返回对应的梯度列表。</p><hr><h3 id="使用优化器"><a href="#使用优化器" class="headerlink" title="使用优化器"></a>使用优化器</h3><p>TensorFlow能够自动计算梯度已经很方便了，但是可以将事情变得更加简单——使用优化器。</p><p>比如，使用<strong>梯度下降优化器</strong>（Gardient Descent optimizer）。</p><p>便可以简单地将之前<code>gradients = ...</code>和<code>training_op = ...</code>直接替换成下列方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(mse)</span><br></pre></td></tr></table></figure><hr><h2 id="为训练算法提供数据"><a href="#为训练算法提供数据" class="headerlink" title="为训练算法提供数据"></a>为训练算法提供数据</h2><p>首先，我们将之前的批梯度下降算法改为<strong>小批量梯度下降算法</strong>（Mini-batch Gradient Descent）。<br>那么对于每个batch，我们都需要不断地替换<code>X</code>和<code>y</code>常量节点，来向训练算法提供数据。</p><p>在TensorFlow中，一个典型的做法是使用<code>placeholder</code><strong>占位符节点</strong>。</p><p>占位符节点在创建的时候，只需指定其存放的数据类型（如，floa32等），以及存放的数据维度大小即可。<br>然后，等到训练运行时才真正往占位符里放数据（使用<code>feed_dict</code>参数放数据）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># None 意味着在该维度不限制大小</span></span><br><span class="line">A = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">3</span>))</span><br><span class="line">B = A + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 由于B依赖于A，因此在对B求值的时候，必须先用feed_dict向占位符A提供数据</span></span><br><span class="line">    B_val_1 = B.eval(feed_dict=&#123;A: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]&#125;)</span><br><span class="line">    <span class="comment"># 占位符A的第0维度可以是任意大小</span></span><br><span class="line">    B_val_2 = B.eval(feed_dict=&#123;A: [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(B_val_1)</span><br><span class="line">&gt;&gt; [[ <span class="number">6.</span>  <span class="number">7.</span>  <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">print(B_val_2)</span><br><span class="line">&gt;&gt; [[  <span class="number">9.</span>  <span class="number">10.</span>  <span class="number">11.</span>]</span><br><span class="line">    [ <span class="number">12.</span>  <span class="number">13.</span>  <span class="number">14.</span>]]</span><br></pre></td></tr></table></figure><hr><p>使用<code>placeholder</code>实现小批量梯度下降算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_epochs = <span class="number">10</span> <span class="comment"># 遍历10次数据集</span></span><br><span class="line">learning_rate = <span class="number">0.01</span> <span class="comment"># 学习率</span></span><br><span class="line">batch_size = <span class="number">100</span> <span class="comment"># 批数据大小</span></span><br><span class="line">n_batches = int(np.ceil(m / batch_size)) <span class="comment"># 完成一次epoch所需要的批次数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_batch</span><span class="params">(epoch, batch_index, batch_size)</span>:</span></span><br><span class="line">    <span class="string">''' 获取批数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param epoch: 当前epoch的次数</span></span><br><span class="line"><span class="string">    :param batch_index: 当前batch的序号</span></span><br><span class="line"><span class="string">    :param batch_size: 每个batch的大小</span></span><br><span class="line"><span class="string">    :return: 样本和标签的批数据</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># seed的种子设为：当前batch的总序号</span></span><br><span class="line">    <span class="comment"># 比如，完成一个epoch需要5个batch</span></span><br><span class="line">    <span class="comment"># 当前是第3个epoch的第2个batch</span></span><br><span class="line">    <span class="comment"># 那么这个batch总序号就是3 × 5 + 2 = 17</span></span><br><span class="line">    np.random.seed(epoch * n_batches + batch_index)</span><br><span class="line">    <span class="comment"># 在[0, m)范围内，产生batch_size个索引</span></span><br><span class="line">    indices = np.random.randint(m, size=batch_size)</span><br><span class="line">    <span class="comment"># 根据索引，获取样本的批数据</span></span><br><span class="line">    X_batch = scaled_housing_data_plus_bias[indices]</span><br><span class="line">    <span class="comment"># 根据索引，获取标签的批数据</span></span><br><span class="line">    y_batch = housing.target.reshape(<span class="number">-1</span>, <span class="number">1</span>)[indices]</span><br><span class="line">    <span class="keyword">return</span> X_batch, y_batch</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建TensorFlow的占位符节点X和y，分别用来存放样本和标签</span></span><br><span class="line"><span class="comment"># 第0维度为None则不指定大小，因为样本数需要在运行时确定</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n + <span class="number">1</span>), name=<span class="string">'X'</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TensorFlow的变量节点theta，用来存放待求解的参数（使用均匀分布初始化节点）</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>, seed=<span class="number">42</span>), name=<span class="string">'thete'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建预测节点</span></span><br><span class="line">y_pred = tf.matmul(X, theta, name=<span class="string">'predictions'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建误差节点</span></span><br><span class="line">error = y_pred - y</span><br><span class="line"></span><br><span class="line">＃ 创建损失函数节点，使用均方根误差（mean square error）</span><br><span class="line">mse = tf.reduce_mean(tf.square(error), name=<span class="string">'mse'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建梯度下降优化器节点 及 对应的训练节点</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建变量初始化节点</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init) </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">            <span class="comment"># 获取批数据</span></span><br><span class="line">            X_batch, y_batch = fetch_batch(epoch, batch_index, batch_size)</span><br><span class="line">            <span class="comment"># 由于训练节点依赖于X和y，因此使用feed_dict参数传送一个字典，分别为X和y提供数据</span></span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">    best_theta = theta.eval()</span><br></pre></td></tr></table></figure><hr><h2 id="模型的存储及读取"><a href="#模型的存储及读取" class="headerlink" title="模型的存储及读取"></a>模型的存储及读取</h2><p>模型一旦训练好，那么应该将相关的信息（如，参数、计算图等）存储在硬盘里，方便以后的使用。<br>同样，在模型的训练过程中，应该定时地保存检查点（checkpoint）。这使得模型训练中断之后，可以直接从最后一次检查点开始训练而不是重头开始。</p><hr><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p>只需在计算图<strong>构造阶段</strong>（construction phase）的最后新建一个<code>Saver</code>保存节点即可。<br>然后在<strong>执行阶段</strong>（execution phase），调用其<code>save(sess, path)</code>方法即可将模型保存到<code>path</code>路径下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + <span class="number">1</span>, <span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>), name=<span class="string">"theta"</span>)</span><br><span class="line">[...]</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"><span class="comment"># 在construction phase之后创建Saver node即可</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>: <span class="comment"># 每100个epoch保存checkpoint</span></span><br><span class="line">            save_path = saver.save(sess, <span class="string">'tmp/my_model.ckpt'</span>)</span><br><span class="line">        sess.run(training_op)</span><br><span class="line">    best_theta = theta.eval()</span><br><span class="line">    <span class="comment"># 训练完毕，保存最终模型</span></span><br><span class="line">    save_path = saver.save(sess, <span class="string">'tmp/my_model_final.ckpt'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="读取模型"><a href="#读取模型" class="headerlink" title="读取模型"></a>读取模型</h3><p>首先，还是在构造阶段的最后新建一个<code>Saver</code>保存节点。<br>然后，在执行阶段的开始，调用其<code>restore(sess, path)</code>方法即可将path路径下的模型读取到当前的会话中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">'tmp/my_model_final.ckpt'</span>)</span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><hr><p><code>Saver</code>默认情况下，会存储和读取模型的所有参数。<br>不过，我们也可以指定只保存哪些变量，以及使用什么名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保存theta变量，命名为weights</span></span><br><span class="line">saver = tf.train.Saver(&#123;<span class="string">"weights"</span>: theta&#125;)</span><br></pre></td></tr></table></figure><p><code>Saver</code>默认情况下，也会存储计算图的结构，保存在路径的<code>*.meta</code>文件中。<br>如果需要读取模型的计算图，可以调用<code>tf.train.import_meta_graph()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取模型的计算图</span></span><br><span class="line"><span class="comment"># 这样可以完整地恢复模型，不仅包括模型的参数，还包括模型的计算图结构</span></span><br><span class="line">saver = tf.train.import_meta_graph(<span class="string">"/tmp/my_model_final.ckpt.meta"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"/tmp/my_model_final.ckpt"</span>)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><hr><h2 id="使用TensorBoard进行可视化"><a href="#使用TensorBoard进行可视化" class="headerlink" title="使用TensorBoard进行可视化"></a>使用TensorBoard进行可视化</h2><p>在此之前，我们都是用<code>print</code>函数打印出训练过程。然而，有一个更好的选择是：使用<code>TensorBoard</code>！</p><p>接下来，我们将对线性回归的loss值进行可视化。</p><hr><p>首先，新建一个存放数据的日志目录（使用时间戳作为目录名）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以指定格式获取当前时间</span></span><br><span class="line">now = datetime.utcnow().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line"><span class="comment"># 根目录</span></span><br><span class="line">root_logdir = <span class="string">'tf_logs'</span></span><br><span class="line"><span class="comment"># 日志文件目录</span></span><br><span class="line">logdir = <span class="string">'&#123;&#125;/run-&#123;&#125;/'</span>.format(root_logdir, now)</span><br></pre></td></tr></table></figure><p>其次，在构造阶段的末尾添加以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># summary是TensorBoard的一种二进制日志字符串</span></span><br><span class="line"><span class="comment"># 我们使用它的scalar标量类型（还有其他类型，如tf.summary.image可以可视化图像）</span></span><br><span class="line"><span class="comment"># 参数'MSE'：可视化时变量的名称</span></span><br><span class="line"><span class="comment"># 参数mse：loss function节点</span></span><br><span class="line">mse_summary = tf.summary.scalar(<span class="string">'MSE'</span>, mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FileWriter可以将summaries写进指定的日志文件中</span></span><br><span class="line"><span class="comment"># 参数logdir：指定的日志文件路径</span></span><br><span class="line"><span class="comment"># 参数tf.get_default_graph()：需要可视化的计算图结构</span></span><br><span class="line">file_writer = tf.summary.FileWriter(logdir, tf.get_default_graph())</span><br></pre></td></tr></table></figure><p>最后，在执行阶段添加以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">for</span> batch_index <span class="keyword">in</span> range(n_batches):</span><br><span class="line">    X_batch, y_batch = fetch_batch(epoch, batch_index, batch_size)</span><br><span class="line">    <span class="keyword">if</span> batch_index % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 计算mse_summary的值</span></span><br><span class="line">        summary_str = mse_summary.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        step = epoch * n_batches + batch_index</span><br><span class="line">        <span class="comment"># 将summary添加到日志文件中，同时需要指定当前的step（也就是可视化时的横轴坐标）</span></span><br><span class="line">        file_writer.add_summary(summary_str, step)</span><br><span class="line">    sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># 关闭FileWriter</span></span><br><span class="line">file_writer.close()</span><br></pre></td></tr></table></figure><p>现在，让我们启动<code>TensorBoard</code>！</p><p>首先，在终端中输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tensorboard --logdir tf_logs/</span><br><span class="line">&gt;&gt; Starting TensorBoard on port 6006</span><br><span class="line">   (You can navigate to http://0.0.0.0:6006)</span><br></pre></td></tr></table></figure></p><p>然后，在浏览器中打开<code>http://0.0.0.0:6006/</code> (或<code>http://localhost:6006/</code>)，即可访问TensorBoard！</p><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_037.png" alt="可视化loss值"></p><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_038.png" alt="可视化计算图"></p><hr><h2 id="命名域"><a href="#命名域" class="headerlink" title="命名域"></a>命名域</h2><p>当处理复杂模型的时候，图中可能有成千上万个节点。因此，非常有必要将相关的节点组织起来放到一起。<br>这就需要TensorFlow中的<strong>命名域</strong>（Name Scopes）来管理节点！</p><p>比如，我们可以将之前代码里的<code>error</code>和<code>mse</code>操作节点放在一个名叫<code>loss</code>的命名域里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'loss'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    error = y_pred - y</span><br><span class="line">    mse = tf.reduce_mean(tf.square(error), name=<span class="string">'mse'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(error.op.name)</span><br><span class="line">&gt;&gt; loss/sub</span><br><span class="line">print(mse.op.name)</span><br><span class="line">&gt;&gt; loss/mse</span><br></pre></td></tr></table></figure><p>在TensorBoard中，error和mse将出现在loss命名域内。</p><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_039.png" alt="TensorBoard中的命名域"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a1 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line">a2 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"param"</span>): </span><br><span class="line">    a3 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"param"</span>):     </span><br><span class="line">    a4 = tf.Variable(<span class="number">0</span>, name=<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> (a1, a2, a3, a4):</span><br><span class="line">    print(node.op.name)</span><br><span class="line">    </span><br><span class="line">&gt;&gt; a</span><br><span class="line">   a_1</span><br><span class="line">   param/a</span><br><span class="line">   param_1/a</span><br></pre></td></tr></table></figure><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>假设现在要对多个<code>ReLU</code>（rectified linear units，修正线性单元）输出进行累加。</p><script type="math/tex; mode=display">ReLU_{x,b}(X) = max(X \cdot w + b, 0 )</script><p>由于要计算多次ReLU，所以基于模块化的思想，我们可以将实现ReLU功能的语句单独封装成一个函数以供调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">''' 实现ReLU</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X: 输入样本</span></span><br><span class="line"><span class="string">    :return: 经过ReLU修正后的输出</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    w_shape = (int(X.get_shape()[<span class="number">1</span>]), <span class="number">1</span>)</span><br><span class="line">    w = tf.Variable(tf.random_normal(w_shape), name=<span class="string">'weights'</span>)</span><br><span class="line">    b = tf.Variable(<span class="number">0.0</span>, name=<span class="string">'bias'</span>)</span><br><span class="line">    z = tf.add(tf.matmul(X, w), b, name=<span class="string">'z'</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.maximum(z, <span class="number">0.0</span>, name=<span class="string">'relu'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n_features = <span class="number">3</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_features), name=<span class="string">'X'</span>)</span><br><span class="line"><span class="comment"># 调用5次relu函数</span></span><br><span class="line">relus = [relu(X) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 将5次的结果累加</span></span><br><span class="line">output = tf.add_n(relus, name=<span class="string">'output'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_040.png" alt="ReLU的计算图(good)"></p><hr><p>还可以做得更好…</p><p>我们将之前讲过的命名域加进来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">''' 实现ReLU</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param X: 输入样本</span></span><br><span class="line"><span class="string">    :return: 经过ReLU修正后的输出</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'relu'</span>):</span><br><span class="line">        [...]</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_041.png" alt="ReLU的计算图(better)"></p><hr><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>如果你想让计算图中不同的部分共享一个变量（比如CNN中卷积核的权值），一个可能的操作是将变量作为参数传递过去。但是，当计算图中需要共享的变量非常多时，将变得十分麻烦。</p><p>TensorFlow有一个更好的解决方案是，使用<code>get_variable()</code>函数来创建（或复用）共享变量。<br>而选择创建还是选择复用则是由当前的变量域<code>variable_scope()</code>决定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在relu变量域内创建threshold变量</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>):</span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>, shape=(), initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复用，设置reuse=True</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>, reuse=<span class="keyword">True</span>):</span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一种复用方式</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    scope.reuse_variables() <span class="comment"># 调用scope的reuse_variables方法</span></span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="复用ReLU的阈值"><a href="#复用ReLU的阈值" class="headerlink" title="复用ReLU的阈值"></a>复用ReLU的阈值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="comment"># 存在则复用，不存在则创建</span></span><br><span class="line">    threshold = tf.get_variable(<span class="string">'threshold'</span>, shape=(), initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">    [...]                   </span><br><span class="line">    <span class="keyword">return</span> tf.maximum(z, threshold, name=<span class="string">"max"</span>)</span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, n_features), name=<span class="string">'X'</span>)</span><br><span class="line">relus = []</span><br><span class="line"><span class="keyword">for</span> relu_index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 第一次调用relu时reuse为0，则不复用选择创建变量</span></span><br><span class="line">    <span class="comment"># 后续调用relu则会选择复用变量</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">'relu'</span>, reuse=(relu_index &gt;= <span class="number">1</span>)) <span class="keyword">as</span> scope:</span><br><span class="line">        relus.append(relu(X))</span><br><span class="line">output = tf.add_n(relus, name=<span class="string">'output'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang001.com/images/2017/12/02/Selection_042.png" alt="5个ReLUs共享threshold变量"></p><hr><h3 id="复用CNN卷积层参数"><a href="#复用CNN卷积层参数" class="headerlink" title="复用CNN卷积层参数"></a>复用CNN卷积层参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">input_images = tf.placeholder(tf.float32, shape = (<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了一层卷积神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu</span><span class="params">(input, kernel_shape, bias_shape)</span>:</span></span><br><span class="line">    <span class="comment"># 创建名为weights的变量</span></span><br><span class="line">    weights = tf.get_variable(<span class="string">"weights"</span>, kernel_shape, initializer=tf.random_normal_initializer())</span><br><span class="line">    <span class="comment"># 创建名为biases的变量</span></span><br><span class="line">    biases = tf.get_variable(<span class="string">"biases"</span>, bias_shape, initializer=tf.constant_initializer(<span class="number">0.0</span>))</span><br><span class="line">    conv = tf.nn.conv2d(input, weights, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(conv + biases)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_image_filter</span><span class="params">(input_images)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"conv1"</span>):</span><br><span class="line">        <span class="comment"># 在名为conv1的variable scope下调用一层神经网络，对应的参数名为</span></span><br><span class="line">        <span class="comment"># "conv1/weights", "conv1/biases"</span></span><br><span class="line">        relu1 = conv_relu(input_images, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"conv2"</span>):</span><br><span class="line">        <span class="comment"># 在名为conv2的variable scope下调用一层神经网络，对应的参数名为</span></span><br><span class="line">        <span class="comment"># "conv2/weights", "conv2/biases"</span></span><br><span class="line">        <span class="keyword">return</span> conv_relu(relu1, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"image_filter"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    result1 = my_image_filter(input_images)</span><br><span class="line">    scope.reuse_variables() <span class="comment"># 复用变量</span></span><br><span class="line">    result2 = my_image_filter(input_images)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    image = np.random.rand(<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line">    result1 = sess.run(result1, feed_dict=&#123;input_images: image&#125;)</span><br><span class="line">    result2 = sess.run(result2, feed_dict=&#123;input_images: image&#125;)</span><br><span class="line">    print(result2.all() == result1.all())</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">True</span> </span><br><span class="line"><span class="comment"># 说明第二次的参数没有重新初始化，而是复用了第一次的参数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://blog.rescale.com/wp-content/uploads/2017/02/markblogtensorflow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;TensorFlow&lt;/strong&gt;&lt;/a&gt;是Google在2015年11月份开源的人工智能系统，是之前所开发的深度学习基础架构&lt;code&gt;DistBelief&lt;/code&gt;的改进版本，该系统可以被用于语音识别、图像识别等多个领域。本文将介绍&lt;code&gt;TensorFlow&lt;/code&gt;的基本概念和常见用法。&lt;/p&gt;
    
    </summary>
    
      <category term="TensorFlow" scheme="https://orzyt.cn/categories/TensorFlow/"/>
    
    
      <category term="机器学习" scheme="https://orzyt.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hands-on ML" scheme="https://orzyt.cn/tags/hands-on-ML/"/>
    
      <category term="TensorFlow" scheme="https://orzyt.cn/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>使用WebIDE搭建Hexo云端写作环境</title>
    <link href="https://orzyt.cn/posts/use-hexo-on-coding-webIDE/"/>
    <id>https://orzyt.cn/posts/use-hexo-on-coding-webIDE/</id>
    <published>2017-11-22T23:20:58.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于学习的需要，现在日常使用Ubuntu系统。但是，之前hexo的写作环境是搭建在Win10系统里的，如果想在Ubuntu系统里写博客的话，又得重新搭建环境，耗时耗力！</p><p>本着<code>Setup Once, Write Anywhere</code>的原则，便开始寻找一劳永逸的方法。</p><p>因为本博客是托管在<a href="https://pages.coding.net/" target="_blank" rel="noopener">Coding Pages</a>上的，所以首先看看Coding有没有解决方案。幸运的是，Coding有一款产品叫<a href="https://ide.coding.net/index" target="_blank" rel="noopener">Coding webIDE</a>满足我们的需求！</p><a id="more"></a><blockquote><p>Coding WebIDE 是 Coding 自主研发的在线集成开发环境 (IDE)。用户可以通过 WebIDE 创建项目的工作空间, 进行在线开发, 调试等操作。同时 WebIDE 集成了 Git 代码版本控制, 用户可以选择 Coding、GitHub、BitBucket、Git@OSC 等任意的代码仓库。 WebIDE 还提供了分享开发环境的功能, 用户可以保存当前的开发环境, 分享给团队的其他成员。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>最好有hexo、git、ubuntu等的使用经验</li><li>若没有coding.net的账号，可以<a href="https://coding.net" target="_blank" rel="noopener">点此注册</a></li><li>完善个人资料，即可免费成为<code>银牌会员</code><br>注：银牌会员可以使用一个webIDE工作空间，配置：CPU×1，内存256M，磁盘空间2G</li></ul><h2 id="新建工作空间"><a href="#新建工作空间" class="headerlink" title="新建工作空间"></a>新建工作空间</h2><h3 id="新建工作空间-1"><a href="#新建工作空间-1" class="headerlink" title="新建工作空间"></a>新建工作空间</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_024.png" alt="新建工作空间"></p><h3 id="选择空项目"><a href="#选择空项目" class="headerlink" title="选择空项目"></a>选择空项目</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_025.png" alt="选择空项目"></p><h3 id="填写项目信息并选择配置"><a href="#填写项目信息并选择配置" class="headerlink" title="填写项目信息并选择配置"></a>填写项目信息并选择配置</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_026.png" alt="填写项目信息并选择配置"></p><h3 id="运行工作空间"><a href="#运行工作空间" class="headerlink" title="运行工作空间"></a>运行工作空间</h3><p><img src="https://tuchuang001.com/images/2017/11/23/Selection_028.png" alt="运行工作空间"></p><h2 id="配置工作空间"><a href="#配置工作空间" class="headerlink" title="配置工作空间"></a>配置工作空间</h2><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>点击右侧边栏的<code>Environments</code>选项卡，然后选择使用<code>ide-ttf-hexo</code>环境。</p><p><img src="https://tuchuang001.com/images/2017/11/23/Screenshotfrom2017-11-2317-14-27a3c0a.png" alt="配置hexo环境"></p><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;Your Email&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure><h3 id="配置npm"><a href="#配置npm" class="headerlink" title="配置npm"></a>配置npm</h3><p>hexo的插件需要通过npm安装，换国内的源比较快<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><p>在<code>workspace</code>（即<code>hexo-cloud</code>）目录下，执行下列命令初始化hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>至此，hexo环境已经搭好，并成功初始化！</p><h2 id="预览博客"><a href="#预览博客" class="headerlink" title="预览博客"></a>预览博客</h2><p>写好文章之后，通常需要使用命令<code>hexo s</code>预览博客效果。<br>在本地的话，直接在地址栏输入<code>http://localhost:4000</code>即可预览。<br>但是在云端要怎么访问呢？</p><p>方法是，点击右侧边栏的<code>Access URL</code>选项卡，然后在<code>Port</code>选择使用<code>4000</code>端口。<br>然后点击添加<code>+</code>，会生成一个临时链接（有效期为1个小时），访问该链接即可预览博客。<br><img src="https://tuchuang001.com/images/2017/11/23/Selection_030.png" alt="预览博客"></p><h2 id="（可选）导入原有博客"><a href="#（可选）导入原有博客" class="headerlink" title="（可选）导入原有博客"></a>（可选）导入原有博客</h2><p>上述操作是在webIDE里新建一个hexo博客，但是如何导入已有的博客呢？</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>右键点击文件树空白处，可以选择上传文件。（但是好像不能上传整个目录）</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>由于每次更新博客之后，我都会把博客文件备份在coding的仓库里。所以，现在只需把该仓库clone到webIDE中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 复制原有的博客文件到文件夹 hexo_cloud/blog_backup 下</span><br><span class="line">git clone https://git.coding.net/orzyt/blog_backup.git</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 删除之前初始化的博客文件</span><br><span class="line">sudo rm -rf blog/*</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将blog_backup中的所有文件移到blog中</span><br><span class="line">sudo mv blog_backup/* blog_backup/.[^.]* blog/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装原有博客所依赖的插件</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于学习的需要，现在日常使用Ubuntu系统。但是，之前hexo的写作环境是搭建在Win10系统里的，如果想在Ubuntu系统里写博客的话，又得重新搭建环境，耗时耗力！&lt;/p&gt;
&lt;p&gt;本着&lt;code&gt;Setup Once, Write Anywhere&lt;/code&gt;的原则，便开始寻找一劳永逸的方法。&lt;/p&gt;
&lt;p&gt;因为本博客是托管在&lt;a href=&quot;https://pages.coding.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding Pages&lt;/a&gt;上的，所以首先看看Coding有没有解决方案。幸运的是，Coding有一款产品叫&lt;a href=&quot;https://ide.coding.net/index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding webIDE&lt;/a&gt;满足我们的需求！&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="webIDE" scheme="https://orzyt.cn/tags/webIDE/"/>
    
      <category term="hexo" scheme="https://orzyt.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
