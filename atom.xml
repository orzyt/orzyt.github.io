<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-02-28T04:59:26.781Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>David Silver强化学习Lecture2：马尔可夫决策过程</title>
    <link href="https://orzyt.cn/posts/markov-decision-processes/"/>
    <id>https://orzyt.cn/posts/markov-decision-processes/</id>
    <published>2019-02-27T07:38:18.000Z</published>
    <updated>2019-02-28T04:59:26.781Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf" target="_blank" rel="noopener">Lecture 2: Markov Decision Processes</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9833386" target="_blank" rel="noopener">David Silver深度强化学习第2课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><h3 id="马尔可夫决策过程简介"><a href="#马尔可夫决策过程简介" class="headerlink" title="马尔可夫决策过程简介"></a>马尔可夫决策过程简介</h3><p><strong>马尔可夫决策过程(Markov Decision Processes, MDPs)</strong>形式上用来描述强化学习中的环境.</p><p>其中,环境是<strong>完全可观测的(fully observable)</strong>,即当前状态可以完全表征过程.</p><p>几乎所有的强化学习问题都能用MDPs来描述：</p><ul><li>最优控制问题可以描述成连续MDPs;</li><li>部分观测环境可以转化成MDPs;</li><li>赌博机问题是只有一个状态的MDPs.</li></ul><hr><h3 id="马尔可夫性质"><a href="#马尔可夫性质" class="headerlink" title="马尔可夫性质"></a>马尔可夫性质</h3><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫性质" width="60%" height="60%"></p><p>马尔科夫性质(Markov Property)表明: <strong>未来只与现在有关,而与过去无关.</strong></p><hr><h3 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h3><p>对于一个马尔可夫状态$S$及其后继状态$S’$,其状态转移概率由下式定义:</p><script type="math/tex; mode=display">\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]</script><p><strong>状态转移矩阵(State Transition Matrix)$\mathcal{P}$</strong>定义了从所有状态$S$转移到所有后继状态$S’$的概率.</p><script type="math/tex; mode=display">\mathcal { P } = \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \dots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n 1 } } & { \cdots } & { \mathcal { P } _ { n n } } \end{array} \right]</script><p>其中,$n$为状态个数,且矩阵的每行和为1.</p><hr><h3 id="马尔可夫过程-1"><a href="#马尔可夫过程-1" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p><strong>马尔可夫过程(Markov Process)</strong>是一个无记忆的随机过程(memoryless random process).</p><p>即,随机状态$S_1, S_2, \dots$序列具有马尔可夫性质.</p><blockquote><p>马尔可夫过程(或马尔可夫链)是一个二元组$&lt;\mathcal{S}, \mathcal{P}&gt;$</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li></ul></blockquote><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l1vm9xkzj20c80act96.jpg" alt="Example: Student Markov Chain" width="50%" height="50%"></p><p>圆圈代表状态, 箭头代表状态之间的转移, 数值代表转移概率.</p><p>状态转移矩阵$\mathcal{P}$如下:</p><script type="math/tex; mode=display">{\mathcal P} =\begin{bmatrix}  & C1 & C2 & C3 &  Pass & Pub & FB & Sleep\\  C1 & &0.5 &  &   & & 0.5 & \\ C2  & & &  0.8 & & & &0.2\\ C3  & & &  & 0.6& 0.4& &\\ Pass  & & &  & & & &1.0\\ Pub  &0.2 & 0.4& 0.4 & & & &\\ FB  &0.1 & &  & & & 0.9 &\\ Sleep  & & &  & & & &1.0 \end{bmatrix}</script><hr><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p><strong>马尔可夫奖励过程(Markov Reward Process, MRP)</strong>是<em>带有奖励的马尔可夫链</em>.</p><blockquote><p>马尔可夫奖励过程是一个四元组&lt;$\mathcal{S}$, $\mathcal{P}$, <font color="red">$\mathcal{R}$</font>, <font color="red">$\mathcal{\gamma}$</font>&gt;</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li><li><font color="red"> $\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right]$ </font></li><li><font color="red"> $\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </font></li></ul></blockquote><p><img src="http://wx1.sinaimg.cn/large/8662e3cegy1g0l2klvnixj20cf0aowf0.jpg" alt="Example: Student MRP" width="50%" height="50%"></p><h3 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h3><blockquote><p><strong>回报(Return)</strong> $G_t$ 是从时间 $t$ 开始的总折扣奖励.</p><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } R _ { t + k + 1 }</script></blockquote><ul><li>折扣因子 $\gamma \in [ 0,1 ]$ 表示未来的奖励在当前的价值. 由于未来的奖励充满不确定性, 因此需要乘上折扣因子;</li><li>$\gamma$ 接近 $0$ 表明更注重当前的奖励(myopic);</li><li>$\gamma$ 接近 $1$ 表明更具有远见(far-sighted).</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function) $v(s)$ 表示一个状态 $s$ 的长期价值(long-term value).</p><blockquote><p>一个马尔可夫奖励过程(MRP)的<strong>状态值函数 $v(s)$</strong>是从状态 $s$ 开始的期望回报.</p><script type="math/tex; mode=display">v ( s ) = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right]</script></blockquote><hr><h3 id="MRPs的贝尔曼方程"><a href="#MRPs的贝尔曼方程" class="headerlink" title="MRPs的贝尔曼方程"></a>MRPs的贝尔曼方程</h3><p>值函数可以被分解为两部分:</p><ul><li>立即奖励 $R_{t+1}$</li><li>后继状态的折扣价值 $\gamma v(S_{t+1})$</li></ul><script type="math/tex; mode=display">\begin{aligned} v ( s ) & = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \gamma ^ { 2 } R _ { t + 3 } + \ldots | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma \left( R _ { t + 2 } + \gamma R _ { t + 3 } + \ldots \right) | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma G _ { t + 1 } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \mathbb { E } \left[ \gamma G _ { t + 1 } | S _ { t } = s \right]\\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \gamma v \left( S _ { t + 1 } \right)\\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v \left( S _ { t + 1 } \right) | S _ { t } = s \right] \end{aligned}\tag{1}\label{eq:mrp-bellman-equation}</script><p>上式表明, $t$ 时刻的状态 $S_t$ 和 $t+1$ 时刻的状态 $S_{t+1}$ 的值函数之间满足递推关系. </p><p>该递推式也称为<strong>贝尔曼方程(Bellman Equation)</strong>.</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0l3fh3jb3j207802zglh.jpg" alt="Bellman Equation for MRPs" width="30%" height="30%"></p><p>如果已知概率转移矩阵 $\mathcal{P}$, 则可将公式\eqref{eq:mrp-bellman-equation}变形为:</p><script type="math/tex; mode=display">v ( s ) = \mathcal { R } _ { s } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } v \left( s ^ { \prime } \right)\tag{2}\label{eq:mrp-bellman-equation-2}</script><p>例子:</p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l3pbm9ixj20c30b5mxp.jpg" alt="Example: Bellman Equation for Student MRP" width="40%" height="40%"></p><p><strong>贝尔曼方程的矩阵形式:</strong></p><p>可将公式\eqref{eq:mrp-bellman-equation-2}改写为矩阵形式:</p><script type="math/tex; mode=display">v = \mathcal { R } + \gamma \mathcal { P } v</script><p>其中, $v$ 为一个列向量, 向量的元素为每个状态的值函数.</p><script type="math/tex; mode=display">\left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right] = \left[ \begin{array} { c } { \mathcal { R } _ { 1 } } \\ { \vdots } \\ { \mathcal { R } _ { n } } \end{array} \right] + \gamma \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \ldots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n1 } } & { \ldots } & { \mathcal { P } _ { n n } } \end{array} \right] \left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right]</script><p>观测贝尔曼方程的矩阵形式, 可知其为线性方程, 可直接求解如下.</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\v & = ( I - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R }\end{aligned}</script><p>计算复杂度为: $\mathcal{O}(n^3)$. 因此, 只适合直接求解小规模的MRP问题.</p><p>对于大规模的MRP问题, 通常采取以下的迭代方法:</p><ul><li>动态规划(Dynamic programming)</li><li>蒙特卡洛评估(Monte-Carlo evaluation)</li><li>时序差分学习(Temporal-Difference learning)</li></ul><hr><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p><strong>马尔可夫决策过程(Markov Decision Process, MDP)</strong>是<em>带有决策的马尔可夫奖励过程</em>.</p><blockquote><p>马尔可夫决策过程是一个五元组&lt;$\mathcal{S}$, <font color="red">$\mathcal{A}$</font>, $\mathcal{P}$, $\mathcal{R}$, $\mathcal{\gamma}$&gt;</p><ul><li>$\mathcal{S}$: 有限的状态集</li><li><font color="red"> $\mathcal{A}$: 有限的动作集</font></li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } ^ {a}= \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } ^ {a} = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </li></ul></blockquote><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0l47drh0vj20g30d93zc.jpg" alt="Example: Student MDP" width="45%" height="45%"></p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote><p><strong>策略(Policy) $\pi$</strong> 是给定状态的动作分布.</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script></blockquote><ul><li>策略完全决定智能体的行为;</li><li>MDP策略值依赖于当前状态(无关历史);</li><li>策略是固定的(与时间无关). $A _ { t } \sim \pi ( \cdot | S _ { t } ) , \forall t &gt; 0$</li></ul><p>给定一个马尔可夫决策过程 $M = &lt;\mathcal{S},\mathcal{A}, \mathcal{P}, \mathcal{R}, \mathcal{\gamma}&gt;$ 和 一个策略 $\pi$, 其可以转化为<em>马尔可夫过程</em>和<em>马尔可夫奖励过程</em>.</p><ul><li><p>状态序列 $S_1, S_2, \dots$ 是马尔科夫决策过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}&gt;$.</p></li><li><p>状态和奖励序列 $S_1, R_2, S_2, \dots$ 是马尔科夫奖励过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$.</p></li></ul><p>其中,</p><script type="math/tex; mode=display">\mathcal{P}_{s,s'}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{P}_{ss'}^{a}</script><script type="math/tex; mode=display">\mathcal{R}_{s}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{R}_{s}^{a}</script><hr><h3 id="值函数-1"><a href="#值函数-1" class="headerlink" title="值函数"></a>值函数</h3><p><strong>值函数(Value Function)</strong>可分为<strong>状态值函数(state-value function)</strong>和<strong>动作值函数(action-value function)</strong>.</p><blockquote><p>MDP的<strong>状态值函数 $v_{\pi}(s)$ </strong>是从状态 $s$ 开始, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ G_t | S_t = s \right]</script><p>MDP的<strong>动作值函数 $q_{\pi}(s, a)$ </strong>是从状态 $s$ 开始, 采取动作 $a$, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ G_t | S_t = s, A_t = a \right]</script></blockquote><hr><h3 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h3><p>状态值函数可以被分解为两部分, <strong>立即奖励 + 后继状态的折扣价值</strong>.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t = s \right]</script><p>动作值函数也可以类似地分解.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma q_{\pi}(S_{t+1}, A_{t+1}) | S_t = s, A_t = a \right]</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0ldl141fkj20bb04xq2x.jpg" width="40%" height="40%"></p><p>上图中, 空心圆圈代表状态, 实心圆圈代表动作.</p><p>在已知策略 $\pi$ 的情况下, 状态值函数 $v_{\pi}(s)$ 可以用动作值函数 $q_{\pi}(s, a)$ 进行表示:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a | s) q_{\pi}(s, a) \tag{3}\label{eq:mdp-state-value-function}</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0lds6jc80j20b004rmx6.jpg" width="40%" height="40%"></p><p>同理, 动作值函数 $q_{\pi}(s, a)$ 也可以用状态值函数 $v_{\pi}(s)$ 进行表示:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s') \tag{4}\label{eq:mdp-action-value-function}</script><hr><p><strong>状态值函数的贝尔曼期望方程:</strong></p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0le5yxgeij20b706hdfx.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-action-value-function}代入公式\eqref{eq:mdp-state-value-function}中, 可得状态值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{\pi}(s')  \right)</script><hr><p><strong>动作值函数的贝尔曼期望方程:</strong></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0le9cf2u7j20bd05wwek.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-state-value-function}代入公式\eqref{eq:mdp-action-value-function}中, 可得动作值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} \sum \limits_{a' \in \mathcal{A}} \pi (a' | s') q_{\pi}(s', a')</script><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lecy0oxgj20h90dcwfj.jpg" alt="状态值函数的贝尔曼期望方程示例" width="55%" height="55%"></p><hr><p><strong>贝尔曼期望方程的矩阵形式:</strong></p><script type="math/tex; mode=display">v_{\pi} = \mathcal{R}^{\pi} + \gamma \mathcal{P}^{\pi} v_{\pi}</script><p>可直接求解:</p><script type="math/tex; mode=display">v_{\pi} = (I - \gamma \mathcal{P}^{\pi})^{-1} \mathcal{R}^{\pi}</script><hr><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><blockquote><p><strong>最优状态值函数(optimal state-value function)</strong> $v_{*}(s)$ 是所有策略中最大的值函数.</p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{\pi}v_{\pi}(s)</script><p><strong>最优动作值函数(optimal action-value function)</strong> $v_{*}(s)$ 是所有策略中最大的动作值函数.</p><script type="math/tex; mode=display">q_{*}(s, a) = \max \limits_{\pi}q_{\pi}(s, a)</script></blockquote><ul><li>最优值函数代表了MDP的最好性能.</li><li>当得知最优值函数时, MDP可被认为”已解决”.</li></ul><hr><p>例子: </p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leoxfaylj20h70ee75c.jpg" alt="Student MDP中的最优状态值函数" width="50%" height="50%"></p><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leqk38l4j20hh0eg75i.jpg" alt="Student MDP中的最优动作值函数" width="50%" height="50%"></p><p>注: 根据公式\eqref{eq:mdp-state-value-function}, Pub动作的最优值应为 $q_{*} = +1 + (0.2 \times 6 + 0.4 \times 8 + 0.4 \times 10) = 9.4$.</p><hr><h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><p>首先定义策略之间的偏序关系, 使得策略之间可以进行比较:</p><script type="math/tex; mode=display">\pi \geq \pi ' \quad \text{if} \quad  v_{\pi}(s) \geq v_{\pi '}(s) , \forall s</script><p>对于任意的MDP来说:</p><ul><li>存在一个最优策略 $\pi_{*}$, 使得 $\pi_{*} \geq \pi, \forall \pi$</li><li>所有的最优策略都能取得最优值函数 $v_{\pi_{*}}(s) = v_{*}(s)$</li><li>所有的最优策略都能取得最优动作值函数 $q_{\pi_{*}}(s, a) = v_{*}(s, a)$</li></ul><hr><p><strong>寻找最优策略</strong></p><p>一个最优策略可以通过最大化所有的 $q_{*}(s, a)$ 得到:</p><script type="math/tex; mode=display">\pi_{*} \left( a | s \right) = \left \{ \begin{array}{ll}1 \ {\mathbb {if}} \ a = \operatorname*{argmax} \limits_{a \in \mathcal{A}} \ q_{*} \left( s,a \right) \\              0 \ {\mathbb {otherwise}}              \end{array} \right.</script><ul><li>对于任意的MDP, 总存在确定的最优策略</li><li>如果我们知道 $q_{*}(s, a)$, 则可以立即得到最优策略</li></ul><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lfhg0710j20hn0ehjsl.jpg" alt="Student MDP的最优策略" width="50%" height="50%"></p><p>图中红色弧线表示每个状态的最优决策.</p><hr><h3 id="贝尔曼最优方程"><a href="#贝尔曼最优方程" class="headerlink" title="贝尔曼最优方程"></a>贝尔曼最优方程</h3><p>$v_{*}$可以通过贝尔曼最优方程递归得到:</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0lfkujh38j20b804uaa2.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{a} q_{*}(s, a)\tag{5}\label{eq:state-bellman-optimal-equation}</script><p>与公式\eqref{eq:mdp-state-value-function}的贝尔曼期望方程进行比较, 此时不再取均值, 而是取最大值.</p><hr><p>$q_{*}$与公式\eqref{eq:mdp-action-value-function}类似:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m10t6s7vj208003a747.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)\tag{6}\label{eq:action-bellman-optimal-equation}</script><hr><p><strong>状态值函数的贝尔曼最优方程</strong></p><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0m14a2fenj208m04xq2x.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:action-bellman-optimal-equation}代入公式\eqref{eq:state-bellman-optimal-equation}可得 $v_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><hr><p><strong>动作值函数的贝尔曼最优方程</strong></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0m18irqg7j208804bgll.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:state-bellman-optimal-equation}代入公式\eqref{eq:action-bellman-optimal-equation}可得 $q_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><hr><p>例子:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m1ato6q2j20d70atjs3.jpg" alt="Student MDP贝尔曼最优方程" width="50%" height="50%"></p><hr><h3 id="贝尔曼最优方程的求解"><a href="#贝尔曼最优方程的求解" class="headerlink" title="贝尔曼最优方程的求解"></a>贝尔曼最优方程的求解</h3><p>贝尔曼最优方程<strong>不是线性的</strong>(因为有取$max$操作), 因此没有封闭解(Closed-form solution).</p><p>通常采用迭代求解方法:</p><ul><li>值迭代(Value Iteration)</li><li>策略迭代(Policy Iteration)</li><li>Q-Learning</li><li>Sarsa</li></ul><h2 id="MDP的扩展"><a href="#MDP的扩展" class="headerlink" title="MDP的扩展"></a>MDP的扩展</h2><ul><li>无穷和连续的MDPs</li><li>部分可观测的MDPs</li><li>不折扣, 平均奖励MDPs</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 2: Markov Decision Processes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9833386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第2课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="马尔可夫决策过程" scheme="https://orzyt.cn/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>David Silver强化学习Lecture1：强化学习简介</title>
    <link href="https://orzyt.cn/posts/introduction-to-rl/"/>
    <id>https://orzyt.cn/posts/introduction-to-rl/</id>
    <published>2019-02-25T14:56:13.000Z</published>
    <updated>2019-02-27T11:03:59.961Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf" target="_blank" rel="noopener">Lecture 1: Introduction to Reinforcement Learning</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9831889" target="_blank" rel="noopener">David Silver深度强化学习第1课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="强化学习的特征"><a href="#强化学习的特征" class="headerlink" title="强化学习的特征"></a>强化学习的特征</h2><p>作为机器学习的一个分支，强化学习主要的特征为:</p><ul><li><p>无监督,仅有奖励信号；</p></li><li><p>反馈有延迟,不是瞬时的;</p></li><li><p>时间是重要的(由于是时序数据,不是独立同分布的);</p></li><li><p>Agent的动作会影响后续得到的数据;</p></li></ul><hr><h2 id="强化学习的概念"><a href="#强化学习的概念" class="headerlink" title="强化学习的概念"></a>强化学习的概念</h2><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>奖励(Rewards) $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何.</p><p><strong>Agent的目标</strong>: 最大化累积奖励(maximise cumulative reward).</p><p>强化学习基于<strong>奖励假设(reward hypothesis)</strong>.</p><blockquote><p><strong>奖励假设(Reward Hypothesis)</strong>:<br>所有强化学习任务的目标都可以被描述为最大化期望累积奖励.</p></blockquote><hr><h3 id="序贯决策"><a href="#序贯决策" class="headerlink" title="序贯决策"></a>序贯决策</h3><p><strong>序贯决策(Sequential Decision Making)的目标</strong>: 选择合适的动作最大化将来的累积奖励.</p><ul><li>动作可能会产生长期后果；</li><li>奖励会有延迟性;</li><li>牺牲立即回报可能会获得更多的长期回报.</li></ul><hr><h3 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k2ozf0lzj20aq0bxtb1.jpg" alt="Agent和环境" width="35%" height="35%"></p><p>智能体(Agent)在每个时刻$t$会:</p><ul><li>执行动作(Action)$A_t$;</li><li>接收观测(Observation)$O_t$;</li><li>接收标量奖励(Reward)$R_t$.</li></ul><p>而环境(Environment)则会:</p><ul><li>接收动作(Action)$A_t$;</li><li>产生观测(Observation)$O_{t+1}$;</li><li>产生标量奖励(Reward)$R_{t+1}$.</li></ul><hr><h3 id="历史与状态"><a href="#历史与状态" class="headerlink" title="历史与状态"></a>历史与状态</h3><blockquote><p><strong>历史(History):</strong>由一系列观测,动作和奖励构成.</p></blockquote><script type="math/tex; mode=display">H_t = O_1, R_1, A_1, \dots, A_{t-1}, O_t, R_t</script><p>下一步将发生什么取决于历史:</p><ul><li>智能体选择的action;</li><li>环境选择的observations/rewards.</li></ul><blockquote><p><strong>状态(State)</strong>:用来决定接下来会发生什么的信息.</p></blockquote><p><strong>状态是历史的函数:</strong></p><script type="math/tex; mode=display">S_t = f(H_t)</script><hr><h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3akygqpj20b20cptb5.jpg" alt="环境状态" width="35%" height="35%"></p><p>环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见.</p><p>即使$S_{t}^{e}$可见,也可能包含不相关信息.</p><hr><h4 id="智能体状态"><a href="#智能体状态" class="headerlink" title="智能体状态"></a>智能体状态</h4><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k3e8bw4aj20b00cx419.jpg" alt="智能体状态" width="35%" height="35%"></p><p>智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息.</p><p>可以写成历史的函数: $S_{t}^{a} = f(H_t)$</p><hr><h4 id="信息状态"><a href="#信息状态" class="headerlink" title="信息状态"></a>信息状态</h4><p><strong>信息状态(也称为马尔科夫状态)</strong>: 包含历史中所有有用的信息.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫状态定义" width="60%" height="60%"></p><p>马尔科夫状态表明: <strong>未来只与现在有关,而与过去无关.</strong></p><p>其中,<strong>环境状态$S_t^e$</strong>和<strong>历史$H_t$</strong>具有马尔科夫性质.</p><hr><h4 id="Rat-Example"><a href="#Rat-Example" class="headerlink" title="Rat Example"></a>Rat Example</h4><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k3trc5qxj20ny0doq88.jpg" alt="Rat Example" width="60%" height="60%"></p><ul><li><p>假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击)</p></li><li><p>假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪)</p></li><li><p>假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知)</p></li></ul><hr><h4 id="完全可观测环境"><a href="#完全可观测环境" class="headerlink" title="完全可观测环境"></a>完全可观测环境</h4><p><strong>完全可观测性(Full observability):</strong> 智能体可以直接观测到环境状态,即</p><script type="math/tex; mode=display">O_t = S_t^a = S_t^e</script><ul><li>智能体状态 = 环境状态 = 信息状态</li><li>实际上是马尔科夫决策过程(Markov Decision Process, MDP)</li></ul><hr><h4 id="部分可观测环境"><a href="#部分可观测环境" class="headerlink" title="部分可观测环境"></a>部分可观测环境</h4><p><strong>部分可观测性(Partial observability):</strong> 智能体不能够直接观测到环境.</p><p>如,机器人不能通过摄像头得知自身的绝对位置.</p><ul><li>智能体状态 $\neq$ 环境状态</li><li>部分可观测马尔科夫决策过程(POMDP)</li></ul><p>此时,智能体必须构建其自身的状态表示 $S_t^a$,比如:</p><ul><li>完全的历史: $S_t^a = H_t$;</li><li>环境状态的置信度: $S _ { t } ^ { a } = \left( \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { 1 } \right] , \ldots , \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { n } \right] \right)$;</li><li>循环神经网络: $S_t^a = \sigma \left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\right)$</li></ul><hr><h2 id="智能体的构成"><a href="#智能体的构成" class="headerlink" title="智能体的构成"></a>智能体的构成</h2><p>智能体主要包含以下几种成分:</p><ul><li><strong>策略(Policy)</strong>: 智能体的行为函数;</li><li><strong>值函数(Value Function)</strong>: 每个state或action的好坏;</li><li><strong>模型(Model)</strong>: 智能体对环境的表示.</li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>策略(Policy)是智能体的行为;</li><li>是<strong>状态</strong>到<strong>动作</strong>的映射;</li><li>确定性策略: $a = \pi(s)$;</li><li>随机性策略: $\pi(a|s) = \mathbb{P} \left[ A_{t} = a | S_{t} = s\right]$</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function)是对于未来奖励的预测.</p><ul><li>用于评价状态的好坏;</li><li>因此可以用来选择动作.</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots | S_{t} = s \right]</script><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型(Model)用来预测环境接下来会做什么.</p><ul><li>$\mathcal{P}$: 预测下一个状态.<script type="math/tex; mode=display">\mathcal{P}_{ss'}^{a} = \mathbb{P} \left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\right]</script></li><li>$\mathcal{R}$: 预测下一个(立即)奖励.<script type="math/tex; mode=display">\mathcal{R}_{s}^{a} = \mathbb{E} \left[ R_{t+1} | S_{t} = s, A_{t} = a\right]</script></li></ul><hr><h3 id="Maze-Example"><a href="#Maze-Example" class="headerlink" title="Maze Example"></a>Maze Example</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k4norup9j20mj092dg5.jpg" alt="Maze Example" width="60%" height="60%"></p><hr><p><strong>策略表示:</strong></p><p>箭头表示每个状态的策略 $\pi(s)$.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k4u9pdcdj20f10c5q38.jpg" alt="Maze Example: Policy" width="40%" height="40%"></p><hr><p><strong>值函数表示:</strong></p><p>数值表示每个状态的值 $v_{\pi}(s)$.</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k4w9vn7wj20f60cct8y.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><p><strong>模型表示:</strong></p><p>智能体可能对环境建立内部模型</p><ul><li>网格布局表示转移模型 $\mathcal{P}_{ss’}^{a}$;</li><li>数值表示每个状态的立即奖励 $\mathcal{R}_{s}^{a}$.</li></ul><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k51h023dj20c109kt8o.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><h3 id="智能体的分类"><a href="#智能体的分类" class="headerlink" title="智能体的分类"></a>智能体的分类</h3><p>按智能体的成分分类:</p><ul><li>基于值函数(Value Based)</li><li>基于策略(Policy Based)</li><li>演员-评论家(Actor Critic)</li></ul><p>或者按有无模型分类:</p><ul><li>无模型(Model Free)</li><li>基于模型(Model Based)</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k55tidg0j20f30eaab9.jpg" alt="智能体分类" width="40%" height="40%"></p><hr><h2 id="强化学习的问题"><a href="#强化学习的问题" class="headerlink" title="强化学习的问题"></a>强化学习的问题</h2><h3 id="学习与规划"><a href="#学习与规划" class="headerlink" title="学习与规划"></a>学习与规划</h3><p><strong>强化学习</strong></p><ul><li>环境的初始状态未知;</li><li>智能体与环境进行交互;</li><li>智能体提升其策略.</li></ul><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0k5dprnn4j20p80ejn0q.jpg" alt="学习" width="60%" height="60%"></p><p><strong>规划</strong></p><ul><li>环境的模型已知;</li><li>智能体通过模型进行计算,无须与外部进行交互;</li><li>智能体提升其策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k5eleerwj20ok0df0u3.jpg" alt="规划" width="60%" height="60%"></p><hr><h3 id="探索和利用"><a href="#探索和利用" class="headerlink" title="探索和利用"></a>探索和利用</h3><p>强化学习是一种试错(trial-and-error)学习.</p><p>智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励.</p><ul><li><strong>探索(Exploration):</strong> 从环境中寻找更多信息;</li><li><strong>利用(Exploitation):</strong> 利用已知信息使奖励最大化.</li></ul><p>探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果.</p><hr><h3 id="预测和控制"><a href="#预测和控制" class="headerlink" title="预测和控制"></a>预测和控制</h3><ul><li><strong>预测(Prediction):</strong> 对未来进行评估.</li></ul><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k5ryo676j20nz0ds0tn.jpg" alt="Gridworld Example: Prediction" width="60%" height="60%"></p><hr><ul><li><strong>控制(Control):</strong> 最优化未来的结果.</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k5r6vdmgj20nv0eot9w.jpg" alt="Gridworld Example: Control" width="60%" height="60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 1: Introduction to Reinforcement Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9831889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第1课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode654 Maximum Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode654-maximum-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode654-maximum-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode637 Average of Levels in Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/average-of-levels-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode661 Image Smoother</title>
    <link href="https://orzyt.cn/posts/leetcode661-image-smoother/"/>
    <id>https://orzyt.cn/posts/leetcode661-image-smoother/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/image-smoother/&quot; t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode657 Robot Return to Origin</title>
    <link href="https://orzyt.cn/posts/leetcode657-robot-return-to-origin/"/>
    <id>https://orzyt.cn/posts/leetcode657-robot-return-to-origin/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-return-to-or
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665 Non-decreasing Array</title>
    <link href="https://orzyt.cn/posts/leetcode665-non-decreasing-array/"/>
    <id>https://orzyt.cn/posts/leetcode665-non-decreasing-array/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/non-decreasing-arr
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617 Merge Two Binary Trees</title>
    <link href="https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/"/>
    <id>https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/</id>
    <published>2019-02-08T09:02:05.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode606 Construct String from Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/</id>
    <published>2019-02-08T09:01:50.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-string-f
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode599 Minimum Index Sum of Two Lists</title>
    <link href="https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
    <id>https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/</id>
    <published>2019-02-08T09:01:34.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-index-sum-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode38 Count and Say</title>
    <link href="https://orzyt.cn/posts/leetcode38-count-and-say/"/>
    <id>https://orzyt.cn/posts/leetcode38-count-and-say/</id>
    <published>2019-02-08T09:00:37.000Z</published>
    <updated>2019-02-08T10:25:59.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/&quot; ta
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-02-26T11:20:51.367Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1j4up5oj21cb0ik489.jpg" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jnv2szj210109oacr.jpg" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jytblsj20of0kgwhp.jpg" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1kfbt7kj217u0e8dlk.jpg" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k1kr4sx8j215r0k9wlm.jpg" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1l9pm84j20x007ht9n.jpg" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lnsllgj20tr0m1qdq.jpg" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lvxp55j20zt0i4n3g.jpg" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1m4b63ij20fv0ib40x.jpg" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k1mg2yrlj20hk0ca0v4.jpg" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mmsrz1j20n808dwfx.jpg" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k1mtlmpmj20ck04sq3j.jpg" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mz40h8j21640ad0wf.jpg" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="https://ws1.sinaimg.cn/large/8662e3cegy1g0k1n6hmq9j20lo09g0wz.jpg" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/leetcode575-distribute-candies/"/>
    <id>https://orzyt.cn/posts/leetcode575-distribute-candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2019-02-08T10:26:00.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/leetcode566-reshape-the-matrix/"/>
    <id>https://orzyt.cn/posts/leetcode566-reshape-the-matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2019-02-08T10:26:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/leetcode563-binary-tree-tilt/"/>
    <id>https://orzyt.cn/posts/leetcode563-binary-tree-tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2019-02-08T10:26:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/leetcode561-array-partition-i/"/>
    <id>https://orzyt.cn/posts/leetcode561-array-partition-i/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2019-02-08T10:26:00.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/"/>
    <id>https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2019-02-08T10:26:00.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ssh本地端口转发的应用</title>
    <link href="https://orzyt.cn/posts/ssh-port-forwarding/"/>
    <id>https://orzyt.cn/posts/ssh-port-forwarding/</id>
    <published>2018-01-13T07:34:17.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;SSH有三种端口转发模式，&lt;strong&gt;本地端口转发(Local Port Forwarding)&lt;/strong&gt;，&lt;strong&gt;远程端口转发(Remote Port Forwarding)&lt;/strong&gt;以及&lt;strong&gt;动态端口转发(Dynamic Port Forwarding)&lt;/strong&gt;。本文只简单介绍&lt;strong&gt;本地端口转发&lt;/strong&gt;，用于实现本机访问远程服务器上的&lt;code&gt;jupyter notebook&lt;/code&gt;、&lt;code&gt;TensorBoard&lt;/code&gt;等服务。&lt;/p&gt;
&lt;h2 id=&quot;什么是本地端口转发？&quot;&gt;&lt;a href=&quot;#什么是本地端口转发？&quot; class=&quot;headerlink&quot; title=&quot;什么是本地端口转发？&quot;&gt;&lt;/a&gt;什么是本地端口转发？&lt;/h2&gt;&lt;p&gt;所谓本地端口转发，就是&lt;strong&gt;将发送到本地端口的请求，转发到目标端口&lt;/strong&gt;。这样，就可以通过访问本地端口，来访问目标端口的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="端口转发" scheme="https://orzyt.cn/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="jupyter notebook" scheme="https://orzyt.cn/tags/jupyter-notebook/"/>
    
      <category term="tensorboard" scheme="https://orzyt.cn/tags/tensorboard/"/>
    
  </entry>
  
  <entry>
    <title>简化ssh连接服务器流程</title>
    <link href="https://orzyt.cn/posts/ssh-login/"/>
    <id>https://orzyt.cn/posts/ssh-login/</id>
    <published>2018-01-13T03:02:26.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>登录远程服务器一般采用<code>ssh</code>（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。</p><h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h2><p>在本机的终端中执行命令 <code>ssh-keygen</code> ，然后根据提示操作即可在目录（默认为<code>~/.ssh</code>）中生成<code>id_rsa</code>（私钥） 和 <code>id_rsa.pub</code>（公钥）文件。</p><a id="more"></a><h2 id="添加-ssh-config-文件"><a href="#添加-ssh-config-文件" class="headerlink" title="添加 ssh config 文件"></a>添加 ssh config 文件</h2><p>根据下列内容，修改（或新建）本机中的<code>~/.ssh/config</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host fastlogin                 # 随便取个名字，用于登录</span><br><span class="line">    HostName xxx.xxx.xxx.xxx   # 主机地址 </span><br><span class="line">    User username              # 用户名</span><br><span class="line">    Port 1234                  # 端口号</span><br></pre></td></tr></table></figure><h2 id="向服务器中添加公钥"><a href="#向服务器中添加公钥" class="headerlink" title="向服务器中添加公钥"></a>向服务器中添加公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在本机中执行]：将公钥文件上传到服务器的用户目录</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表</span></span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p>配置好之后，只需执行下列命令即可快速登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastlogin 为之前在ssh config中定义的名字</span></span><br><span class="line">ssh fastlogin</span><br></pre></td></tr></table></figure><h2 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h2><p>现在，如果想要复制本机的文件到服务器上，可以更加简便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本机源地址 fastlogin:服务器目标地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;登录远程服务器一般采用&lt;code&gt;ssh&lt;/code&gt;（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。&lt;/p&gt;
&lt;h2 id=&quot;生成-ssh-key&quot;&gt;&lt;a href=&quot;#生成-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;生成 ssh key&quot;&gt;&lt;/a&gt;生成 ssh key&lt;/h2&gt;&lt;p&gt;在本机的终端中执行命令 &lt;code&gt;ssh-keygen&lt;/code&gt; ，然后根据提示操作即可在目录（默认为&lt;code&gt;~/.ssh&lt;/code&gt;）中生成&lt;code&gt;id_rsa&lt;/code&gt;（私钥） 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;（公钥）文件。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="scp" scheme="https://orzyt.cn/tags/scp/"/>
    
  </entry>
  
</feed>
