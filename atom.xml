<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-02-28T04:59:26.781Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>David Silver强化学习Lecture2：马尔可夫决策过程</title>
    <link href="https://orzyt.cn/posts/markov-decision-processes/"/>
    <id>https://orzyt.cn/posts/markov-decision-processes/</id>
    <published>2019-02-27T07:38:18.000Z</published>
    <updated>2019-02-28T04:59:26.781Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf" target="_blank" rel="noopener">Lecture 2: Markov Decision Processes</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9833386" target="_blank" rel="noopener">David Silver深度强化学习第2课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><h3 id="马尔可夫决策过程简介"><a href="#马尔可夫决策过程简介" class="headerlink" title="马尔可夫决策过程简介"></a>马尔可夫决策过程简介</h3><p><strong>马尔可夫决策过程(Markov Decision Processes, MDPs)</strong>形式上用来描述强化学习中的环境.</p><p>其中,环境是<strong>完全可观测的(fully observable)</strong>,即当前状态可以完全表征过程.</p><p>几乎所有的强化学习问题都能用MDPs来描述：</p><ul><li>最优控制问题可以描述成连续MDPs;</li><li>部分观测环境可以转化成MDPs;</li><li>赌博机问题是只有一个状态的MDPs.</li></ul><hr><h3 id="马尔可夫性质"><a href="#马尔可夫性质" class="headerlink" title="马尔可夫性质"></a>马尔可夫性质</h3><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫性质" width="60%" height="60%"></p><p>马尔科夫性质(Markov Property)表明: <strong>未来只与现在有关,而与过去无关.</strong></p><hr><h3 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h3><p>对于一个马尔可夫状态$S$及其后继状态$S’$,其状态转移概率由下式定义:</p><script type="math/tex; mode=display">\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]</script><p><strong>状态转移矩阵(State Transition Matrix)$\mathcal{P}$</strong>定义了从所有状态$S$转移到所有后继状态$S’$的概率.</p><script type="math/tex; mode=display">\mathcal { P } = \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \dots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n 1 } } & { \cdots } & { \mathcal { P } _ { n n } } \end{array} \right]</script><p>其中,$n$为状态个数,且矩阵的每行和为1.</p><hr><h3 id="马尔可夫过程-1"><a href="#马尔可夫过程-1" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p><strong>马尔可夫过程(Markov Process)</strong>是一个无记忆的随机过程(memoryless random process).</p><p>即,随机状态$S_1, S_2, \dots$序列具有马尔可夫性质.</p><blockquote><p>马尔可夫过程(或马尔可夫链)是一个二元组$&lt;\mathcal{S}, \mathcal{P}&gt;$</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li></ul></blockquote><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l1vm9xkzj20c80act96.jpg" alt="Example: Student Markov Chain" width="50%" height="50%"></p><p>圆圈代表状态, 箭头代表状态之间的转移, 数值代表转移概率.</p><p>状态转移矩阵$\mathcal{P}$如下:</p><script type="math/tex; mode=display">{\mathcal P} =\begin{bmatrix}  & C1 & C2 & C3 &  Pass & Pub & FB & Sleep\\  C1 & &0.5 &  &   & & 0.5 & \\ C2  & & &  0.8 & & & &0.2\\ C3  & & &  & 0.6& 0.4& &\\ Pass  & & &  & & & &1.0\\ Pub  &0.2 & 0.4& 0.4 & & & &\\ FB  &0.1 & &  & & & 0.9 &\\ Sleep  & & &  & & & &1.0 \end{bmatrix}</script><hr><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p><strong>马尔可夫奖励过程(Markov Reward Process, MRP)</strong>是<em>带有奖励的马尔可夫链</em>.</p><blockquote><p>马尔可夫奖励过程是一个四元组&lt;$\mathcal{S}$, $\mathcal{P}$, <font color="red">$\mathcal{R}$</font>, <font color="red">$\mathcal{\gamma}$</font>&gt;</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li><li><font color="red"> $\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right]$ </font></li><li><font color="red"> $\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </font></li></ul></blockquote><p><img src="http://wx1.sinaimg.cn/large/8662e3cegy1g0l2klvnixj20cf0aowf0.jpg" alt="Example: Student MRP" width="50%" height="50%"></p><h3 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h3><blockquote><p><strong>回报(Return)</strong> $G_t$ 是从时间 $t$ 开始的总折扣奖励.</p><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } R _ { t + k + 1 }</script></blockquote><ul><li>折扣因子 $\gamma \in [ 0,1 ]$ 表示未来的奖励在当前的价值. 由于未来的奖励充满不确定性, 因此需要乘上折扣因子;</li><li>$\gamma$ 接近 $0$ 表明更注重当前的奖励(myopic);</li><li>$\gamma$ 接近 $1$ 表明更具有远见(far-sighted).</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function) $v(s)$ 表示一个状态 $s$ 的长期价值(long-term value).</p><blockquote><p>一个马尔可夫奖励过程(MRP)的<strong>状态值函数 $v(s)$</strong>是从状态 $s$ 开始的期望回报.</p><script type="math/tex; mode=display">v ( s ) = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right]</script></blockquote><hr><h3 id="MRPs的贝尔曼方程"><a href="#MRPs的贝尔曼方程" class="headerlink" title="MRPs的贝尔曼方程"></a>MRPs的贝尔曼方程</h3><p>值函数可以被分解为两部分:</p><ul><li>立即奖励 $R_{t+1}$</li><li>后继状态的折扣价值 $\gamma v(S_{t+1})$</li></ul><script type="math/tex; mode=display">\begin{aligned} v ( s ) & = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \gamma ^ { 2 } R _ { t + 3 } + \ldots | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma \left( R _ { t + 2 } + \gamma R _ { t + 3 } + \ldots \right) | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma G _ { t + 1 } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \mathbb { E } \left[ \gamma G _ { t + 1 } | S _ { t } = s \right]\\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \gamma v \left( S _ { t + 1 } \right)\\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v \left( S _ { t + 1 } \right) | S _ { t } = s \right] \end{aligned}\tag{1}\label{eq:mrp-bellman-equation}</script><p>上式表明, $t$ 时刻的状态 $S_t$ 和 $t+1$ 时刻的状态 $S_{t+1}$ 的值函数之间满足递推关系. </p><p>该递推式也称为<strong>贝尔曼方程(Bellman Equation)</strong>.</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0l3fh3jb3j207802zglh.jpg" alt="Bellman Equation for MRPs" width="30%" height="30%"></p><p>如果已知概率转移矩阵 $\mathcal{P}$, 则可将公式\eqref{eq:mrp-bellman-equation}变形为:</p><script type="math/tex; mode=display">v ( s ) = \mathcal { R } _ { s } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } v \left( s ^ { \prime } \right)\tag{2}\label{eq:mrp-bellman-equation-2}</script><p>例子:</p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l3pbm9ixj20c30b5mxp.jpg" alt="Example: Bellman Equation for Student MRP" width="40%" height="40%"></p><p><strong>贝尔曼方程的矩阵形式:</strong></p><p>可将公式\eqref{eq:mrp-bellman-equation-2}改写为矩阵形式:</p><script type="math/tex; mode=display">v = \mathcal { R } + \gamma \mathcal { P } v</script><p>其中, $v$ 为一个列向量, 向量的元素为每个状态的值函数.</p><script type="math/tex; mode=display">\left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right] = \left[ \begin{array} { c } { \mathcal { R } _ { 1 } } \\ { \vdots } \\ { \mathcal { R } _ { n } } \end{array} \right] + \gamma \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \ldots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n1 } } & { \ldots } & { \mathcal { P } _ { n n } } \end{array} \right] \left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right]</script><p>观测贝尔曼方程的矩阵形式, 可知其为线性方程, 可直接求解如下.</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\v & = ( I - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R }\end{aligned}</script><p>计算复杂度为: $\mathcal{O}(n^3)$. 因此, 只适合直接求解小规模的MRP问题.</p><p>对于大规模的MRP问题, 通常采取以下的迭代方法:</p><ul><li>动态规划(Dynamic programming)</li><li>蒙特卡洛评估(Monte-Carlo evaluation)</li><li>时序差分学习(Temporal-Difference learning)</li></ul><hr><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p><strong>马尔可夫决策过程(Markov Decision Process, MDP)</strong>是<em>带有决策的马尔可夫奖励过程</em>.</p><blockquote><p>马尔可夫决策过程是一个五元组&lt;$\mathcal{S}$, <font color="red">$\mathcal{A}$</font>, $\mathcal{P}$, $\mathcal{R}$, $\mathcal{\gamma}$&gt;</p><ul><li>$\mathcal{S}$: 有限的状态集</li><li><font color="red"> $\mathcal{A}$: 有限的动作集</font></li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } ^ {a}= \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } ^ {a} = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </li></ul></blockquote><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0l47drh0vj20g30d93zc.jpg" alt="Example: Student MDP" width="45%" height="45%"></p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote><p><strong>策略(Policy) $\pi$</strong> 是给定状态的动作分布.</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script></blockquote><ul><li>策略完全决定智能体的行为;</li><li>MDP策略值依赖于当前状态(无关历史);</li><li>策略是固定的(与时间无关). $A _ { t } \sim \pi ( \cdot | S _ { t } ) , \forall t &gt; 0$</li></ul><p>给定一个马尔可夫决策过程 $M = &lt;\mathcal{S},\mathcal{A}, \mathcal{P}, \mathcal{R}, \mathcal{\gamma}&gt;$ 和 一个策略 $\pi$, 其可以转化为<em>马尔可夫过程</em>和<em>马尔可夫奖励过程</em>.</p><ul><li><p>状态序列 $S_1, S_2, \dots$ 是马尔科夫决策过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}&gt;$.</p></li><li><p>状态和奖励序列 $S_1, R_2, S_2, \dots$ 是马尔科夫奖励过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$.</p></li></ul><p>其中,</p><script type="math/tex; mode=display">\mathcal{P}_{s,s'}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{P}_{ss'}^{a}</script><script type="math/tex; mode=display">\mathcal{R}_{s}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{R}_{s}^{a}</script><hr><h3 id="值函数-1"><a href="#值函数-1" class="headerlink" title="值函数"></a>值函数</h3><p><strong>值函数(Value Function)</strong>可分为<strong>状态值函数(state-value function)</strong>和<strong>动作值函数(action-value function)</strong>.</p><blockquote><p>MDP的<strong>状态值函数 $v_{\pi}(s)$ </strong>是从状态 $s$ 开始, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ G_t | S_t = s \right]</script><p>MDP的<strong>动作值函数 $q_{\pi}(s, a)$ </strong>是从状态 $s$ 开始, 采取动作 $a$, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ G_t | S_t = s, A_t = a \right]</script></blockquote><hr><h3 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h3><p>状态值函数可以被分解为两部分, <strong>立即奖励 + 后继状态的折扣价值</strong>.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t = s \right]</script><p>动作值函数也可以类似地分解.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma q_{\pi}(S_{t+1}, A_{t+1}) | S_t = s, A_t = a \right]</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0ldl141fkj20bb04xq2x.jpg" width="40%" height="40%"></p><p>上图中, 空心圆圈代表状态, 实心圆圈代表动作.</p><p>在已知策略 $\pi$ 的情况下, 状态值函数 $v_{\pi}(s)$ 可以用动作值函数 $q_{\pi}(s, a)$ 进行表示:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a | s) q_{\pi}(s, a) \tag{3}\label{eq:mdp-state-value-function}</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0lds6jc80j20b004rmx6.jpg" width="40%" height="40%"></p><p>同理, 动作值函数 $q_{\pi}(s, a)$ 也可以用状态值函数 $v_{\pi}(s)$ 进行表示:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s') \tag{4}\label{eq:mdp-action-value-function}</script><hr><p><strong>状态值函数的贝尔曼期望方程:</strong></p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0le5yxgeij20b706hdfx.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-action-value-function}代入公式\eqref{eq:mdp-state-value-function}中, 可得状态值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{\pi}(s')  \right)</script><hr><p><strong>动作值函数的贝尔曼期望方程:</strong></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0le9cf2u7j20bd05wwek.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-state-value-function}代入公式\eqref{eq:mdp-action-value-function}中, 可得动作值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} \sum \limits_{a' \in \mathcal{A}} \pi (a' | s') q_{\pi}(s', a')</script><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lecy0oxgj20h90dcwfj.jpg" alt="状态值函数的贝尔曼期望方程示例" width="55%" height="55%"></p><hr><p><strong>贝尔曼期望方程的矩阵形式:</strong></p><script type="math/tex; mode=display">v_{\pi} = \mathcal{R}^{\pi} + \gamma \mathcal{P}^{\pi} v_{\pi}</script><p>可直接求解:</p><script type="math/tex; mode=display">v_{\pi} = (I - \gamma \mathcal{P}^{\pi})^{-1} \mathcal{R}^{\pi}</script><hr><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><blockquote><p><strong>最优状态值函数(optimal state-value function)</strong> $v_{*}(s)$ 是所有策略中最大的值函数.</p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{\pi}v_{\pi}(s)</script><p><strong>最优动作值函数(optimal action-value function)</strong> $v_{*}(s)$ 是所有策略中最大的动作值函数.</p><script type="math/tex; mode=display">q_{*}(s, a) = \max \limits_{\pi}q_{\pi}(s, a)</script></blockquote><ul><li>最优值函数代表了MDP的最好性能.</li><li>当得知最优值函数时, MDP可被认为”已解决”.</li></ul><hr><p>例子: </p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leoxfaylj20h70ee75c.jpg" alt="Student MDP中的最优状态值函数" width="50%" height="50%"></p><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leqk38l4j20hh0eg75i.jpg" alt="Student MDP中的最优动作值函数" width="50%" height="50%"></p><p>注: 根据公式\eqref{eq:mdp-state-value-function}, Pub动作的最优值应为 $q_{*} = +1 + (0.2 \times 6 + 0.4 \times 8 + 0.4 \times 10) = 9.4$.</p><hr><h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><p>首先定义策略之间的偏序关系, 使得策略之间可以进行比较:</p><script type="math/tex; mode=display">\pi \geq \pi ' \quad \text{if} \quad  v_{\pi}(s) \geq v_{\pi '}(s) , \forall s</script><p>对于任意的MDP来说:</p><ul><li>存在一个最优策略 $\pi_{*}$, 使得 $\pi_{*} \geq \pi, \forall \pi$</li><li>所有的最优策略都能取得最优值函数 $v_{\pi_{*}}(s) = v_{*}(s)$</li><li>所有的最优策略都能取得最优动作值函数 $q_{\pi_{*}}(s, a) = v_{*}(s, a)$</li></ul><hr><p><strong>寻找最优策略</strong></p><p>一个最优策略可以通过最大化所有的 $q_{*}(s, a)$ 得到:</p><script type="math/tex; mode=display">\pi_{*} \left( a | s \right) = \left \{ \begin{array}{ll}1 \ {\mathbb {if}} \ a = \operatorname*{argmax} \limits_{a \in \mathcal{A}} \ q_{*} \left( s,a \right) \\              0 \ {\mathbb {otherwise}}              \end{array} \right.</script><ul><li>对于任意的MDP, 总存在确定的最优策略</li><li>如果我们知道 $q_{*}(s, a)$, 则可以立即得到最优策略</li></ul><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lfhg0710j20hn0ehjsl.jpg" alt="Student MDP的最优策略" width="50%" height="50%"></p><p>图中红色弧线表示每个状态的最优决策.</p><hr><h3 id="贝尔曼最优方程"><a href="#贝尔曼最优方程" class="headerlink" title="贝尔曼最优方程"></a>贝尔曼最优方程</h3><p>$v_{*}$可以通过贝尔曼最优方程递归得到:</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0lfkujh38j20b804uaa2.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{a} q_{*}(s, a)\tag{5}\label{eq:state-bellman-optimal-equation}</script><p>与公式\eqref{eq:mdp-state-value-function}的贝尔曼期望方程进行比较, 此时不再取均值, 而是取最大值.</p><hr><p>$q_{*}$与公式\eqref{eq:mdp-action-value-function}类似:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m10t6s7vj208003a747.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)\tag{6}\label{eq:action-bellman-optimal-equation}</script><hr><p><strong>状态值函数的贝尔曼最优方程</strong></p><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0m14a2fenj208m04xq2x.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:action-bellman-optimal-equation}代入公式\eqref{eq:state-bellman-optimal-equation}可得 $v_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><hr><p><strong>动作值函数的贝尔曼最优方程</strong></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0m18irqg7j208804bgll.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:state-bellman-optimal-equation}代入公式\eqref{eq:action-bellman-optimal-equation}可得 $q_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><hr><p>例子:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m1ato6q2j20d70atjs3.jpg" alt="Student MDP贝尔曼最优方程" width="50%" height="50%"></p><hr><h3 id="贝尔曼最优方程的求解"><a href="#贝尔曼最优方程的求解" class="headerlink" title="贝尔曼最优方程的求解"></a>贝尔曼最优方程的求解</h3><p>贝尔曼最优方程<strong>不是线性的</strong>(因为有取$max$操作), 因此没有封闭解(Closed-form solution).</p><p>通常采用迭代求解方法:</p><ul><li>值迭代(Value Iteration)</li><li>策略迭代(Policy Iteration)</li><li>Q-Learning</li><li>Sarsa</li></ul><h2 id="MDP的扩展"><a href="#MDP的扩展" class="headerlink" title="MDP的扩展"></a>MDP的扩展</h2><ul><li>无穷和连续的MDPs</li><li>部分可观测的MDPs</li><li>不折扣, 平均奖励MDPs</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 2: Markov Decision Processes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9833386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第2课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="马尔可夫决策过程" scheme="https://orzyt.cn/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>David Silver强化学习Lecture1：强化学习简介</title>
    <link href="https://orzyt.cn/posts/introduction-to-rl/"/>
    <id>https://orzyt.cn/posts/introduction-to-rl/</id>
    <published>2019-02-25T14:56:13.000Z</published>
    <updated>2019-02-27T11:03:59.961Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf" target="_blank" rel="noopener">Lecture 1: Introduction to Reinforcement Learning</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9831889" target="_blank" rel="noopener">David Silver深度强化学习第1课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="强化学习的特征"><a href="#强化学习的特征" class="headerlink" title="强化学习的特征"></a>强化学习的特征</h2><p>作为机器学习的一个分支，强化学习主要的特征为:</p><ul><li><p>无监督,仅有奖励信号；</p></li><li><p>反馈有延迟,不是瞬时的;</p></li><li><p>时间是重要的(由于是时序数据,不是独立同分布的);</p></li><li><p>Agent的动作会影响后续得到的数据;</p></li></ul><hr><h2 id="强化学习的概念"><a href="#强化学习的概念" class="headerlink" title="强化学习的概念"></a>强化学习的概念</h2><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>奖励(Rewards) $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何.</p><p><strong>Agent的目标</strong>: 最大化累积奖励(maximise cumulative reward).</p><p>强化学习基于<strong>奖励假设(reward hypothesis)</strong>.</p><blockquote><p><strong>奖励假设(Reward Hypothesis)</strong>:<br>所有强化学习任务的目标都可以被描述为最大化期望累积奖励.</p></blockquote><hr><h3 id="序贯决策"><a href="#序贯决策" class="headerlink" title="序贯决策"></a>序贯决策</h3><p><strong>序贯决策(Sequential Decision Making)的目标</strong>: 选择合适的动作最大化将来的累积奖励.</p><ul><li>动作可能会产生长期后果；</li><li>奖励会有延迟性;</li><li>牺牲立即回报可能会获得更多的长期回报.</li></ul><hr><h3 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k2ozf0lzj20aq0bxtb1.jpg" alt="Agent和环境" width="35%" height="35%"></p><p>智能体(Agent)在每个时刻$t$会:</p><ul><li>执行动作(Action)$A_t$;</li><li>接收观测(Observation)$O_t$;</li><li>接收标量奖励(Reward)$R_t$.</li></ul><p>而环境(Environment)则会:</p><ul><li>接收动作(Action)$A_t$;</li><li>产生观测(Observation)$O_{t+1}$;</li><li>产生标量奖励(Reward)$R_{t+1}$.</li></ul><hr><h3 id="历史与状态"><a href="#历史与状态" class="headerlink" title="历史与状态"></a>历史与状态</h3><blockquote><p><strong>历史(History):</strong>由一系列观测,动作和奖励构成.</p></blockquote><script type="math/tex; mode=display">H_t = O_1, R_1, A_1, \dots, A_{t-1}, O_t, R_t</script><p>下一步将发生什么取决于历史:</p><ul><li>智能体选择的action;</li><li>环境选择的observations/rewards.</li></ul><blockquote><p><strong>状态(State)</strong>:用来决定接下来会发生什么的信息.</p></blockquote><p><strong>状态是历史的函数:</strong></p><script type="math/tex; mode=display">S_t = f(H_t)</script><hr><h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3akygqpj20b20cptb5.jpg" alt="环境状态" width="35%" height="35%"></p><p>环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见.</p><p>即使$S_{t}^{e}$可见,也可能包含不相关信息.</p><hr><h4 id="智能体状态"><a href="#智能体状态" class="headerlink" title="智能体状态"></a>智能体状态</h4><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k3e8bw4aj20b00cx419.jpg" alt="智能体状态" width="35%" height="35%"></p><p>智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息.</p><p>可以写成历史的函数: $S_{t}^{a} = f(H_t)$</p><hr><h4 id="信息状态"><a href="#信息状态" class="headerlink" title="信息状态"></a>信息状态</h4><p><strong>信息状态(也称为马尔科夫状态)</strong>: 包含历史中所有有用的信息.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫状态定义" width="60%" height="60%"></p><p>马尔科夫状态表明: <strong>未来只与现在有关,而与过去无关.</strong></p><p>其中,<strong>环境状态$S_t^e$</strong>和<strong>历史$H_t$</strong>具有马尔科夫性质.</p><hr><h4 id="Rat-Example"><a href="#Rat-Example" class="headerlink" title="Rat Example"></a>Rat Example</h4><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k3trc5qxj20ny0doq88.jpg" alt="Rat Example" width="60%" height="60%"></p><ul><li><p>假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击)</p></li><li><p>假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪)</p></li><li><p>假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知)</p></li></ul><hr><h4 id="完全可观测环境"><a href="#完全可观测环境" class="headerlink" title="完全可观测环境"></a>完全可观测环境</h4><p><strong>完全可观测性(Full observability):</strong> 智能体可以直接观测到环境状态,即</p><script type="math/tex; mode=display">O_t = S_t^a = S_t^e</script><ul><li>智能体状态 = 环境状态 = 信息状态</li><li>实际上是马尔科夫决策过程(Markov Decision Process, MDP)</li></ul><hr><h4 id="部分可观测环境"><a href="#部分可观测环境" class="headerlink" title="部分可观测环境"></a>部分可观测环境</h4><p><strong>部分可观测性(Partial observability):</strong> 智能体不能够直接观测到环境.</p><p>如,机器人不能通过摄像头得知自身的绝对位置.</p><ul><li>智能体状态 $\neq$ 环境状态</li><li>部分可观测马尔科夫决策过程(POMDP)</li></ul><p>此时,智能体必须构建其自身的状态表示 $S_t^a$,比如:</p><ul><li>完全的历史: $S_t^a = H_t$;</li><li>环境状态的置信度: $S _ { t } ^ { a } = \left( \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { 1 } \right] , \ldots , \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { n } \right] \right)$;</li><li>循环神经网络: $S_t^a = \sigma \left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\right)$</li></ul><hr><h2 id="智能体的构成"><a href="#智能体的构成" class="headerlink" title="智能体的构成"></a>智能体的构成</h2><p>智能体主要包含以下几种成分:</p><ul><li><strong>策略(Policy)</strong>: 智能体的行为函数;</li><li><strong>值函数(Value Function)</strong>: 每个state或action的好坏;</li><li><strong>模型(Model)</strong>: 智能体对环境的表示.</li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>策略(Policy)是智能体的行为;</li><li>是<strong>状态</strong>到<strong>动作</strong>的映射;</li><li>确定性策略: $a = \pi(s)$;</li><li>随机性策略: $\pi(a|s) = \mathbb{P} \left[ A_{t} = a | S_{t} = s\right]$</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function)是对于未来奖励的预测.</p><ul><li>用于评价状态的好坏;</li><li>因此可以用来选择动作.</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots | S_{t} = s \right]</script><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型(Model)用来预测环境接下来会做什么.</p><ul><li>$\mathcal{P}$: 预测下一个状态.<script type="math/tex; mode=display">\mathcal{P}_{ss'}^{a} = \mathbb{P} \left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\right]</script></li><li>$\mathcal{R}$: 预测下一个(立即)奖励.<script type="math/tex; mode=display">\mathcal{R}_{s}^{a} = \mathbb{E} \left[ R_{t+1} | S_{t} = s, A_{t} = a\right]</script></li></ul><hr><h3 id="Maze-Example"><a href="#Maze-Example" class="headerlink" title="Maze Example"></a>Maze Example</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k4norup9j20mj092dg5.jpg" alt="Maze Example" width="60%" height="60%"></p><hr><p><strong>策略表示:</strong></p><p>箭头表示每个状态的策略 $\pi(s)$.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k4u9pdcdj20f10c5q38.jpg" alt="Maze Example: Policy" width="40%" height="40%"></p><hr><p><strong>值函数表示:</strong></p><p>数值表示每个状态的值 $v_{\pi}(s)$.</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k4w9vn7wj20f60cct8y.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><p><strong>模型表示:</strong></p><p>智能体可能对环境建立内部模型</p><ul><li>网格布局表示转移模型 $\mathcal{P}_{ss’}^{a}$;</li><li>数值表示每个状态的立即奖励 $\mathcal{R}_{s}^{a}$.</li></ul><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k51h023dj20c109kt8o.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><h3 id="智能体的分类"><a href="#智能体的分类" class="headerlink" title="智能体的分类"></a>智能体的分类</h3><p>按智能体的成分分类:</p><ul><li>基于值函数(Value Based)</li><li>基于策略(Policy Based)</li><li>演员-评论家(Actor Critic)</li></ul><p>或者按有无模型分类:</p><ul><li>无模型(Model Free)</li><li>基于模型(Model Based)</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k55tidg0j20f30eaab9.jpg" alt="智能体分类" width="40%" height="40%"></p><hr><h2 id="强化学习的问题"><a href="#强化学习的问题" class="headerlink" title="强化学习的问题"></a>强化学习的问题</h2><h3 id="学习与规划"><a href="#学习与规划" class="headerlink" title="学习与规划"></a>学习与规划</h3><p><strong>强化学习</strong></p><ul><li>环境的初始状态未知;</li><li>智能体与环境进行交互;</li><li>智能体提升其策略.</li></ul><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0k5dprnn4j20p80ejn0q.jpg" alt="学习" width="60%" height="60%"></p><p><strong>规划</strong></p><ul><li>环境的模型已知;</li><li>智能体通过模型进行计算,无须与外部进行交互;</li><li>智能体提升其策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k5eleerwj20ok0df0u3.jpg" alt="规划" width="60%" height="60%"></p><hr><h3 id="探索和利用"><a href="#探索和利用" class="headerlink" title="探索和利用"></a>探索和利用</h3><p>强化学习是一种试错(trial-and-error)学习.</p><p>智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励.</p><ul><li><strong>探索(Exploration):</strong> 从环境中寻找更多信息;</li><li><strong>利用(Exploitation):</strong> 利用已知信息使奖励最大化.</li></ul><p>探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果.</p><hr><h3 id="预测和控制"><a href="#预测和控制" class="headerlink" title="预测和控制"></a>预测和控制</h3><ul><li><strong>预测(Prediction):</strong> 对未来进行评估.</li></ul><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k5ryo676j20nz0ds0tn.jpg" alt="Gridworld Example: Prediction" width="60%" height="60%"></p><hr><ul><li><strong>控制(Control):</strong> 最优化未来的结果.</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k5r6vdmgj20nv0eot9w.jpg" alt="Gridworld Example: Control" width="60%" height="60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 1: Introduction to Reinforcement Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9831889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第1课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode637 Average of Levels in Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/average-of-levels-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode654 Maximum Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode654-maximum-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode654-maximum-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode657 Robot Return to Origin</title>
    <link href="https://orzyt.cn/posts/leetcode657-robot-return-to-origin/"/>
    <id>https://orzyt.cn/posts/leetcode657-robot-return-to-origin/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-return-to-or
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode661 Image Smoother</title>
    <link href="https://orzyt.cn/posts/leetcode661-image-smoother/"/>
    <id>https://orzyt.cn/posts/leetcode661-image-smoother/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/image-smoother/&quot; t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665 Non-decreasing Array</title>
    <link href="https://orzyt.cn/posts/leetcode665-non-decreasing-array/"/>
    <id>https://orzyt.cn/posts/leetcode665-non-decreasing-array/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/non-decreasing-arr
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617 Merge Two Binary Trees</title>
    <link href="https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/"/>
    <id>https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/</id>
    <published>2019-02-08T09:02:05.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode606 Construct String from Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/</id>
    <published>2019-02-08T09:01:50.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-string-f
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode599 Minimum Index Sum of Two Lists</title>
    <link href="https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
    <id>https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/</id>
    <published>2019-02-08T09:01:34.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-index-sum-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode38 Count and Say</title>
    <link href="https://orzyt.cn/posts/leetcode38-count-and-say/"/>
    <id>https://orzyt.cn/posts/leetcode38-count-and-say/</id>
    <published>2019-02-08T09:00:37.000Z</published>
    <updated>2019-02-08T10:25:59.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/&quot; ta
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-02-26T11:20:51.367Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1j4up5oj21cb0ik489.jpg" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jnv2szj210109oacr.jpg" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jytblsj20of0kgwhp.jpg" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1kfbt7kj217u0e8dlk.jpg" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k1kr4sx8j215r0k9wlm.jpg" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1l9pm84j20x007ht9n.jpg" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lnsllgj20tr0m1qdq.jpg" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lvxp55j20zt0i4n3g.jpg" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1m4b63ij20fv0ib40x.jpg" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k1mg2yrlj20hk0ca0v4.jpg" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mmsrz1j20n808dwfx.jpg" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k1mtlmpmj20ck04sq3j.jpg" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mz40h8j21640ad0wf.jpg" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="https://ws1.sinaimg.cn/large/8662e3cegy1g0k1n6hmq9j20lo09g0wz.jpg" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/leetcode575-distribute-candies/"/>
    <id>https://orzyt.cn/posts/leetcode575-distribute-candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2019-02-08T10:26:00.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/leetcode566-reshape-the-matrix/"/>
    <id>https://orzyt.cn/posts/leetcode566-reshape-the-matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2019-02-08T10:26:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/leetcode563-binary-tree-tilt/"/>
    <id>https://orzyt.cn/posts/leetcode563-binary-tree-tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2019-02-08T10:26:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/leetcode561-array-partition-i/"/>
    <id>https://orzyt.cn/posts/leetcode561-array-partition-i/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2019-02-08T10:26:00.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/"/>
    <id>https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2019-02-08T10:26:00.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ssh本地端口转发的应用</title>
    <link href="https://orzyt.cn/posts/ssh-port-forwarding/"/>
    <id>https://orzyt.cn/posts/ssh-port-forwarding/</id>
    <published>2018-01-13T07:34:17.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;SSH有三种端口转发模式，&lt;strong&gt;本地端口转发(Local Port Forwarding)&lt;/strong&gt;，&lt;strong&gt;远程端口转发(Remote Port Forwarding)&lt;/strong&gt;以及&lt;strong&gt;动态端口转发(Dynamic Port Forwarding)&lt;/strong&gt;。本文只简单介绍&lt;strong&gt;本地端口转发&lt;/strong&gt;，用于实现本机访问远程服务器上的&lt;code&gt;jupyter notebook&lt;/code&gt;、&lt;code&gt;TensorBoard&lt;/code&gt;等服务。&lt;/p&gt;
&lt;h2 id=&quot;什么是本地端口转发？&quot;&gt;&lt;a href=&quot;#什么是本地端口转发？&quot; class=&quot;headerlink&quot; title=&quot;什么是本地端口转发？&quot;&gt;&lt;/a&gt;什么是本地端口转发？&lt;/h2&gt;&lt;p&gt;所谓本地端口转发，就是&lt;strong&gt;将发送到本地端口的请求，转发到目标端口&lt;/strong&gt;。这样，就可以通过访问本地端口，来访问目标端口的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="端口转发" scheme="https://orzyt.cn/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="jupyter notebook" scheme="https://orzyt.cn/tags/jupyter-notebook/"/>
    
      <category term="tensorboard" scheme="https://orzyt.cn/tags/tensorboard/"/>
    
  </entry>
  
  <entry>
    <title>简化ssh连接服务器流程</title>
    <link href="https://orzyt.cn/posts/ssh-login/"/>
    <id>https://orzyt.cn/posts/ssh-login/</id>
    <published>2018-01-13T03:02:26.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>登录远程服务器一般采用<code>ssh</code>（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。</p><h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h2><p>在本机的终端中执行命令 <code>ssh-keygen</code> ，然后根据提示操作即可在目录（默认为<code>~/.ssh</code>）中生成<code>id_rsa</code>（私钥） 和 <code>id_rsa.pub</code>（公钥）文件。</p><a id="more"></a><h2 id="添加-ssh-config-文件"><a href="#添加-ssh-config-文件" class="headerlink" title="添加 ssh config 文件"></a>添加 ssh config 文件</h2><p>根据下列内容，修改（或新建）本机中的<code>~/.ssh/config</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host fastlogin                 # 随便取个名字，用于登录</span><br><span class="line">    HostName xxx.xxx.xxx.xxx   # 主机地址 </span><br><span class="line">    User username              # 用户名</span><br><span class="line">    Port 1234                  # 端口号</span><br></pre></td></tr></table></figure><h2 id="向服务器中添加公钥"><a href="#向服务器中添加公钥" class="headerlink" title="向服务器中添加公钥"></a>向服务器中添加公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在本机中执行]：将公钥文件上传到服务器的用户目录</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表</span></span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p>配置好之后，只需执行下列命令即可快速登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastlogin 为之前在ssh config中定义的名字</span></span><br><span class="line">ssh fastlogin</span><br></pre></td></tr></table></figure><h2 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h2><p>现在，如果想要复制本机的文件到服务器上，可以更加简便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本机源地址 fastlogin:服务器目标地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;登录远程服务器一般采用&lt;code&gt;ssh&lt;/code&gt;（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。&lt;/p&gt;
&lt;h2 id=&quot;生成-ssh-key&quot;&gt;&lt;a href=&quot;#生成-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;生成 ssh key&quot;&gt;&lt;/a&gt;生成 ssh key&lt;/h2&gt;&lt;p&gt;在本机的终端中执行命令 &lt;code&gt;ssh-keygen&lt;/code&gt; ，然后根据提示操作即可在目录（默认为&lt;code&gt;~/.ssh&lt;/code&gt;）中生成&lt;code&gt;id_rsa&lt;/code&gt;（私钥） 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;（公钥）文件。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="scp" scheme="https://orzyt.cn/tags/scp/"/>
    
  </entry>
  
</feed>
