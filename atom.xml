<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-02-08T10:25:59.974Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode637 Average of Levels in Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/average-of-levels-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode654 Maximum Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode654-maximum-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode654-maximum-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode657 Robot Return to Origin</title>
    <link href="https://orzyt.cn/posts/leetcode657-robot-return-to-origin/"/>
    <id>https://orzyt.cn/posts/leetcode657-robot-return-to-origin/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-return-to-or
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode661 Image Smoother</title>
    <link href="https://orzyt.cn/posts/leetcode661-image-smoother/"/>
    <id>https://orzyt.cn/posts/leetcode661-image-smoother/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/image-smoother/&quot; t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665 Non-decreasing Array</title>
    <link href="https://orzyt.cn/posts/leetcode665-non-decreasing-array/"/>
    <id>https://orzyt.cn/posts/leetcode665-non-decreasing-array/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/non-decreasing-arr
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617 Merge Two Binary Trees</title>
    <link href="https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/"/>
    <id>https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/</id>
    <published>2019-02-08T09:02:05.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode606 Construct String from Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/</id>
    <published>2019-02-08T09:01:50.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-string-f
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode599 Minimum Index Sum of Two Lists</title>
    <link href="https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
    <id>https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/</id>
    <published>2019-02-08T09:01:34.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-index-sum-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode38 Count and Say</title>
    <link href="https://orzyt.cn/posts/leetcode38-count-and-say/"/>
    <id>https://orzyt.cn/posts/leetcode38-count-and-say/</id>
    <published>2019-02-08T09:00:37.000Z</published>
    <updated>2019-02-08T10:25:59.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/&quot; ta
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-02-07T14:56:09.148Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="./fr_system.png" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="./arch.png" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="./archs.png" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="./loss.png" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="./lfw.png" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="./triplet_loss.png" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="./center_loss.png" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="./center_invariant_loss.png" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="./l_softmax.png" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="./a_softmax.png" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="./am_softmax.png" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="./lmc.png" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="./arcface.png" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="./ring_loss.png" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/leetcode575-distribute-candies/"/>
    <id>https://orzyt.cn/posts/leetcode575-distribute-candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2019-02-08T10:26:00.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/leetcode566-reshape-the-matrix/"/>
    <id>https://orzyt.cn/posts/leetcode566-reshape-the-matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2019-02-08T10:26:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/leetcode563-binary-tree-tilt/"/>
    <id>https://orzyt.cn/posts/leetcode563-binary-tree-tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2019-02-08T10:26:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/leetcode561-array-partition-i/"/>
    <id>https://orzyt.cn/posts/leetcode561-array-partition-i/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2019-02-08T10:26:00.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/"/>
    <id>https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2019-02-08T10:26:00.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ssh本地端口转发的应用</title>
    <link href="https://orzyt.cn/posts/ssh-port-forwarding/"/>
    <id>https://orzyt.cn/posts/ssh-port-forwarding/</id>
    <published>2018-01-13T07:34:17.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;SSH有三种端口转发模式，&lt;strong&gt;本地端口转发(Local Port Forwarding)&lt;/strong&gt;，&lt;strong&gt;远程端口转发(Remote Port Forwarding)&lt;/strong&gt;以及&lt;strong&gt;动态端口转发(Dynamic Port Forwarding)&lt;/strong&gt;。本文只简单介绍&lt;strong&gt;本地端口转发&lt;/strong&gt;，用于实现本机访问远程服务器上的&lt;code&gt;jupyter notebook&lt;/code&gt;、&lt;code&gt;TensorBoard&lt;/code&gt;等服务。&lt;/p&gt;
&lt;h2 id=&quot;什么是本地端口转发？&quot;&gt;&lt;a href=&quot;#什么是本地端口转发？&quot; class=&quot;headerlink&quot; title=&quot;什么是本地端口转发？&quot;&gt;&lt;/a&gt;什么是本地端口转发？&lt;/h2&gt;&lt;p&gt;所谓本地端口转发，就是&lt;strong&gt;将发送到本地端口的请求，转发到目标端口&lt;/strong&gt;。这样，就可以通过访问本地端口，来访问目标端口的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="端口转发" scheme="https://orzyt.cn/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="jupyter notebook" scheme="https://orzyt.cn/tags/jupyter-notebook/"/>
    
      <category term="tensorboard" scheme="https://orzyt.cn/tags/tensorboard/"/>
    
  </entry>
  
  <entry>
    <title>简化ssh连接服务器流程</title>
    <link href="https://orzyt.cn/posts/ssh-login/"/>
    <id>https://orzyt.cn/posts/ssh-login/</id>
    <published>2018-01-13T03:02:26.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>登录远程服务器一般采用<code>ssh</code>（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。</p><h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h2><p>在本机的终端中执行命令 <code>ssh-keygen</code> ，然后根据提示操作即可在目录（默认为<code>~/.ssh</code>）中生成<code>id_rsa</code>（私钥） 和 <code>id_rsa.pub</code>（公钥）文件。</p><a id="more"></a><h2 id="添加-ssh-config-文件"><a href="#添加-ssh-config-文件" class="headerlink" title="添加 ssh config 文件"></a>添加 ssh config 文件</h2><p>根据下列内容，修改（或新建）本机中的<code>~/.ssh/config</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host fastlogin                 # 随便取个名字，用于登录</span><br><span class="line">    HostName xxx.xxx.xxx.xxx   # 主机地址 </span><br><span class="line">    User username              # 用户名</span><br><span class="line">    Port 1234                  # 端口号</span><br></pre></td></tr></table></figure><h2 id="向服务器中添加公钥"><a href="#向服务器中添加公钥" class="headerlink" title="向服务器中添加公钥"></a>向服务器中添加公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在本机中执行]：将公钥文件上传到服务器的用户目录</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表</span></span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p>配置好之后，只需执行下列命令即可快速登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastlogin 为之前在ssh config中定义的名字</span></span><br><span class="line">ssh fastlogin</span><br></pre></td></tr></table></figure><h2 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h2><p>现在，如果想要复制本机的文件到服务器上，可以更加简便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本机源地址 fastlogin:服务器目标地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;登录远程服务器一般采用&lt;code&gt;ssh&lt;/code&gt;（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。&lt;/p&gt;
&lt;h2 id=&quot;生成-ssh-key&quot;&gt;&lt;a href=&quot;#生成-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;生成 ssh key&quot;&gt;&lt;/a&gt;生成 ssh key&lt;/h2&gt;&lt;p&gt;在本机的终端中执行命令 &lt;code&gt;ssh-keygen&lt;/code&gt; ，然后根据提示操作即可在目录（默认为&lt;code&gt;~/.ssh&lt;/code&gt;）中生成&lt;code&gt;id_rsa&lt;/code&gt;（私钥） 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;（公钥）文件。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="scp" scheme="https://orzyt.cn/tags/scp/"/>
    
  </entry>
  
  <entry>
    <title>常用软件更换国内镜像源</title>
    <link href="https://orzyt.cn/posts/change-mirrors/"/>
    <id>https://orzyt.cn/posts/change-mirrors/</id>
    <published>2018-01-13T02:45:51.000Z</published>
    <updated>2018-11-10T11:47:16.927Z</updated>
    
    <content type="html"><![CDATA[<hr><p>由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。</p><p>以下基于<code>Ubuntu</code>系统介绍相应的换源方式。</p><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>修改（或新建）文件：<code>~/.pip/pip.conf</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。&lt;/p&gt;
&lt;p&gt;以下基于&lt;code&gt;Ubuntu&lt;/code&gt;系统介绍相应的换源方式。&lt;/p&gt;
&lt;h2 id=&quot;pip&quot;&gt;&lt;a href=&quot;#pip&quot; class=&quot;headerlink&quot; title=&quot;pip&quot;&gt;&lt;/a&gt;pip&lt;/h2&gt;&lt;p&gt;修改（或新建）文件：&lt;code&gt;~/.pip/pip.conf&lt;/code&gt;，添加以下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[global]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index-url = https://pypi.tuna.tsinghua.edu.cn/simple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pip" scheme="https://orzyt.cn/tags/pip/"/>
    
      <category term="npm" scheme="https://orzyt.cn/tags/npm/"/>
    
      <category term="anaconda" scheme="https://orzyt.cn/tags/anaconda/"/>
    
      <category term="镜像源" scheme="https://orzyt.cn/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode543 Diameter of Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode543-diameter-of-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode543-diameter-of-binary-tree/</id>
    <published>2018-01-09T05:14:50.000Z</published>
    <updated>2019-02-08T10:26:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">      </span><br><span class="line">Output:</span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的直径</p><p>普通树的直径需要<a href="https://www.cnblogs.com/wuyiqi/archive/2012/04/08/2437424.html" target="_blank" rel="noopener">两遍DFS</a>，而二叉树因为结构特殊只需一次DFS即可</p><p>假设二叉树中共有$n$个节点，第$i$个节点的左子树树高为$l_i$，右子树树高为$r_i$，则以第$i$个节点为子树的直径$d_i = l_i + r_i  $，最终整棵二叉树的直径$D = max\{d_i | i=1..n\}$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> dep - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递归求解左子树深度及右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> l = dfs(u-&gt;left, dep + <span class="number">1</span>), r = dfs(u-&gt;right, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 因为当前深度是相对于root来说的，如果相对于u来说，其左右子树树高需要减去u的深度</span></span><br><span class="line">        <span class="comment">// 即 d = l - dep + r - dep = l + r - 2 * dep</span></span><br><span class="line">        ans = max(ans, l + r - <span class="number">2</span> * dep);</span><br><span class="line">        <span class="keyword">return</span> max(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the &lt;strong&gt;longest&lt;/strong&gt; path between any two nodes in a tree. This path may or may not pass through the root.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The length of path between two nodes is represented by the number of edges between them.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
</feed>
