<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-02-26T13:43:51.431Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>David Silver强化学习Lecture1：强化学习简介</title>
    <link href="https://orzyt.cn/posts/introduction-to-rl/"/>
    <id>https://orzyt.cn/posts/introduction-to-rl/</id>
    <published>2019-02-25T14:56:13.000Z</published>
    <updated>2019-02-26T13:43:51.431Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf" target="_blank" rel="noopener">Lecture 1: Introduction to Reinforcement Learning</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9831889" target="_blank" rel="noopener">David Silver深度强化学习第1课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="强化学习的特征"><a href="#强化学习的特征" class="headerlink" title="强化学习的特征"></a>强化学习的特征</h2><p>作为机器学习的一个分支，强化学习主要的特征为:</p><ul><li><p>无监督,仅有奖励信号；</p></li><li><p>反馈有延迟,不是瞬时的;</p></li><li><p>时间是重要的(由于是时序数据,不是独立同分布的);</p></li><li><p>Agent的动作会影响后续得到的数据;</p></li></ul><hr><h2 id="强化学习问题"><a href="#强化学习问题" class="headerlink" title="强化学习问题"></a>强化学习问题</h2><h3 id="奖励-Rewards"><a href="#奖励-Rewards" class="headerlink" title="奖励(Rewards)"></a>奖励(Rewards)</h3><p>奖励 $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何.</p><p><strong>Agent的目标</strong>: 最大化累积奖励(maximise cumulative reward).</p><p>强化学习基于<strong>奖励假设(reward hypothesis)</strong>.</p><blockquote><p><strong>奖励假设(Reward Hypothesis)</strong>:<br>所有强化学习任务的目标都可以被描述为最大化期望累积奖励.</p></blockquote><hr><h3 id="序贯决策-Sequential-Decision-Making"><a href="#序贯决策-Sequential-Decision-Making" class="headerlink" title="序贯决策(Sequential Decision Making)"></a>序贯决策(Sequential Decision Making)</h3><p><strong>目标</strong>: 选择合适的动作最大化将来的累积奖励.</p><ul><li>动作可能会产生长期后果；</li><li>奖励会有延迟性;</li><li>牺牲立即回报可能会获得更多的长期回报.</li></ul><hr><h3 id="智能体和环境-Agent-and-Environment"><a href="#智能体和环境-Agent-and-Environment" class="headerlink" title="智能体和环境(Agent and Environment)"></a>智能体和环境(Agent and Environment)</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k2ozf0lzj20aq0bxtb1.jpg" alt="Agent和环境" width="35%" height="35%"></p><p>智能体在每个时刻$t$会:</p><ul><li>执行动作(Action)$A_t$;</li><li>接收观测(Observation)$O_t$;</li><li>接收标量奖励(Reward)$R_t$.</li></ul><p>而环境则会:</p><ul><li>接收动作(Action)$A_t$;</li><li>产生观测(Observation)$O_{t+1}$;</li><li>产生标量奖励(Reward)$R_{t+1}$.</li></ul><hr><h3 id="历史与状态-History-and-State"><a href="#历史与状态-History-and-State" class="headerlink" title="历史与状态(History and State)"></a>历史与状态(History and State)</h3><blockquote><p><strong>历史(History):</strong>由一系列观测,动作和奖励构成.</p></blockquote><script type="math/tex; mode=display">H_t = O_1, R_1, A_1, \dots, A_{t-1}, O_t, R_t</script><p>下一步将发生什么取决于历史:</p><ul><li>智能体选择的action;</li><li>环境选择的observations/rewards.</li></ul><blockquote><p><strong>状态(State)</strong>:用来决定接下来会发生什么的信息.</p></blockquote><p><strong>状态是历史的函数:</strong></p><script type="math/tex; mode=display">S_t = f(H_t)</script><hr><h4 id="环境状态-Environment-State"><a href="#环境状态-Environment-State" class="headerlink" title="环境状态(Environment State)"></a>环境状态(Environment State)</h4><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3akygqpj20b20cptb5.jpg" alt="环境状态" width="35%" height="35%"></p><p>环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见.</p><p>即使$S_{t}^{e}$可见,也可能包含不相关信息.</p><hr><h4 id="智能体状态-Agent-State"><a href="#智能体状态-Agent-State" class="headerlink" title="智能体状态(Agent State)"></a>智能体状态(Agent State)</h4><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k3e8bw4aj20b00cx419.jpg" alt="智能体状态" width="35%" height="35%"></p><p>智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息.</p><p>可以写成历史的函数: $S_{t}^{a} = f(H_t)$</p><hr><h4 id="信息状态-Information-State"><a href="#信息状态-Information-State" class="headerlink" title="信息状态(Information State)"></a>信息状态(Information State)</h4><p><strong>信息状态(也称为马尔科夫状态)</strong>: 包含历史中所有有用的信息.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫状态定义" width="60%" height="60%"></p><p>马尔科夫状态表明: <strong>未来只与现在有关,而与过去无关.</strong></p><p>其中,<strong>环境状态$S_t^e$</strong>和<strong>历史$H_t$</strong>具有马尔科夫性质.</p><hr><h4 id="Rat-Example"><a href="#Rat-Example" class="headerlink" title="Rat Example"></a>Rat Example</h4><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k3trc5qxj20ny0doq88.jpg" alt="Rat Example" width="60%" height="60%"></p><ul><li><p>假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击)</p></li><li><p>假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪)</p></li><li><p>假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知)</p></li></ul><hr><h4 id="完全可观测环境-Fully-Observable-Environments"><a href="#完全可观测环境-Fully-Observable-Environments" class="headerlink" title="完全可观测环境(Fully Observable Environments)"></a>完全可观测环境(Fully Observable Environments)</h4><p><strong>完全可观测性(Full observability):</strong> 智能体可以直接观测到环境状态,即</p><script type="math/tex; mode=display">O_t = S_t^a = S_t^e</script><ul><li>智能体状态 = 环境状态 = 信息状态</li><li>实际上是马尔科夫决策过程(Markov Decision Process, MDP)</li></ul><hr><h4 id="部分可观测环境-Partially-Observable-Environments"><a href="#部分可观测环境-Partially-Observable-Environments" class="headerlink" title="部分可观测环境(Partially Observable Environments)"></a>部分可观测环境(Partially Observable Environments)</h4><p><strong>部分可观测性(Partial observability):</strong> 智能体不能够直接观测到环境.</p><p>如,机器人不能通过摄像头得知自身的绝对位置.</p><ul><li>智能体状态 $\neq$ 环境状态</li><li>部分可观测马尔科夫决策过程(POMDP)</li></ul><p>此时,智能体必须构建其自身的状态表示 $S_t^a$,比如:</p><ul><li>完全的历史: $S_t^a = H_t$;</li><li>环境状态的置信度: $S _ { t } ^ { a } = \left( \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { 1 } \right] , \ldots , \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { n } \right] \right)$;</li><li>循环神经网络: $S_t^a = \sigma \left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\right)$</li></ul><hr><h2 id="智能体的构成"><a href="#智能体的构成" class="headerlink" title="智能体的构成"></a>智能体的构成</h2><p>智能体主要包含以下几种成分:</p><ul><li><strong>策略(Policy)</strong>: 智能体的行为函数;</li><li><strong>值函数(Value Function)</strong>: 每个state或action的好坏;</li><li><strong>模型(Model)</strong>: 智能体对环境的表示.</li></ul><hr><h3 id="策略-Policy"><a href="#策略-Policy" class="headerlink" title="策略(Policy)"></a>策略(Policy)</h3><ul><li>策略是智能体的行为;</li><li>是<strong>状态</strong>到<strong>动作</strong>的映射;</li><li>确定性策略: $a = \pi(s)$;</li><li>随机性策略: $\pi(a|s) = \mathbb{P} \left[ A_{t} = a | S_{t} = s\right]$</li></ul><hr><h3 id="值函数-Value-Function"><a href="#值函数-Value-Function" class="headerlink" title="值函数(Value Function)"></a>值函数(Value Function)</h3><p>值函数是对于未来奖励的预测.</p><ul><li>用于评价状态的好坏;</li><li>因此可以用来选择动作.</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots | S_{t} = s \right]</script><hr><h3 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h3><p>模型用来预测环境接下来会做什么.</p><ul><li>$\mathcal{P}$: 预测下一个状态.<script type="math/tex; mode=display">\mathcal{P}_{ss'}^{a} = \mathbb{P} \left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\right]</script></li><li>$\mathcal{R}$: 预测下一个(立即)奖励.<script type="math/tex; mode=display">\mathcal{R}_{s}^{a} = \mathbb{E} \left[ R_{t+1} | S_{t} = s, A_{t} = a\right]</script></li></ul><hr><h3 id="Maze-Example"><a href="#Maze-Example" class="headerlink" title="Maze Example"></a>Maze Example</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k4norup9j20mj092dg5.jpg" alt="Maze Example" width="60%" height="60%"></p><hr><p><strong>策略表示:</strong></p><p>箭头表示每个状态的策略 $\pi(s)$.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k4u9pdcdj20f10c5q38.jpg" alt="Maze Example: Policy" width="40%" height="40%"></p><hr><p><strong>值函数表示:</strong></p><p>数值表示每个状态的值 $v_{\pi}(s)$.</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k4w9vn7wj20f60cct8y.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><p><strong>模型表示:</strong></p><p>智能体可能对环境建立内部模型</p><ul><li>网格布局表示转移模型 $\mathcal{P}_{ss’}^{a}$;</li><li>数值表示每个状态的立即奖励 $\mathcal{R}_{s}^{a}$.</li></ul><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k51h023dj20c109kt8o.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><h3 id="智能体的分类-Categorizing-RL-agents"><a href="#智能体的分类-Categorizing-RL-agents" class="headerlink" title="智能体的分类(Categorizing RL agents)"></a>智能体的分类(Categorizing RL agents)</h3><p>按智能体的成分分类:</p><ul><li>基于值函数(Value Based)</li><li>基于策略(Policy Based)</li><li>演员-评论家(Actor Critic)</li></ul><p>或者按有无模型分类:</p><ul><li>无模型(Model Free)</li><li>基于模型(Model Based)</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k55tidg0j20f30eaab9.jpg" alt="智能体分类" width="40%" height="40%"></p><hr><h2 id="强化学习的问题"><a href="#强化学习的问题" class="headerlink" title="强化学习的问题"></a>强化学习的问题</h2><h3 id="学习与规划-Learning-and-Planning"><a href="#学习与规划-Learning-and-Planning" class="headerlink" title="学习与规划(Learning and Planning)"></a>学习与规划(Learning and Planning)</h3><p><strong>强化学习</strong></p><ul><li>环境的初始状态未知;</li><li>智能体与环境进行交互;</li><li>智能体提升其策略.</li></ul><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0k5dprnn4j20p80ejn0q.jpg" alt="学习" width="60%" height="60%"></p><p><strong>规划</strong></p><ul><li>环境的模型已知;</li><li>智能体通过模型进行计算,无须与外部进行交互;</li><li>智能体提升其策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k5eleerwj20ok0df0u3.jpg" alt="规划" width="60%" height="60%"></p><hr><h3 id="探索和利用-Exploration-and-Exploitation"><a href="#探索和利用-Exploration-and-Exploitation" class="headerlink" title="探索和利用(Exploration and Exploitation)"></a>探索和利用(Exploration and Exploitation)</h3><p>强化学习是一种试错(trial-and-error)学习.</p><p>智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励.</p><ul><li><strong>探索(Exploration):</strong> 从环境中寻找更多信息;</li><li><strong>利用(Exploitation):</strong> 利用已知信息使奖励最大化.</li></ul><p>探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果.</p><hr><h3 id="预测和控制-Prediction-and-Control"><a href="#预测和控制-Prediction-and-Control" class="headerlink" title="预测和控制(Prediction and Control)"></a>预测和控制(Prediction and Control)</h3><ul><li><strong>预测(Prediction):</strong> 对未来进行评估.</li></ul><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k5ryo676j20nz0ds0tn.jpg" alt="Gridworld Example: Prediction" width="60%" height="60%"></p><hr><ul><li><strong>控制(Control):</strong> 最优化未来的结果.</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k5r6vdmgj20nv0eot9w.jpg" alt="Gridworld Example: Control" width="60%" height="60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 1: Introduction to Reinforcement Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9831889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第1课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Reinforcement Learning" scheme="https://orzyt.cn/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode661 Image Smoother</title>
    <link href="https://orzyt.cn/posts/leetcode661-image-smoother/"/>
    <id>https://orzyt.cn/posts/leetcode661-image-smoother/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/image-smoother/&quot; t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode657 Robot Return to Origin</title>
    <link href="https://orzyt.cn/posts/leetcode657-robot-return-to-origin/"/>
    <id>https://orzyt.cn/posts/leetcode657-robot-return-to-origin/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-return-to-or
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode654 Maximum Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode654-maximum-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode654-maximum-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode637 Average of Levels in Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/average-of-levels-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665 Non-decreasing Array</title>
    <link href="https://orzyt.cn/posts/leetcode665-non-decreasing-array/"/>
    <id>https://orzyt.cn/posts/leetcode665-non-decreasing-array/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/non-decreasing-arr
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617 Merge Two Binary Trees</title>
    <link href="https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/"/>
    <id>https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/</id>
    <published>2019-02-08T09:02:05.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode606 Construct String from Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/</id>
    <published>2019-02-08T09:01:50.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-string-f
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode599 Minimum Index Sum of Two Lists</title>
    <link href="https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
    <id>https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/</id>
    <published>2019-02-08T09:01:34.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-index-sum-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode38 Count and Say</title>
    <link href="https://orzyt.cn/posts/leetcode38-count-and-say/"/>
    <id>https://orzyt.cn/posts/leetcode38-count-and-say/</id>
    <published>2019-02-08T09:00:37.000Z</published>
    <updated>2019-02-08T10:25:59.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/&quot; ta
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-02-26T11:20:51.367Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1j4up5oj21cb0ik489.jpg" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jnv2szj210109oacr.jpg" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jytblsj20of0kgwhp.jpg" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1kfbt7kj217u0e8dlk.jpg" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k1kr4sx8j215r0k9wlm.jpg" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1l9pm84j20x007ht9n.jpg" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lnsllgj20tr0m1qdq.jpg" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lvxp55j20zt0i4n3g.jpg" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1m4b63ij20fv0ib40x.jpg" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k1mg2yrlj20hk0ca0v4.jpg" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mmsrz1j20n808dwfx.jpg" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k1mtlmpmj20ck04sq3j.jpg" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mz40h8j21640ad0wf.jpg" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="https://ws1.sinaimg.cn/large/8662e3cegy1g0k1n6hmq9j20lo09g0wz.jpg" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/leetcode575-distribute-candies/"/>
    <id>https://orzyt.cn/posts/leetcode575-distribute-candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2019-02-08T10:26:00.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/leetcode566-reshape-the-matrix/"/>
    <id>https://orzyt.cn/posts/leetcode566-reshape-the-matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2019-02-08T10:26:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/leetcode563-binary-tree-tilt/"/>
    <id>https://orzyt.cn/posts/leetcode563-binary-tree-tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2019-02-08T10:26:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/leetcode561-array-partition-i/"/>
    <id>https://orzyt.cn/posts/leetcode561-array-partition-i/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2019-02-08T10:26:00.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/"/>
    <id>https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2019-02-08T10:26:00.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ssh本地端口转发的应用</title>
    <link href="https://orzyt.cn/posts/ssh-port-forwarding/"/>
    <id>https://orzyt.cn/posts/ssh-port-forwarding/</id>
    <published>2018-01-13T07:34:17.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;SSH有三种端口转发模式，&lt;strong&gt;本地端口转发(Local Port Forwarding)&lt;/strong&gt;，&lt;strong&gt;远程端口转发(Remote Port Forwarding)&lt;/strong&gt;以及&lt;strong&gt;动态端口转发(Dynamic Port Forwarding)&lt;/strong&gt;。本文只简单介绍&lt;strong&gt;本地端口转发&lt;/strong&gt;，用于实现本机访问远程服务器上的&lt;code&gt;jupyter notebook&lt;/code&gt;、&lt;code&gt;TensorBoard&lt;/code&gt;等服务。&lt;/p&gt;
&lt;h2 id=&quot;什么是本地端口转发？&quot;&gt;&lt;a href=&quot;#什么是本地端口转发？&quot; class=&quot;headerlink&quot; title=&quot;什么是本地端口转发？&quot;&gt;&lt;/a&gt;什么是本地端口转发？&lt;/h2&gt;&lt;p&gt;所谓本地端口转发，就是&lt;strong&gt;将发送到本地端口的请求，转发到目标端口&lt;/strong&gt;。这样，就可以通过访问本地端口，来访问目标端口的服务。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="端口转发" scheme="https://orzyt.cn/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="jupyter notebook" scheme="https://orzyt.cn/tags/jupyter-notebook/"/>
    
      <category term="tensorboard" scheme="https://orzyt.cn/tags/tensorboard/"/>
    
  </entry>
  
  <entry>
    <title>简化ssh连接服务器流程</title>
    <link href="https://orzyt.cn/posts/ssh-login/"/>
    <id>https://orzyt.cn/posts/ssh-login/</id>
    <published>2018-01-13T03:02:26.000Z</published>
    <updated>2018-11-10T11:47:16.931Z</updated>
    
    <content type="html"><![CDATA[<hr><p>登录远程服务器一般采用<code>ssh</code>（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。</p><h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h2><p>在本机的终端中执行命令 <code>ssh-keygen</code> ，然后根据提示操作即可在目录（默认为<code>~/.ssh</code>）中生成<code>id_rsa</code>（私钥） 和 <code>id_rsa.pub</code>（公钥）文件。</p><a id="more"></a><h2 id="添加-ssh-config-文件"><a href="#添加-ssh-config-文件" class="headerlink" title="添加 ssh config 文件"></a>添加 ssh config 文件</h2><p>根据下列内容，修改（或新建）本机中的<code>~/.ssh/config</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host fastlogin                 # 随便取个名字，用于登录</span><br><span class="line">    HostName xxx.xxx.xxx.xxx   # 主机地址 </span><br><span class="line">    User username              # 用户名</span><br><span class="line">    Port 1234                  # 端口号</span><br></pre></td></tr></table></figure><h2 id="向服务器中添加公钥"><a href="#向服务器中添加公钥" class="headerlink" title="向服务器中添加公钥"></a>向服务器中添加公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在本机中执行]：将公钥文件上传到服务器的用户目录</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx:~/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [此命令在服务器中执行]：将公钥文件添加进服务器的ssh信任列表</span></span><br><span class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p>配置好之后，只需执行下列命令即可快速登录服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastlogin 为之前在ssh config中定义的名字</span></span><br><span class="line">ssh fastlogin</span><br></pre></td></tr></table></figure><h2 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h2><p>现在，如果想要复制本机的文件到服务器上，可以更加简便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 本机源地址 fastlogin:服务器目标地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;登录远程服务器一般采用&lt;code&gt;ssh&lt;/code&gt;（Secure Shell）的方式，为了避免每次登录时手动输入用户名、密码、服务器地址等信息，故进行以下配置来达到简化登录流程。&lt;/p&gt;
&lt;h2 id=&quot;生成-ssh-key&quot;&gt;&lt;a href=&quot;#生成-ssh-key&quot; class=&quot;headerlink&quot; title=&quot;生成 ssh key&quot;&gt;&lt;/a&gt;生成 ssh key&lt;/h2&gt;&lt;p&gt;在本机的终端中执行命令 &lt;code&gt;ssh-keygen&lt;/code&gt; ，然后根据提示操作即可在目录（默认为&lt;code&gt;~/.ssh&lt;/code&gt;）中生成&lt;code&gt;id_rsa&lt;/code&gt;（私钥） 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;（公钥）文件。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="scp" scheme="https://orzyt.cn/tags/scp/"/>
    
  </entry>
  
  <entry>
    <title>常用软件更换国内镜像源</title>
    <link href="https://orzyt.cn/posts/change-mirrors/"/>
    <id>https://orzyt.cn/posts/change-mirrors/</id>
    <published>2018-01-13T02:45:51.000Z</published>
    <updated>2018-11-10T11:47:16.927Z</updated>
    
    <content type="html"><![CDATA[<hr><p>由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。</p><p>以下基于<code>Ubuntu</code>系统介绍相应的换源方式。</p><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>修改（或新建）文件：<code>~/.pip/pip.conf</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>在终端中运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;由于某些原因，国内访问一些国外的软件仓库时比较慢。为了提高下载速度，通常可以更换相应的国内镜像源。&lt;/p&gt;
&lt;p&gt;以下基于&lt;code&gt;Ubuntu&lt;/code&gt;系统介绍相应的换源方式。&lt;/p&gt;
&lt;h2 id=&quot;pip&quot;&gt;&lt;a href=&quot;#pip&quot; class=&quot;headerlink&quot; title=&quot;pip&quot;&gt;&lt;/a&gt;pip&lt;/h2&gt;&lt;p&gt;修改（或新建）文件：&lt;code&gt;~/.pip/pip.conf&lt;/code&gt;，添加以下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[global]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index-url = https://pypi.tuna.tsinghua.edu.cn/simple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pip" scheme="https://orzyt.cn/tags/pip/"/>
    
      <category term="npm" scheme="https://orzyt.cn/tags/npm/"/>
    
      <category term="anaconda" scheme="https://orzyt.cn/tags/anaconda/"/>
    
      <category term="镜像源" scheme="https://orzyt.cn/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
  </entry>
  
</feed>
