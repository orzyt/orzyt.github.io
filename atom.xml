<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-03-01T14:09:34.728Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>David Silver强化学习Lecture3：动态规划</title>
    <link href="https://orzyt.cn/posts/planning-by-dp/"/>
    <id>https://orzyt.cn/posts/planning-by-dp/</id>
    <published>2019-03-01T06:10:25.000Z</published>
    <updated>2019-03-01T14:09:34.728Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/DP.pdf" target="_blank" rel="noopener">Lecture 3: Planning by Dynamic Programming</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9930653" target="_blank" rel="noopener">David Silver强化学习第3课 - 动态规划(中文字幕)</a></p><hr><a id="more"></a><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><p><strong>动态(Dynamic)</strong>: 问题中的时序部分</p></li><li><p><strong>规划(Planning)</strong>: 对问题进行优化</p></li></ul><p>动态规划将问题分解为子问题, 从子问题的解中得到原始问题的解.</p><hr><h3 id="动态规划的性质"><a href="#动态规划的性质" class="headerlink" title="动态规划的性质"></a>动态规划的性质</h3><ul><li><p><strong>最优子结构(Optimal substructure)</strong></p><ul><li>应用最优性原则(Principle of optimality)</li><li>最优解可以从子问题的最优解中得到</li></ul></li><li><p><strong>重叠子问题(Overlapping subproblems)</strong></p><ul><li>相同的子问题出现多次</li><li>问题的解可以被缓存和复用</li></ul></li></ul><p>马尔可夫决策过程满足上面两种性质:</p><blockquote><p><em>贝尔曼方程</em> 给出了问题的递归分解表示, <em>值函数</em> 存储和复用了问题的解.</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a|s) (\mathcal{R}_s^a + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s'))</script></blockquote><hr><h3 id="用动态规划进行Planning"><a href="#用动态规划进行Planning" class="headerlink" title="用动态规划进行Planning"></a>用动态规划进行Planning</h3><p>动态规划假设我们知道MDP的所有知识, 包括状态、行为、转移矩阵、奖励甚至策略等.</p><p>对于<strong>预测(Prediction)</strong>问题: </p><ul><li><p>输入: </p><ul><li>MDP $&lt;\mathcal{S}, \mathcal{A}, \mathcal{P}, \mathcal{R}, \gamma&gt;$ 和 策略 $\pi$</li><li>MRP $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$</li></ul></li><li><p>输出: 值函数 $v_{\pi}$</p></li></ul><p>对于<strong>控制(Control)</strong>问题:</p><ul><li><p>输入:</p><ul><li>MDP $&lt;\mathcal{S}, \mathcal{A}, \mathcal{P}, \mathcal{R}, \gamma&gt;$</li></ul></li><li><p>输出:</p><ul><li>最优值函数 $v_{*}$</li><li>最优策略 $\pi_{*}$</li></ul></li></ul><hr><h2 id="策略评估"><a href="#策略评估" class="headerlink" title="策略评估"></a>策略评估</h2><blockquote><p>问题: 评估一个给定的策略 $\pi$<br>求解: 对贝尔曼期望方程进行迭代, $v_1 \to v_2 \to \dots \to v_{\pi}$</p></blockquote><p>通常使用<strong>同步备份(synchronous backups)</strong>方法:</p><p>对于第 $k+1$ 次迭代, 所有状态 $s$ 在第 $k+1$ 时刻的价值 $v_{k+1}(s)$ 用 $v_k(s’)$ 进行更新, 其中 $s’$ 是 $s$ 的后继状态.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0nb9rn3v4j20ar06eq31.jpg" alt="迭代策略评估" width="30%" height="30%"></p><script type="math/tex; mode=display">\begin{aligned} v _ { k + 1 } ( s ) & = \sum _ { a \in \mathcal { A } } \pi ( a | s ) \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { k } \left( s ^ { \prime } \right) \right) \\\mathbf { v } ^ { k + 1 } & = \mathcal { R } ^ { \pi } + \gamma \mathcal { P } ^ { \pi } \mathbf { v } ^ { k } \end{aligned}</script><hr><p><strong>迭代策略评估算法</strong>:</p><p>迭代策略评估算法用来估计 $V \approx v_{\pi}$.</p><p>这里使用<code>in-place</code>版本, 即只保留一份 $v$ 数组, 没有新旧之分. </p><p>通常来说, 该方法也能收敛到 $v_{\pi}$, 而且收敛速度可能更快.</p><p>终止条件: $\max \limits_ { s \in \mathcal{S} } \left| v _ { k + 1 } ( s ) - v _ { k } ( s ) \right|$ 小于给定的误差 $\Delta$</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0nj071hc6j20km08hq3t.jpg" alt="迭代策略评估伪代码" width="60%" height="60%"></p><hr><p>例子: <strong>Small Gridworld</strong> <a href="https://github.com/orzyt/reinforcement-learning-an-introduction/blob/master/chapter04/grid_world.py" target="_blank" rel="noopener">[代码]</a></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0nbvkvvotj20k00dkdgx.jpg" alt="Small Gridworld" width="50%" height="50%"></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0nc5gkmd8j20e30lkwgd.jpg" alt="Small Gridworld Solution" width="50%" height="50%"></p><hr><h2 id="策略改进"><a href="#策略改进" class="headerlink" title="策略改进"></a>策略改进</h2><p>让我们考虑一个<strong>确定性策略</strong>(即对于一个状态来说, 其采取的动作是确定的, 而不是考虑每个动作的概率) $a = \pi(s)$.</p><blockquote><p>我们可以通过贪心选择来改进策略 $\pi$:</p><script type="math/tex; mode=display">\pi ^ { \prime } ( s ) = \underset { a \in \mathcal { A } } { \operatorname { argmax } } q _ { \pi } ( s , a )</script></blockquote><p>即状态 $s$ 的新策略为令动作值函数 $q_{\pi}(s, a)$ 取得最大值的动作.</p><p>相应地, 动作值函数 $q _ { \pi } \left( s , \pi ^ { \prime } ( s ) \right)$ 得到了改进:</p><script type="math/tex; mode=display">q _ { \pi } \left( s , \pi ^ { \prime } ( s ) \right) = \max _ { a \in \mathcal { A } } q _ { \pi } ( s , a ) \geq q _ { \pi } ( s , \pi ( s ) ) = v _ { \pi } ( s ) \\{\scriptsize 由于是确定性策略, 才会有 v_{\pi}(s) = q_{\pi}(s, \pi(s))}\tag{1}</script><p>注: 确定性策略下的动作值函数 $q_{\pi}(s, a)$ 为:</p><script type="math/tex; mode=display">\begin{aligned} q _ { \pi } ( s , a ) & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v _ { \pi } \left( S _ { t + 1 } \right) | S _ { t } = s , A _ { t } = a \right] \\ & = \sum _ { s ^ { \prime } , r } p \left( s ^ { \prime } , r | s , a \right) \left[ r + \gamma v _ { \pi } \left( s ^ { \prime } \right) \right] \end{aligned}\tag{2}</script><p>从而, 值函数 $v _ { \pi ^ { \prime } } ( s )$ 也得到了改进:</p><script type="math/tex; mode=display">\begin{aligned} v_\pi(s) & \le q_\pi(s,\pi^{'}(s)) {\scriptsize //公式(1)} \\ &={\Bbb E}[R_{t+1} + \gamma v_\pi(S_{t+1})|S_t=s, A_t=\pi^{'}(s)] {\scriptsize //公式(2)} \\&={\Bbb E}_{\pi'}[R_{t+1}+\gamma v_\pi(S_{t+1})|S_t=s]\  {\scriptsize //注意外层是在新策略 \pi^{'} 下求期望} \\   & \le {\Bbb E}_{\pi'}[R_{t+1}+\gamma q_\pi(S_{t+1},\pi'(S_{t+1}))|S_t=s] {\scriptsize //对状态S_{t+1}使用公式(1)} \\  &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma {\Bbb E}_{\pi'}\left[ R_{t+2}+\gamma v_{\pi}\left( S_{t+2}\right) | S_{t+1}, A_{t+1}=\pi^{'}(S_{t+1}) \right] | S_t=s]\\ &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 v_{\pi}\left( S_{t+2} \right)|S_t=s] {\scriptsize //去掉括号内的期望} \\ & \le {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma ^2 q_\pi(S_{t+2},\pi'(S_{t+2}))|S_t=s] {\scriptsize //对状态S_{t+2}使用公式(1)} \\  &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 {\Bbb E}_{\pi'}\left( R_{t+3}+\gamma v_{\pi}\left( S_{t+3} \right) \right)|S_t=s]\\  &= {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\gamma^3 v_{\pi}\left( S_{t+3} \right)|S_t=s]\\  & \vdots \\& \le {\Bbb E}_{\pi'}[R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\gamma^3 R_{t+4} + \dots |S_t=s]\\ &=v_{\pi^{'}}(s) \\ \end{aligned}</script><p>当改进停止时, 有如下等式:</p><script type="math/tex; mode=display">q _ { \pi } \left( s , \pi ^ { \prime } ( s ) \right) = \max _ { a \in \mathcal { A } } q _ { \pi } ( s , a ) = q _ { \pi } ( s , \pi ( s ) ) = v _ { \pi } ( s )\tag{3}</script><p>可以说, 此时公式(3)满足了贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \max _ { a \in \mathcal { A } } q _ { \pi } ( s , a )</script><p>从而, 对所有状态 $s$ 来说, 有$v_{\pi}(s) = v_{*}(s)$, 即策略 $\pi$ 改进到了最优策略.</p><hr><h2 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h2><h3 id="策略迭代-1"><a href="#策略迭代-1" class="headerlink" title="策略迭代"></a>策略迭代</h3><p>给定一个策略 $\pi$, 我们可以首先对策略进行评估, 然后根据值函数 $v_{\pi}$ 进行贪心地改进策略.</p><script type="math/tex; mode=display">\pi _ { 0 } \stackrel { \mathrm { E } } { \longrightarrow } v _ { \pi _ { 0 } } \stackrel { \mathrm { I } } { \longrightarrow } \pi _ { 1 } \stackrel { \mathrm { E } } { \longrightarrow } v _ { \pi _ { 1 } } \stackrel { \mathrm { I } } { \longrightarrow } \pi _ { 2 } \stackrel { \mathrm { E } } { \longrightarrow } \cdots \stackrel { \mathrm { I } } { \longrightarrow } \pi _ { * } \stackrel { \mathrm { E } } { \longrightarrow } v _ { * }</script><p>其中, $\stackrel { \mathrm { E } } { \longrightarrow }$ 表示策略评估, $\stackrel { \mathrm { I } } { \longrightarrow }$ 表示策略改进. </p><ul><li><p><strong>评估(Evaluate):</strong></p><script type="math/tex; mode=display">v _ { \pi } ( s ) = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots | S _ { t } = s \right]</script></li><li><p><strong>改进(Improve):</strong></p><script type="math/tex; mode=display">\pi^{'} = \text{greedy}(v_{\pi})</script></li></ul><p>由于每个策略都比前一个策略更优, 同时一个有限状态的马尔可夫决策过程(finite MDP)仅有有限个策略, 因此该过程一定能够在有限次的迭代中收敛到最优策略 $\pi_{*}$ 和最优值函数 $v_{*}$.</p><hr><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0ncddk93hj20ni0cc0uq.jpg" alt="策略迭代" width="50%" height="50%"></p><hr><p><strong>策略迭代算法:</strong></p><p>策略迭代算法分为: <strong>初始化</strong>, <strong>策略评估</strong> 以及 <strong>策略改进</strong> 三部分.</p><p>其中, 策略改进部分的终止条件为: <strong>是否所有状态的策略不再发生变化</strong>.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0njmn8jy5j20kq0e3760.jpg" alt="策略迭代算法" width="60%" height="60%"></p><hr><p>例子: <strong>Jack’s Car Rental</strong> <a href="https://github.com/orzyt/reinforcement-learning-an-introduction/blob/master/chapter04/car_rental.py" target="_blank" rel="noopener">[代码]</a>  (<em>先占个坑 , 等有时间把这个例子详细写下</em>)</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0ncjvapk8j20ke0ebn32.jpg" alt="Jack’s Car Rental" width="50%" height="50%"></p><p>策略迭代求解结果:</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0nclbnxl1j20jw0dgtam.jpg" alt="Jack’s Car Rental Solution" width="50%" height="50%"></p><p>图中纵坐标是位置 $1$ 的汽车数量, 横坐标是位置 $2$ 的汽车数量, 该问题共有 $21 \times 21$ 个状态. </p><p>图中的等高线将状态划分为不同的区域, 区域内的数值代表相应的策略(正数代表从位置 $1$ 移往位置 $2$ 的汽车数量, 负数则往反方向移动).</p><hr><h3 id="策略迭代的扩展"><a href="#策略迭代的扩展" class="headerlink" title="策略迭代的扩展"></a>策略迭代的扩展</h3><h4 id="改良策略迭代"><a href="#改良策略迭代" class="headerlink" title="改良策略迭代"></a>改良策略迭代</h4><p>策略评估并不需要真正的收敛到 $v_{\pi}$. (比如在 <code>Small Gridworld</code>例子中, 迭代 $k=3$次 即可以得到最优策略.)</p><p>为此我们可以引进终止条件, 如:</p><ul><li>值函数的 $\epsilon$ -收敛</li><li>简单地迭代 $k$ 次便停止策略评估</li></ul><p>或者每次迭代(即 $k=1$ )都对策略进行更新改进, 这种情况等价于<strong>值迭代(value iteration)</strong>.</p><hr><h4 id="广义策略迭代"><a href="#广义策略迭代" class="headerlink" title="广义策略迭代"></a>广义策略迭代</h4><p><strong>广义策略迭代</strong>(Generalized Policy iteration，GPI)指代让策略评估(policy-evaluation)和策略改进(policyimprovement)过程进行交互的一般概念, 其不依赖于两个过程的粒度(granularity)和其他细节.</p><p>几乎所有强化学习方法都可以很好地被描述为GPI. 也就是说, 它们都具有可辨识的策略与值函数. 其中, 策略 $\pi$ 通过相应的值函数 $v$ 进行改进, 而值函数 $V$ 总是趋向策略 $\pi$ 的值函数 $v^{\pi}$. 如下图所示,</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0nik26512j206y0a5dfz.jpg" alt="广义策略迭代" width="20%" height="20%"></p><hr><h2 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h2><p>策略迭代的一个缺点是它的每次迭代都涉及策略评估, 这本身就是一个需要对状态集进行多次扫描的耗时迭代计算. </p><p>而在值迭代的过程中, 并没有出现显式的策略, 并且中间过程的值函数可能也不和任何策略对应.</p><hr><h3 id="最优性原则"><a href="#最优性原则" class="headerlink" title="最优性原则"></a>最优性原则</h3><p>一个最优策略可以被分解为两部分:</p><ul><li>当前状态的最优动作 $A_{*}$</li><li>后继状态 $S^{\prime}$ 的最优策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0nk02i8apj20mi06v75b.jpg" alt="最优性原则" width="60%" height="60%"></p><p>该原则的意思是说, 一个策略 $\pi(a|s)$ 在状态 $s$ 取到最优值函数 $v_{\pi}(s) = v_{*}(s)$ <strong>当且仅当</strong> 对于所有从状态 $s$ 出发可到达的状态 $s^{\prime}$, 策略 $\pi$ 也能够在状态 $s^{\prime}$ 取到最优值函数.</p><hr><h3 id="确定性值迭代"><a href="#确定性值迭代" class="headerlink" title="确定性值迭代"></a>确定性值迭代</h3><p>如果我们已经知道子问题的最优解 $v_{*}(s^{\prime})$, 那么状态 $s$ 的最优解可以通过向前看(lookahead)一步得到, 这称为<strong>值迭代(Value Iteration)</strong>:</p><script type="math/tex; mode=display">v_{*}(s) \gets \max \limits_{a \in \mathcal{A}} \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{*}(s') \right)</script><hr><p><strong>值迭代算法:</strong></p><p>值迭代算法和策略迭代算法一样, 是用来估计最优策略 $\pi_{*}$ 的, 它将策略评估和策略改进有效地结合在了一起.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0nkt7xfz0j20kn09k0ts.jpg" alt="值迭代算法" width="60%" height="60%"></p><hr><h2 id="同步动态规划算法总结"><a href="#同步动态规划算法总结" class="headerlink" title="同步动态规划算法总结"></a>同步动态规划算法总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">贝尔曼方程</th><th style="text-align:center">算法</th></tr></thead><tbody><tr><td style="text-align:center">预测(Prediction)</td><td style="text-align:center">贝尔曼期望方程</td><td style="text-align:center">迭代策略评估</td></tr><tr><td style="text-align:center">控制(Control)</td><td style="text-align:center">贝尔曼期望方程 + 贪心策略改进</td><td style="text-align:center">策略迭代</td></tr><tr><td style="text-align:center">控制(Control)</td><td style="text-align:center">贝尔曼最优方程</td><td style="text-align:center">值迭代</td></tr></tbody></table></div><p>对于有 $m$ 个动作和 $n$ 个状态 的MDP来说, 每次迭代的时间复杂度如下:</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">复杂度</th></tr></thead><tbody><tr><td style="text-align:center">$v_{\pi}(s)$ or $v_{*}(s)$</td><td style="text-align:center">$\mathcal{O}(mn^2)$</td></tr><tr><td style="text-align:center">$q_{\pi}(s, a)$ or $q_{*}(s, a)$</td><td style="text-align:center">$\mathcal{O}(m^2n^2)$</td></tr></tbody></table></div><hr><h2 id="动态规划的扩展"><a href="#动态规划的扩展" class="headerlink" title="动态规划的扩展"></a>动态规划的扩展</h2><h3 id="异步动态规划"><a href="#异步动态规划" class="headerlink" title="异步动态规划"></a>异步动态规划</h3><p>同步DP算法的主要缺点是每次迭代都需要对整个状态集进行扫描, 这对于状态数非常多的MDP来说耗费巨大. 而异步DP算法则将所有的状态独立地,以任意顺序进行备份, 并且每个状态的更新次数不一, 这可以显著地减少计算量.</p><p>为了保证算法的正确收敛, 异步动态规划算法必须保证<strong>所有状态都能够持续地被更新</strong>(continue to update the values of all the states), 也就是说在任何时刻任何状态都有可能被更新, 而不能忽略某个状态.</p><p>异步DP算法主要有三种简单的思想:</p><ul><li>就地动态规划(<em>In-place</em> dynamic programming)</li><li>优先扫描(<em>Prioritised sweeping</em>)</li><li>实时动态规划(<em>Real-time</em> dynamic programming)</li></ul><hr><h4 id="就地动态规划"><a href="#就地动态规划" class="headerlink" title="就地动态规划"></a>就地动态规划</h4><p>同步DP保留值函数的两个备份, $v_{new}$ 和 $v_{old}$</p><script type="math/tex; mode=display">{\color{red} {v_{new}(s)}} \gets \max \limits_{a \in \mathcal{A}} \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} {\color{red} {v_{old}(s')}} \right)</script><p>就地值迭代只保留值函数的一个备份.</p><script type="math/tex; mode=display">{\color{red} {v(s)}} \gets \max \limits_{a \in \mathcal{A}} \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} {\color{red} {v(s')}} \right)</script><hr><h4 id="优先扫描"><a href="#优先扫描" class="headerlink" title="优先扫描"></a>优先扫描</h4><p>使用贝尔曼误差的大小来进行状态的选择:</p><script type="math/tex; mode=display">\left| \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v \left( s ^ { \prime } \right) \right) - v ( s ) \right|</script><ul><li><p>仅备份有最大贝尔曼误差的状态</p></li><li><p>在每次备份后, 需要更新受到影响的状态(即备份状态的前驱状态)的贝尔曼误差</p></li><li><p>可以使用优先队列进行实现</p></li></ul><hr><h4 id="实时动态规划"><a href="#实时动态规划" class="headerlink" title="实时动态规划"></a>实时动态规划</h4><ul><li>思想: <strong>只使用和Agent相关的状态</strong></li><li>使用Agent的经验来进行状态的选择</li><li>在每个时间步 $S_t, A_t, R_{t+1}$ 对状态 $S_t$ 进行备份</li></ul><script type="math/tex; mode=display">{\color{red} {v \left( S _ { t } \right)}} \gets \max _ { a \in \mathcal { A } } \left( \mathcal { R } _ { {\color{red}{S _ { t }}} } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { {\color{red} {S _ { t }}} s ^ { \prime }}  ^ { a } {\color{red} {v \left( s ^ { \prime } \right)}} \right)</script><hr><h3 id="全宽和采样备份"><a href="#全宽和采样备份" class="headerlink" title="全宽和采样备份"></a>全宽和采样备份</h3><h4 id="全宽备份"><a href="#全宽备份" class="headerlink" title="全宽备份"></a>全宽备份</h4><ul><li><p>DP使用<strong>全宽备份</strong>(<em>full-width</em> backups)</p></li><li><p>对于每次备份(不管同步还是异步)</p><ul><li>每个后继状态和动作都会被考虑进去</li><li>需要知道MDP转移矩阵和奖励函数</li></ul></li><li><p>对于大规模DP问题会遇到维数灾难</p></li><li><p>进行一次备份都太奢侈了</p></li></ul><hr><h4 id="采样备份"><a href="#采样备份" class="headerlink" title="采样备份"></a>采样备份</h4><p><strong>采样备份(Sample Backups)</strong>使用采样的奖励和采样的转移 $&lt; S , A , R , S ^ { \prime } &gt;$ 来替代奖励函数 $\mathcal{R}$ 和 转移矩阵 $\mathcal{P}$. </p><p>采样备份的优点:</p><ul><li><strong>Model-free</strong>: 不需要知道MDP的先验知识</li><li>通过采样<strong>缓解维数灾难</strong></li><li><strong>备份代价成为常量</strong>, 独立于状态数 $n = |\mathcal{S}|$</li></ul><hr><h2 id="压缩映射"><a href="#压缩映射" class="headerlink" title="压缩映射"></a>压缩映射</h2><p>关于上面的种种算法, 我们可能会有如下疑问:</p><ul><li>值迭代是否会收敛到 $v_{*}$ ?</li><li>迭代策略评估是否会收敛到 $v_{\pi}$ ?</li><li>策略迭代是否会收敛到 $v_{*}$ ?</li><li>解唯一吗 ?</li><li>算法收敛速度有多快 ?</li></ul><p>为了解决这些问题, 需要引入压缩映射(contraction mapping)理论.<br>可以参考: <a href="https://zhuanlan.zhihu.com/p/39279611" target="_blank" rel="noopener">如何证明迭代式策略评价、值迭代和策略迭代的收敛性？</a></p><hr><p>(关于压缩映射理论有时间再补充, 先到这里吧…)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/DP.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 3: Planning by Dynamic Programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9930653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver强化学习第3课 - 动态规划(中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="动态规划" scheme="https://orzyt.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>David Silver强化学习Lecture2：马尔可夫决策过程</title>
    <link href="https://orzyt.cn/posts/markov-decision-processes/"/>
    <id>https://orzyt.cn/posts/markov-decision-processes/</id>
    <published>2019-02-27T07:38:18.000Z</published>
    <updated>2019-03-01T06:11:25.343Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf" target="_blank" rel="noopener">Lecture 2: Markov Decision Processes</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9833386" target="_blank" rel="noopener">David Silver强化学习第2课 - 马尔科夫决策过程(中文字幕)</a></p><hr><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><h3 id="马尔可夫决策过程简介"><a href="#马尔可夫决策过程简介" class="headerlink" title="马尔可夫决策过程简介"></a>马尔可夫决策过程简介</h3><p><strong>马尔可夫决策过程(Markov Decision Processes, MDPs)</strong>形式上用来描述强化学习中的环境.</p><p>其中,环境是<strong>完全可观测的(fully observable)</strong>,即当前状态可以完全表征过程.</p><p>几乎所有的强化学习问题都能用MDPs来描述：</p><ul><li>最优控制问题可以描述成连续MDPs;</li><li>部分观测环境可以转化成MDPs;</li><li>赌博机问题是只有一个状态的MDPs.</li></ul><hr><h3 id="马尔可夫性质"><a href="#马尔可夫性质" class="headerlink" title="马尔可夫性质"></a>马尔可夫性质</h3><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫性质" width="60%" height="60%"></p><p>马尔科夫性质(Markov Property)表明: <strong>未来只与现在有关,而与过去无关.</strong></p><hr><h3 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h3><p>对于一个马尔可夫状态$S$及其后继状态$S’$,其状态转移概率由下式定义:</p><script type="math/tex; mode=display">\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]</script><p><strong>状态转移矩阵(State Transition Matrix)$\mathcal{P}$</strong>定义了从所有状态$S$转移到所有后继状态$S’$的概率.</p><script type="math/tex; mode=display">\mathcal { P } = \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \dots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n 1 } } & { \cdots } & { \mathcal { P } _ { n n } } \end{array} \right]</script><p>其中,$n$为状态个数,且矩阵的每行和为1.</p><hr><h3 id="马尔可夫过程-1"><a href="#马尔可夫过程-1" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p><strong>马尔可夫过程(Markov Process)</strong>是一个无记忆的随机过程(memoryless random process).</p><p>即,随机状态$S_1, S_2, \dots$序列具有马尔可夫性质.</p><blockquote><p>马尔可夫过程(或马尔可夫链)是一个二元组$&lt;\mathcal{S}, \mathcal{P}&gt;$</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li></ul></blockquote><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l1vm9xkzj20c80act96.jpg" alt="Example: Student Markov Chain" width="50%" height="50%"></p><p>圆圈代表状态, 箭头代表状态之间的转移, 数值代表转移概率.</p><p>状态转移矩阵$\mathcal{P}$如下:</p><script type="math/tex; mode=display">{\mathcal P} =\begin{bmatrix}  & C1 & C2 & C3 &  Pass & Pub & FB & Sleep\\  C1 & &0.5 &  &   & & 0.5 & \\ C2  & & &  0.8 & & & &0.2\\ C3  & & &  & 0.6& 0.4& &\\ Pass  & & &  & & & &1.0\\ Pub  &0.2 & 0.4& 0.4 & & & &\\ FB  &0.1 & &  & & & 0.9 &\\ Sleep  & & &  & & & &1.0 \end{bmatrix}</script><hr><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p><strong>马尔可夫奖励过程(Markov Reward Process, MRP)</strong>是<em>带有奖励的马尔可夫链</em>.</p><blockquote><p>马尔可夫奖励过程是一个四元组&lt;$\mathcal{S}$, $\mathcal{P}$, <font color="red">$\mathcal{R}$</font>, <font color="red">$\mathcal{\gamma}$</font>&gt;</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li><li><font color="red"> $\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right]$ </font></li><li><font color="red"> $\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </font></li></ul></blockquote><p><img src="http://wx1.sinaimg.cn/large/8662e3cegy1g0l2klvnixj20cf0aowf0.jpg" alt="Example: Student MRP" width="50%" height="50%"></p><h3 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h3><blockquote><p><strong>回报(Return)</strong> $G_t$ 是从时间 $t$ 开始的总折扣奖励.</p><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } R _ { t + k + 1 }</script></blockquote><ul><li>折扣因子 $\gamma \in [ 0,1 ]$ 表示未来的奖励在当前的价值. 由于未来的奖励充满不确定性, 因此需要乘上折扣因子;</li><li>$\gamma$ 接近 $0$ 表明更注重当前的奖励(myopic);</li><li>$\gamma$ 接近 $1$ 表明更具有远见(far-sighted).</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function) $v(s)$ 表示一个状态 $s$ 的长期价值(long-term value).</p><blockquote><p>一个马尔可夫奖励过程(MRP)的<strong>状态值函数 $v(s)$</strong>是从状态 $s$ 开始的期望回报.</p><script type="math/tex; mode=display">v ( s ) = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right]</script></blockquote><hr><h3 id="MRPs的贝尔曼方程"><a href="#MRPs的贝尔曼方程" class="headerlink" title="MRPs的贝尔曼方程"></a>MRPs的贝尔曼方程</h3><p>值函数可以被分解为两部分:</p><ul><li>立即奖励 $R_{t+1}$</li><li>后继状态的折扣价值 $\gamma v(S_{t+1})$</li></ul><script type="math/tex; mode=display">\begin{aligned} v ( s ) & = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \gamma ^ { 2 } R _ { t + 3 } + \ldots | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma \left( R _ { t + 2 } + \gamma R _ { t + 3 } + \ldots \right) | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma G _ { t + 1 } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \mathbb { E } \left[ \gamma G _ { t + 1 } | S _ { t } = s \right]\\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \gamma v \left( S _ { t + 1 } \right)\\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v \left( S _ { t + 1 } \right) | S _ { t } = s \right] \end{aligned}\tag{1}\label{eq:mrp-bellman-equation}</script><p>上式表明, $t$ 时刻的状态 $S_t$ 和 $t+1$ 时刻的状态 $S_{t+1}$ 的值函数之间满足递推关系. </p><p>该递推式也称为<strong>贝尔曼方程(Bellman Equation)</strong>.</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0l3fh3jb3j207802zglh.jpg" alt="Bellman Equation for MRPs" width="30%" height="30%"></p><p>如果已知概率转移矩阵 $\mathcal{P}$, 则可将公式\eqref{eq:mrp-bellman-equation}变形为:</p><script type="math/tex; mode=display">v ( s ) = \mathcal { R } _ { s } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } v \left( s ^ { \prime } \right)\tag{2}\label{eq:mrp-bellman-equation-2}</script><p>例子:</p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l3pbm9ixj20c30b5mxp.jpg" alt="Example: Bellman Equation for Student MRP" width="40%" height="40%"></p><p><strong>贝尔曼方程的矩阵形式:</strong></p><p>可将公式\eqref{eq:mrp-bellman-equation-2}改写为矩阵形式:</p><script type="math/tex; mode=display">v = \mathcal { R } + \gamma \mathcal { P } v</script><p>其中, $v$ 为一个列向量, 向量的元素为每个状态的值函数.</p><script type="math/tex; mode=display">\left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right] = \left[ \begin{array} { c } { \mathcal { R } _ { 1 } } \\ { \vdots } \\ { \mathcal { R } _ { n } } \end{array} \right] + \gamma \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \ldots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n1 } } & { \ldots } & { \mathcal { P } _ { n n } } \end{array} \right] \left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right]</script><p>观测贝尔曼方程的矩阵形式, 可知其为线性方程, 可直接求解如下.</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\v & = ( I - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R }\end{aligned}</script><p>计算复杂度为: $\mathcal{O}(n^3)$. 因此, 只适合直接求解小规模的MRP问题.</p><p>对于大规模的MRP问题, 通常采取以下的迭代方法:</p><ul><li>动态规划(Dynamic programming)</li><li>蒙特卡洛评估(Monte-Carlo evaluation)</li><li>时序差分学习(Temporal-Difference learning)</li></ul><hr><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p><strong>马尔可夫决策过程(Markov Decision Process, MDP)</strong>是<em>带有决策的马尔可夫奖励过程</em>.</p><blockquote><p>马尔可夫决策过程是一个五元组&lt;$\mathcal{S}$, <font color="red">$\mathcal{A}$</font>, $\mathcal{P}$, $\mathcal{R}$, $\mathcal{\gamma}$&gt;</p><ul><li>$\mathcal{S}$: 有限的状态集</li><li><font color="red"> $\mathcal{A}$: 有限的动作集</font></li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } ^ {a}= \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } ^ {a} = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </li></ul></blockquote><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0l47drh0vj20g30d93zc.jpg" alt="Example: Student MDP" width="45%" height="45%"></p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote><p><strong>策略(Policy) $\pi$</strong> 是给定状态的动作分布.</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script></blockquote><ul><li>策略完全决定智能体的行为;</li><li>MDP策略值依赖于当前状态(无关历史);</li><li>策略是固定的(与时间无关). $A _ { t } \sim \pi ( \cdot | S _ { t } ) , \forall t &gt; 0$</li></ul><p>给定一个马尔可夫决策过程 $M = &lt;\mathcal{S},\mathcal{A}, \mathcal{P}, \mathcal{R}, \mathcal{\gamma}&gt;$ 和 一个策略 $\pi$, 其可以转化为<em>马尔可夫过程</em>和<em>马尔可夫奖励过程</em>.</p><ul><li><p>状态序列 $S_1, S_2, \dots$ 是马尔科夫决策过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}&gt;$.</p></li><li><p>状态和奖励序列 $S_1, R_2, S_2, \dots$ 是马尔科夫奖励过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$.</p></li></ul><p>其中,</p><script type="math/tex; mode=display">\mathcal{P}_{s,s'}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{P}_{ss'}^{a}</script><script type="math/tex; mode=display">\mathcal{R}_{s}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{R}_{s}^{a}</script><hr><h3 id="值函数-1"><a href="#值函数-1" class="headerlink" title="值函数"></a>值函数</h3><p><strong>值函数(Value Function)</strong>可分为<strong>状态值函数(state-value function)</strong>和<strong>动作值函数(action-value function)</strong>.</p><blockquote><p>MDP的<strong>状态值函数 $v_{\pi}(s)$ </strong>是从状态 $s$ 开始, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ G_t | S_t = s \right]</script><p>MDP的<strong>动作值函数 $q_{\pi}(s, a)$ </strong>是从状态 $s$ 开始, 采取动作 $a$, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ G_t | S_t = s, A_t = a \right]</script></blockquote><hr><h3 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h3><p>状态值函数可以被分解为两部分, <strong>立即奖励 + 后继状态的折扣价值</strong>.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t = s \right]</script><p>动作值函数也可以类似地分解.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma q_{\pi}(S_{t+1}, A_{t+1}) | S_t = s, A_t = a \right]</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0ldl141fkj20bb04xq2x.jpg" width="40%" height="40%"></p><p>上图中, 空心圆圈代表状态, 实心圆圈代表动作.</p><p>在已知策略 $\pi$ 的情况下, 状态值函数 $v_{\pi}(s)$ 可以用动作值函数 $q_{\pi}(s, a)$ 进行表示:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a | s) q_{\pi}(s, a) \tag{3}\label{eq:mdp-state-value-function}</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0lds6jc80j20b004rmx6.jpg" width="40%" height="40%"></p><p>同理, 动作值函数 $q_{\pi}(s, a)$ 也可以用状态值函数 $v_{\pi}(s)$ 进行表示:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s') \tag{4}\label{eq:mdp-action-value-function}</script><hr><p><strong>状态值函数的贝尔曼期望方程:</strong></p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0le5yxgeij20b706hdfx.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-action-value-function}代入公式\eqref{eq:mdp-state-value-function}中, 可得状态值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{\pi}(s')  \right)</script><hr><p><strong>动作值函数的贝尔曼期望方程:</strong></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0le9cf2u7j20bd05wwek.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-state-value-function}代入公式\eqref{eq:mdp-action-value-function}中, 可得动作值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} \sum \limits_{a' \in \mathcal{A}} \pi (a' | s') q_{\pi}(s', a')</script><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lecy0oxgj20h90dcwfj.jpg" alt="状态值函数的贝尔曼期望方程示例" width="55%" height="55%"></p><hr><p><strong>贝尔曼期望方程的矩阵形式:</strong></p><script type="math/tex; mode=display">v_{\pi} = \mathcal{R}^{\pi} + \gamma \mathcal{P}^{\pi} v_{\pi}</script><p>可直接求解:</p><script type="math/tex; mode=display">v_{\pi} = (I - \gamma \mathcal{P}^{\pi})^{-1} \mathcal{R}^{\pi}</script><hr><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><blockquote><p><strong>最优状态值函数(optimal state-value function)</strong> $v_{*}(s)$ 是所有策略中最大的值函数.</p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{\pi}v_{\pi}(s)</script><p><strong>最优动作值函数(optimal action-value function)</strong> $v_{*}(s)$ 是所有策略中最大的动作值函数.</p><script type="math/tex; mode=display">q_{*}(s, a) = \max \limits_{\pi}q_{\pi}(s, a)</script></blockquote><ul><li>最优值函数代表了MDP的最好性能.</li><li>当得知最优值函数时, MDP可被认为”已解决”.</li></ul><hr><p>例子: </p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leoxfaylj20h70ee75c.jpg" alt="Student MDP中的最优状态值函数" width="50%" height="50%"></p><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leqk38l4j20hh0eg75i.jpg" alt="Student MDP中的最优动作值函数" width="50%" height="50%"></p><p>注: 根据公式\eqref{eq:mdp-state-value-function}, Pub动作的最优值应为 $q_{*} = +1 + (0.2 \times 6 + 0.4 \times 8 + 0.4 \times 10) = 9.4$.</p><hr><h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><p>首先定义策略之间的偏序关系, 使得策略之间可以进行比较:</p><script type="math/tex; mode=display">\pi \geq \pi ' \quad \text{if} \quad  v_{\pi}(s) \geq v_{\pi '}(s) , \forall s</script><p>对于任意的MDP来说:</p><ul><li>存在一个最优策略 $\pi_{*}$, 使得 $\pi_{*} \geq \pi, \forall \pi$</li><li>所有的最优策略都能取得最优值函数 $v_{\pi_{*}}(s) = v_{*}(s)$</li><li>所有的最优策略都能取得最优动作值函数 $q_{\pi_{*}}(s, a) = v_{*}(s, a)$</li></ul><hr><p><strong>寻找最优策略</strong></p><p>一个最优策略可以通过最大化所有的 $q_{*}(s, a)$ 得到:</p><script type="math/tex; mode=display">\pi_{*} \left( a | s \right) = \left \{ \begin{array}{ll}1 \ {\mathbb {if}} \ a = \operatorname*{argmax} \limits_{a \in \mathcal{A}} \ q_{*} \left( s,a \right) \\              0 \ {\mathbb {otherwise}}              \end{array} \right.</script><ul><li>对于任意的MDP, 总存在确定的最优策略</li><li>如果我们知道 $q_{*}(s, a)$, 则可以立即得到最优策略</li></ul><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lfhg0710j20hn0ehjsl.jpg" alt="Student MDP的最优策略" width="50%" height="50%"></p><p>图中红色弧线表示每个状态的最优决策.</p><hr><h3 id="贝尔曼最优方程"><a href="#贝尔曼最优方程" class="headerlink" title="贝尔曼最优方程"></a>贝尔曼最优方程</h3><p>$v_{*}$可以通过贝尔曼最优方程递归得到:</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0lfkujh38j20b804uaa2.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{a} q_{*}(s, a)\tag{5}\label{eq:state-bellman-optimal-equation}</script><p>与公式\eqref{eq:mdp-state-value-function}的贝尔曼期望方程进行比较, 此时不再取均值, 而是取最大值.</p><hr><p>$q_{*}$与公式\eqref{eq:mdp-action-value-function}类似:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m10t6s7vj208003a747.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)\tag{6}\label{eq:action-bellman-optimal-equation}</script><hr><p><strong>状态值函数的贝尔曼最优方程</strong></p><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0m14a2fenj208m04xq2x.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:action-bellman-optimal-equation}代入公式\eqref{eq:state-bellman-optimal-equation}可得 $v_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><hr><p><strong>动作值函数的贝尔曼最优方程</strong></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0m18irqg7j208804bgll.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:state-bellman-optimal-equation}代入公式\eqref{eq:action-bellman-optimal-equation}可得 $q_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><hr><p>例子:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m1ato6q2j20d70atjs3.jpg" alt="Student MDP贝尔曼最优方程" width="50%" height="50%"></p><hr><h3 id="贝尔曼最优方程的求解"><a href="#贝尔曼最优方程的求解" class="headerlink" title="贝尔曼最优方程的求解"></a>贝尔曼最优方程的求解</h3><p>贝尔曼最优方程<strong>不是线性的</strong>(因为有取$max$操作), 因此没有封闭解(Closed-form solution).</p><p>通常采用迭代求解方法:</p><ul><li>值迭代(Value Iteration)</li><li>策略迭代(Policy Iteration)</li><li>Q-Learning</li><li>Sarsa</li></ul><h2 id="MDP的扩展"><a href="#MDP的扩展" class="headerlink" title="MDP的扩展"></a>MDP的扩展</h2><ul><li>无穷和连续的MDPs</li><li>部分可观测的MDPs</li><li>不折扣, 平均奖励MDPs</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 2: Markov Decision Processes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9833386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver强化学习第2课 - 马尔科夫决策过程(中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="马尔可夫决策过程" scheme="https://orzyt.cn/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>David Silver强化学习Lecture1：强化学习简介</title>
    <link href="https://orzyt.cn/posts/introduction-to-rl/"/>
    <id>https://orzyt.cn/posts/introduction-to-rl/</id>
    <published>2019-02-25T14:56:13.000Z</published>
    <updated>2019-02-27T11:03:59.961Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf" target="_blank" rel="noopener">Lecture 1: Introduction to Reinforcement Learning</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9831889" target="_blank" rel="noopener">David Silver深度强化学习第1课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="强化学习的特征"><a href="#强化学习的特征" class="headerlink" title="强化学习的特征"></a>强化学习的特征</h2><p>作为机器学习的一个分支，强化学习主要的特征为:</p><ul><li><p>无监督,仅有奖励信号；</p></li><li><p>反馈有延迟,不是瞬时的;</p></li><li><p>时间是重要的(由于是时序数据,不是独立同分布的);</p></li><li><p>Agent的动作会影响后续得到的数据;</p></li></ul><hr><h2 id="强化学习的概念"><a href="#强化学习的概念" class="headerlink" title="强化学习的概念"></a>强化学习的概念</h2><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>奖励(Rewards) $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何.</p><p><strong>Agent的目标</strong>: 最大化累积奖励(maximise cumulative reward).</p><p>强化学习基于<strong>奖励假设(reward hypothesis)</strong>.</p><blockquote><p><strong>奖励假设(Reward Hypothesis)</strong>:<br>所有强化学习任务的目标都可以被描述为最大化期望累积奖励.</p></blockquote><hr><h3 id="序贯决策"><a href="#序贯决策" class="headerlink" title="序贯决策"></a>序贯决策</h3><p><strong>序贯决策(Sequential Decision Making)的目标</strong>: 选择合适的动作最大化将来的累积奖励.</p><ul><li>动作可能会产生长期后果；</li><li>奖励会有延迟性;</li><li>牺牲立即回报可能会获得更多的长期回报.</li></ul><hr><h3 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k2ozf0lzj20aq0bxtb1.jpg" alt="Agent和环境" width="35%" height="35%"></p><p>智能体(Agent)在每个时刻$t$会:</p><ul><li>执行动作(Action)$A_t$;</li><li>接收观测(Observation)$O_t$;</li><li>接收标量奖励(Reward)$R_t$.</li></ul><p>而环境(Environment)则会:</p><ul><li>接收动作(Action)$A_t$;</li><li>产生观测(Observation)$O_{t+1}$;</li><li>产生标量奖励(Reward)$R_{t+1}$.</li></ul><hr><h3 id="历史与状态"><a href="#历史与状态" class="headerlink" title="历史与状态"></a>历史与状态</h3><blockquote><p><strong>历史(History):</strong>由一系列观测,动作和奖励构成.</p></blockquote><script type="math/tex; mode=display">H_t = O_1, R_1, A_1, \dots, A_{t-1}, O_t, R_t</script><p>下一步将发生什么取决于历史:</p><ul><li>智能体选择的action;</li><li>环境选择的observations/rewards.</li></ul><blockquote><p><strong>状态(State)</strong>:用来决定接下来会发生什么的信息.</p></blockquote><p><strong>状态是历史的函数:</strong></p><script type="math/tex; mode=display">S_t = f(H_t)</script><hr><h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3akygqpj20b20cptb5.jpg" alt="环境状态" width="35%" height="35%"></p><p>环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见.</p><p>即使$S_{t}^{e}$可见,也可能包含不相关信息.</p><hr><h4 id="智能体状态"><a href="#智能体状态" class="headerlink" title="智能体状态"></a>智能体状态</h4><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k3e8bw4aj20b00cx419.jpg" alt="智能体状态" width="35%" height="35%"></p><p>智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息.</p><p>可以写成历史的函数: $S_{t}^{a} = f(H_t)$</p><hr><h4 id="信息状态"><a href="#信息状态" class="headerlink" title="信息状态"></a>信息状态</h4><p><strong>信息状态(也称为马尔科夫状态)</strong>: 包含历史中所有有用的信息.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫状态定义" width="60%" height="60%"></p><p>马尔科夫状态表明: <strong>未来只与现在有关,而与过去无关.</strong></p><p>其中,<strong>环境状态$S_t^e$</strong>和<strong>历史$H_t$</strong>具有马尔科夫性质.</p><hr><h4 id="Rat-Example"><a href="#Rat-Example" class="headerlink" title="Rat Example"></a>Rat Example</h4><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k3trc5qxj20ny0doq88.jpg" alt="Rat Example" width="60%" height="60%"></p><ul><li><p>假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击)</p></li><li><p>假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪)</p></li><li><p>假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知)</p></li></ul><hr><h4 id="完全可观测环境"><a href="#完全可观测环境" class="headerlink" title="完全可观测环境"></a>完全可观测环境</h4><p><strong>完全可观测性(Full observability):</strong> 智能体可以直接观测到环境状态,即</p><script type="math/tex; mode=display">O_t = S_t^a = S_t^e</script><ul><li>智能体状态 = 环境状态 = 信息状态</li><li>实际上是马尔科夫决策过程(Markov Decision Process, MDP)</li></ul><hr><h4 id="部分可观测环境"><a href="#部分可观测环境" class="headerlink" title="部分可观测环境"></a>部分可观测环境</h4><p><strong>部分可观测性(Partial observability):</strong> 智能体不能够直接观测到环境.</p><p>如,机器人不能通过摄像头得知自身的绝对位置.</p><ul><li>智能体状态 $\neq$ 环境状态</li><li>部分可观测马尔科夫决策过程(POMDP)</li></ul><p>此时,智能体必须构建其自身的状态表示 $S_t^a$,比如:</p><ul><li>完全的历史: $S_t^a = H_t$;</li><li>环境状态的置信度: $S _ { t } ^ { a } = \left( \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { 1 } \right] , \ldots , \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { n } \right] \right)$;</li><li>循环神经网络: $S_t^a = \sigma \left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\right)$</li></ul><hr><h2 id="智能体的构成"><a href="#智能体的构成" class="headerlink" title="智能体的构成"></a>智能体的构成</h2><p>智能体主要包含以下几种成分:</p><ul><li><strong>策略(Policy)</strong>: 智能体的行为函数;</li><li><strong>值函数(Value Function)</strong>: 每个state或action的好坏;</li><li><strong>模型(Model)</strong>: 智能体对环境的表示.</li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>策略(Policy)是智能体的行为;</li><li>是<strong>状态</strong>到<strong>动作</strong>的映射;</li><li>确定性策略: $a = \pi(s)$;</li><li>随机性策略: $\pi(a|s) = \mathbb{P} \left[ A_{t} = a | S_{t} = s\right]$</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function)是对于未来奖励的预测.</p><ul><li>用于评价状态的好坏;</li><li>因此可以用来选择动作.</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots | S_{t} = s \right]</script><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型(Model)用来预测环境接下来会做什么.</p><ul><li>$\mathcal{P}$: 预测下一个状态.<script type="math/tex; mode=display">\mathcal{P}_{ss'}^{a} = \mathbb{P} \left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\right]</script></li><li>$\mathcal{R}$: 预测下一个(立即)奖励.<script type="math/tex; mode=display">\mathcal{R}_{s}^{a} = \mathbb{E} \left[ R_{t+1} | S_{t} = s, A_{t} = a\right]</script></li></ul><hr><h3 id="Maze-Example"><a href="#Maze-Example" class="headerlink" title="Maze Example"></a>Maze Example</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k4norup9j20mj092dg5.jpg" alt="Maze Example" width="60%" height="60%"></p><hr><p><strong>策略表示:</strong></p><p>箭头表示每个状态的策略 $\pi(s)$.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k4u9pdcdj20f10c5q38.jpg" alt="Maze Example: Policy" width="40%" height="40%"></p><hr><p><strong>值函数表示:</strong></p><p>数值表示每个状态的值 $v_{\pi}(s)$.</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k4w9vn7wj20f60cct8y.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><p><strong>模型表示:</strong></p><p>智能体可能对环境建立内部模型</p><ul><li>网格布局表示转移模型 $\mathcal{P}_{ss’}^{a}$;</li><li>数值表示每个状态的立即奖励 $\mathcal{R}_{s}^{a}$.</li></ul><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k51h023dj20c109kt8o.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><h3 id="智能体的分类"><a href="#智能体的分类" class="headerlink" title="智能体的分类"></a>智能体的分类</h3><p>按智能体的成分分类:</p><ul><li>基于值函数(Value Based)</li><li>基于策略(Policy Based)</li><li>演员-评论家(Actor Critic)</li></ul><p>或者按有无模型分类:</p><ul><li>无模型(Model Free)</li><li>基于模型(Model Based)</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k55tidg0j20f30eaab9.jpg" alt="智能体分类" width="40%" height="40%"></p><hr><h2 id="强化学习的问题"><a href="#强化学习的问题" class="headerlink" title="强化学习的问题"></a>强化学习的问题</h2><h3 id="学习与规划"><a href="#学习与规划" class="headerlink" title="学习与规划"></a>学习与规划</h3><p><strong>强化学习</strong></p><ul><li>环境的初始状态未知;</li><li>智能体与环境进行交互;</li><li>智能体提升其策略.</li></ul><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0k5dprnn4j20p80ejn0q.jpg" alt="学习" width="60%" height="60%"></p><p><strong>规划</strong></p><ul><li>环境的模型已知;</li><li>智能体通过模型进行计算,无须与外部进行交互;</li><li>智能体提升其策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k5eleerwj20ok0df0u3.jpg" alt="规划" width="60%" height="60%"></p><hr><h3 id="探索和利用"><a href="#探索和利用" class="headerlink" title="探索和利用"></a>探索和利用</h3><p>强化学习是一种试错(trial-and-error)学习.</p><p>智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励.</p><ul><li><strong>探索(Exploration):</strong> 从环境中寻找更多信息;</li><li><strong>利用(Exploitation):</strong> 利用已知信息使奖励最大化.</li></ul><p>探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果.</p><hr><h3 id="预测和控制"><a href="#预测和控制" class="headerlink" title="预测和控制"></a>预测和控制</h3><ul><li><strong>预测(Prediction):</strong> 对未来进行评估.</li></ul><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k5ryo676j20nz0ds0tn.jpg" alt="Gridworld Example: Prediction" width="60%" height="60%"></p><hr><ul><li><strong>控制(Control):</strong> 最优化未来的结果.</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k5r6vdmgj20nv0eot9w.jpg" alt="Gridworld Example: Control" width="60%" height="60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 1: Introduction to Reinforcement Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9831889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第1课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode637 Average of Levels in Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/average-of-levels-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode657 Robot Return to Origin</title>
    <link href="https://orzyt.cn/posts/leetcode657-robot-return-to-origin/"/>
    <id>https://orzyt.cn/posts/leetcode657-robot-return-to-origin/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-return-to-or
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode654 Maximum Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode654-maximum-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode654-maximum-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode661 Image Smoother</title>
    <link href="https://orzyt.cn/posts/leetcode661-image-smoother/"/>
    <id>https://orzyt.cn/posts/leetcode661-image-smoother/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/image-smoother/&quot; t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665 Non-decreasing Array</title>
    <link href="https://orzyt.cn/posts/leetcode665-non-decreasing-array/"/>
    <id>https://orzyt.cn/posts/leetcode665-non-decreasing-array/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/non-decreasing-arr
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617 Merge Two Binary Trees</title>
    <link href="https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/"/>
    <id>https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/</id>
    <published>2019-02-08T09:02:05.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode606 Construct String from Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/</id>
    <published>2019-02-08T09:01:50.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-string-f
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode599 Minimum Index Sum of Two Lists</title>
    <link href="https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
    <id>https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/</id>
    <published>2019-02-08T09:01:34.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-index-sum-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode38 Count and Say</title>
    <link href="https://orzyt.cn/posts/leetcode38-count-and-say/"/>
    <id>https://orzyt.cn/posts/leetcode38-count-and-say/</id>
    <published>2019-02-08T09:00:37.000Z</published>
    <updated>2019-02-08T10:25:59.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/&quot; ta
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-02-26T11:20:51.367Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1j4up5oj21cb0ik489.jpg" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jnv2szj210109oacr.jpg" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jytblsj20of0kgwhp.jpg" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1kfbt7kj217u0e8dlk.jpg" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k1kr4sx8j215r0k9wlm.jpg" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1l9pm84j20x007ht9n.jpg" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lnsllgj20tr0m1qdq.jpg" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lvxp55j20zt0i4n3g.jpg" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1m4b63ij20fv0ib40x.jpg" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k1mg2yrlj20hk0ca0v4.jpg" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mmsrz1j20n808dwfx.jpg" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k1mtlmpmj20ck04sq3j.jpg" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mz40h8j21640ad0wf.jpg" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="https://ws1.sinaimg.cn/large/8662e3cegy1g0k1n6hmq9j20lo09g0wz.jpg" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈支持向量机的推导</title>
    <link href="https://orzyt.cn/posts/svm/"/>
    <id>https://orzyt.cn/posts/svm/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-02-28T11:38:06.625Z</updated>
    
    <content type="html"><![CDATA[<hr><iframe src="/svm.html" scrolling="no" width="100%" height="11100px"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;iframe src=&quot;/svm.html&quot; scrolling=&quot;no&quot; width=&quot;100%&quot; height=&quot;11100px&quot;&gt;&lt;/iframe&gt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://orzyt.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="支持向量机" scheme="https://orzyt.cn/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
      <category term="SVM" scheme="https://orzyt.cn/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/leetcode575-distribute-candies/"/>
    <id>https://orzyt.cn/posts/leetcode575-distribute-candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2019-02-08T10:26:00.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/leetcode566-reshape-the-matrix/"/>
    <id>https://orzyt.cn/posts/leetcode566-reshape-the-matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2019-02-08T10:26:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/leetcode563-binary-tree-tilt/"/>
    <id>https://orzyt.cn/posts/leetcode563-binary-tree-tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2019-02-08T10:26:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/leetcode561-array-partition-i/"/>
    <id>https://orzyt.cn/posts/leetcode561-array-partition-i/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2019-02-08T10:26:00.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/"/>
    <id>https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2019-02-08T10:26:00.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
