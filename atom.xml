<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬涛的博客</title>
  
  <subtitle>上善若水·大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://orzyt.cn/"/>
  <updated>2019-02-28T04:59:26.781Z</updated>
  <id>https://orzyt.cn/</id>
  
  <author>
    <name>orzyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>David Silver强化学习Lecture2：马尔可夫决策过程</title>
    <link href="https://orzyt.cn/posts/markov-decision-processes/"/>
    <id>https://orzyt.cn/posts/markov-decision-processes/</id>
    <published>2019-02-27T07:38:18.000Z</published>
    <updated>2019-02-28T04:59:26.781Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf" target="_blank" rel="noopener">Lecture 2: Markov Decision Processes</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9833386" target="_blank" rel="noopener">David Silver深度强化学习第2课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><h3 id="马尔可夫决策过程简介"><a href="#马尔可夫决策过程简介" class="headerlink" title="马尔可夫决策过程简介"></a>马尔可夫决策过程简介</h3><p><strong>马尔可夫决策过程(Markov Decision Processes, MDPs)</strong>形式上用来描述强化学习中的环境.</p><p>其中,环境是<strong>完全可观测的(fully observable)</strong>,即当前状态可以完全表征过程.</p><p>几乎所有的强化学习问题都能用MDPs来描述：</p><ul><li>最优控制问题可以描述成连续MDPs;</li><li>部分观测环境可以转化成MDPs;</li><li>赌博机问题是只有一个状态的MDPs.</li></ul><hr><h3 id="马尔可夫性质"><a href="#马尔可夫性质" class="headerlink" title="马尔可夫性质"></a>马尔可夫性质</h3><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫性质" width="60%" height="60%"></p><p>马尔科夫性质(Markov Property)表明: <strong>未来只与现在有关,而与过去无关.</strong></p><hr><h3 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h3><p>对于一个马尔可夫状态$S$及其后继状态$S’$,其状态转移概率由下式定义:</p><script type="math/tex; mode=display">\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]</script><p><strong>状态转移矩阵(State Transition Matrix)$\mathcal{P}$</strong>定义了从所有状态$S$转移到所有后继状态$S’$的概率.</p><script type="math/tex; mode=display">\mathcal { P } = \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \dots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n 1 } } & { \cdots } & { \mathcal { P } _ { n n } } \end{array} \right]</script><p>其中,$n$为状态个数,且矩阵的每行和为1.</p><hr><h3 id="马尔可夫过程-1"><a href="#马尔可夫过程-1" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p><strong>马尔可夫过程(Markov Process)</strong>是一个无记忆的随机过程(memoryless random process).</p><p>即,随机状态$S_1, S_2, \dots$序列具有马尔可夫性质.</p><blockquote><p>马尔可夫过程(或马尔可夫链)是一个二元组$&lt;\mathcal{S}, \mathcal{P}&gt;$</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li></ul></blockquote><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l1vm9xkzj20c80act96.jpg" alt="Example: Student Markov Chain" width="50%" height="50%"></p><p>圆圈代表状态, 箭头代表状态之间的转移, 数值代表转移概率.</p><p>状态转移矩阵$\mathcal{P}$如下:</p><script type="math/tex; mode=display">{\mathcal P} =\begin{bmatrix}  & C1 & C2 & C3 &  Pass & Pub & FB & Sleep\\  C1 & &0.5 &  &   & & 0.5 & \\ C2  & & &  0.8 & & & &0.2\\ C3  & & &  & 0.6& 0.4& &\\ Pass  & & &  & & & &1.0\\ Pub  &0.2 & 0.4& 0.4 & & & &\\ FB  &0.1 & &  & & & 0.9 &\\ Sleep  & & &  & & & &1.0 \end{bmatrix}</script><hr><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p><strong>马尔可夫奖励过程(Markov Reward Process, MRP)</strong>是<em>带有奖励的马尔可夫链</em>.</p><blockquote><p>马尔可夫奖励过程是一个四元组&lt;$\mathcal{S}$, $\mathcal{P}$, <font color="red">$\mathcal{R}$</font>, <font color="red">$\mathcal{\gamma}$</font>&gt;</p><ul><li>$\mathcal{S}$: (有限)状态集</li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } = \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s \right]$</li><li><font color="red"> $\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right]$ </font></li><li><font color="red"> $\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </font></li></ul></blockquote><p><img src="http://wx1.sinaimg.cn/large/8662e3cegy1g0l2klvnixj20cf0aowf0.jpg" alt="Example: Student MRP" width="50%" height="50%"></p><h3 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h3><blockquote><p><strong>回报(Return)</strong> $G_t$ 是从时间 $t$ 开始的总折扣奖励.</p><script type="math/tex; mode=display">G _ { t } = R _ { t + 1 } + \gamma R _ { t + 2 } + \ldots = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } R _ { t + k + 1 }</script></blockquote><ul><li>折扣因子 $\gamma \in [ 0,1 ]$ 表示未来的奖励在当前的价值. 由于未来的奖励充满不确定性, 因此需要乘上折扣因子;</li><li>$\gamma$ 接近 $0$ 表明更注重当前的奖励(myopic);</li><li>$\gamma$ 接近 $1$ 表明更具有远见(far-sighted).</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function) $v(s)$ 表示一个状态 $s$ 的长期价值(long-term value).</p><blockquote><p>一个马尔可夫奖励过程(MRP)的<strong>状态值函数 $v(s)$</strong>是从状态 $s$ 开始的期望回报.</p><script type="math/tex; mode=display">v ( s ) = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right]</script></blockquote><hr><h3 id="MRPs的贝尔曼方程"><a href="#MRPs的贝尔曼方程" class="headerlink" title="MRPs的贝尔曼方程"></a>MRPs的贝尔曼方程</h3><p>值函数可以被分解为两部分:</p><ul><li>立即奖励 $R_{t+1}$</li><li>后继状态的折扣价值 $\gamma v(S_{t+1})$</li></ul><script type="math/tex; mode=display">\begin{aligned} v ( s ) & = \mathbb { E } \left[ G _ { t } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma R _ { t + 2 } + \gamma ^ { 2 } R _ { t + 3 } + \ldots | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma \left( R _ { t + 2 } + \gamma R _ { t + 3 } + \ldots \right) | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma G _ { t + 1 } | S _ { t } = s \right] \\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \mathbb { E } \left[ \gamma G _ { t + 1 } | S _ { t } = s \right]\\ & = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s \right] + \gamma v \left( S _ { t + 1 } \right)\\ & = \mathbb { E } \left[ R _ { t + 1 } + \gamma v \left( S _ { t + 1 } \right) | S _ { t } = s \right] \end{aligned}\tag{1}\label{eq:mrp-bellman-equation}</script><p>上式表明, $t$ 时刻的状态 $S_t$ 和 $t+1$ 时刻的状态 $S_{t+1}$ 的值函数之间满足递推关系. </p><p>该递推式也称为<strong>贝尔曼方程(Bellman Equation)</strong>.</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0l3fh3jb3j207802zglh.jpg" alt="Bellman Equation for MRPs" width="30%" height="30%"></p><p>如果已知概率转移矩阵 $\mathcal{P}$, 则可将公式\eqref{eq:mrp-bellman-equation}变形为:</p><script type="math/tex; mode=display">v ( s ) = \mathcal { R } _ { s } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } v \left( s ^ { \prime } \right)\tag{2}\label{eq:mrp-bellman-equation-2}</script><p>例子:</p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0l3pbm9ixj20c30b5mxp.jpg" alt="Example: Bellman Equation for Student MRP" width="40%" height="40%"></p><p><strong>贝尔曼方程的矩阵形式:</strong></p><p>可将公式\eqref{eq:mrp-bellman-equation-2}改写为矩阵形式:</p><script type="math/tex; mode=display">v = \mathcal { R } + \gamma \mathcal { P } v</script><p>其中, $v$ 为一个列向量, 向量的元素为每个状态的值函数.</p><script type="math/tex; mode=display">\left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right] = \left[ \begin{array} { c } { \mathcal { R } _ { 1 } } \\ { \vdots } \\ { \mathcal { R } _ { n } } \end{array} \right] + \gamma \left[ \begin{array} { c c c } { \mathcal { P } _ { 11 } } & { \ldots } & { \mathcal { P } _ { 1 n } } \\ { \vdots } & { } & { } \\ { \mathcal { P } _ { n1 } } & { \ldots } & { \mathcal { P } _ { n n } } \end{array} \right] \left[ \begin{array} { c } { v ( 1 ) } \\ { \vdots } \\ { v ( n ) } \end{array} \right]</script><p>观测贝尔曼方程的矩阵形式, 可知其为线性方程, 可直接求解如下.</p><script type="math/tex; mode=display">\begin{aligned} v & = \mathcal { R } + \gamma \mathcal { P } v \\( I - \gamma \mathcal { P } ) v & = \mathcal { R } \\v & = ( I - \gamma \mathcal { P } ) ^ { - 1 } \mathcal { R }\end{aligned}</script><p>计算复杂度为: $\mathcal{O}(n^3)$. 因此, 只适合直接求解小规模的MRP问题.</p><p>对于大规模的MRP问题, 通常采取以下的迭代方法:</p><ul><li>动态规划(Dynamic programming)</li><li>蒙特卡洛评估(Monte-Carlo evaluation)</li><li>时序差分学习(Temporal-Difference learning)</li></ul><hr><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p><strong>马尔可夫决策过程(Markov Decision Process, MDP)</strong>是<em>带有决策的马尔可夫奖励过程</em>.</p><blockquote><p>马尔可夫决策过程是一个五元组&lt;$\mathcal{S}$, <font color="red">$\mathcal{A}$</font>, $\mathcal{P}$, $\mathcal{R}$, $\mathcal{\gamma}$&gt;</p><ul><li>$\mathcal{S}$: 有限的状态集</li><li><font color="red"> $\mathcal{A}$: 有限的动作集</font></li><li>$\mathcal{P}$: 状态转移概率矩阵, $\mathcal { P } _ { s s ^ { \prime } } ^ {a}= \mathbb { P } \left[ S _ { t + 1 } = s ^ { \prime } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\mathcal{R}$: 奖励函数, $\mathcal { R } _ { s } ^ {a} = \mathbb { E } \left[ R _ { t + 1 } | S _ { t } = s, A _ { t } = a \right]$</li><li>$\gamma$: 折扣因子, $\gamma \in [ 0,1 ]$ </li></ul></blockquote><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0l47drh0vj20g30d93zc.jpg" alt="Example: Student MDP" width="45%" height="45%"></p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote><p><strong>策略(Policy) $\pi$</strong> 是给定状态的动作分布.</p><script type="math/tex; mode=display">\pi ( a | s ) = \mathbb { P } \left[ A _ { t } = a | S _ { t } = s \right]</script></blockquote><ul><li>策略完全决定智能体的行为;</li><li>MDP策略值依赖于当前状态(无关历史);</li><li>策略是固定的(与时间无关). $A _ { t } \sim \pi ( \cdot | S _ { t } ) , \forall t &gt; 0$</li></ul><p>给定一个马尔可夫决策过程 $M = &lt;\mathcal{S},\mathcal{A}, \mathcal{P}, \mathcal{R}, \mathcal{\gamma}&gt;$ 和 一个策略 $\pi$, 其可以转化为<em>马尔可夫过程</em>和<em>马尔可夫奖励过程</em>.</p><ul><li><p>状态序列 $S_1, S_2, \dots$ 是马尔科夫决策过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}&gt;$.</p></li><li><p>状态和奖励序列 $S_1, R_2, S_2, \dots$ 是马尔科夫奖励过程 $&lt;\mathcal{S}, \mathcal{P}^{\pi}, \mathcal{R}^{\pi}, \gamma&gt;$.</p></li></ul><p>其中,</p><script type="math/tex; mode=display">\mathcal{P}_{s,s'}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{P}_{ss'}^{a}</script><script type="math/tex; mode=display">\mathcal{R}_{s}^{\pi} = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \mathcal{R}_{s}^{a}</script><hr><h3 id="值函数-1"><a href="#值函数-1" class="headerlink" title="值函数"></a>值函数</h3><p><strong>值函数(Value Function)</strong>可分为<strong>状态值函数(state-value function)</strong>和<strong>动作值函数(action-value function)</strong>.</p><blockquote><p>MDP的<strong>状态值函数 $v_{\pi}(s)$ </strong>是从状态 $s$ 开始, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ G_t | S_t = s \right]</script><p>MDP的<strong>动作值函数 $q_{\pi}(s, a)$ </strong>是从状态 $s$ 开始, 采取动作 $a$, 然后按照策略 $\pi$ 决策所获得的期望回报.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ G_t | S_t = s, A_t = a \right]</script></blockquote><hr><h3 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h3><p>状态值函数可以被分解为两部分, <strong>立即奖励 + 后继状态的折扣价值</strong>.</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t = s \right]</script><p>动作值函数也可以类似地分解.</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma q_{\pi}(S_{t+1}, A_{t+1}) | S_t = s, A_t = a \right]</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0ldl141fkj20bb04xq2x.jpg" width="40%" height="40%"></p><p>上图中, 空心圆圈代表状态, 实心圆圈代表动作.</p><p>在已知策略 $\pi$ 的情况下, 状态值函数 $v_{\pi}(s)$ 可以用动作值函数 $q_{\pi}(s, a)$ 进行表示:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi(a | s) q_{\pi}(s, a) \tag{3}\label{eq:mdp-state-value-function}</script><hr><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0lds6jc80j20b004rmx6.jpg" width="40%" height="40%"></p><p>同理, 动作值函数 $q_{\pi}(s, a)$ 也可以用状态值函数 $v_{\pi}(s)$ 进行表示:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a}v_{\pi}(s') \tag{4}\label{eq:mdp-action-value-function}</script><hr><p><strong>状态值函数的贝尔曼期望方程:</strong></p><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0le5yxgeij20b706hdfx.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-action-value-function}代入公式\eqref{eq:mdp-state-value-function}中, 可得状态值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum \limits_{a \in \mathcal{A}} \pi (a | s) \left( \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} v_{\pi}(s')  \right)</script><hr><p><strong>动作值函数的贝尔曼期望方程:</strong></p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0le9cf2u7j20bd05wwek.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:mdp-state-value-function}代入公式\eqref{eq:mdp-action-value-function}中, 可得动作值函数的贝尔曼期望方程:</p><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathcal{R}_{s}^{a} + \gamma \sum \limits_{s' \in \mathcal{S}} \mathcal{P}_{ss'}^{a} \sum \limits_{a' \in \mathcal{A}} \pi (a' | s') q_{\pi}(s', a')</script><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lecy0oxgj20h90dcwfj.jpg" alt="状态值函数的贝尔曼期望方程示例" width="55%" height="55%"></p><hr><p><strong>贝尔曼期望方程的矩阵形式:</strong></p><script type="math/tex; mode=display">v_{\pi} = \mathcal{R}^{\pi} + \gamma \mathcal{P}^{\pi} v_{\pi}</script><p>可直接求解:</p><script type="math/tex; mode=display">v_{\pi} = (I - \gamma \mathcal{P}^{\pi})^{-1} \mathcal{R}^{\pi}</script><hr><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><blockquote><p><strong>最优状态值函数(optimal state-value function)</strong> $v_{*}(s)$ 是所有策略中最大的值函数.</p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{\pi}v_{\pi}(s)</script><p><strong>最优动作值函数(optimal action-value function)</strong> $v_{*}(s)$ 是所有策略中最大的动作值函数.</p><script type="math/tex; mode=display">q_{*}(s, a) = \max \limits_{\pi}q_{\pi}(s, a)</script></blockquote><ul><li>最优值函数代表了MDP的最好性能.</li><li>当得知最优值函数时, MDP可被认为”已解决”.</li></ul><hr><p>例子: </p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leoxfaylj20h70ee75c.jpg" alt="Student MDP中的最优状态值函数" width="50%" height="50%"></p><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0leqk38l4j20hh0eg75i.jpg" alt="Student MDP中的最优动作值函数" width="50%" height="50%"></p><p>注: 根据公式\eqref{eq:mdp-state-value-function}, Pub动作的最优值应为 $q_{*} = +1 + (0.2 \times 6 + 0.4 \times 8 + 0.4 \times 10) = 9.4$.</p><hr><h3 id="最优策略"><a href="#最优策略" class="headerlink" title="最优策略"></a>最优策略</h3><p>首先定义策略之间的偏序关系, 使得策略之间可以进行比较:</p><script type="math/tex; mode=display">\pi \geq \pi ' \quad \text{if} \quad  v_{\pi}(s) \geq v_{\pi '}(s) , \forall s</script><p>对于任意的MDP来说:</p><ul><li>存在一个最优策略 $\pi_{*}$, 使得 $\pi_{*} \geq \pi, \forall \pi$</li><li>所有的最优策略都能取得最优值函数 $v_{\pi_{*}}(s) = v_{*}(s)$</li><li>所有的最优策略都能取得最优动作值函数 $q_{\pi_{*}}(s, a) = v_{*}(s, a)$</li></ul><hr><p><strong>寻找最优策略</strong></p><p>一个最优策略可以通过最大化所有的 $q_{*}(s, a)$ 得到:</p><script type="math/tex; mode=display">\pi_{*} \left( a | s \right) = \left \{ \begin{array}{ll}1 \ {\mathbb {if}} \ a = \operatorname*{argmax} \limits_{a \in \mathcal{A}} \ q_{*} \left( s,a \right) \\              0 \ {\mathbb {otherwise}}              \end{array} \right.</script><ul><li>对于任意的MDP, 总存在确定的最优策略</li><li>如果我们知道 $q_{*}(s, a)$, 则可以立即得到最优策略</li></ul><hr><p>例子:</p><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0lfhg0710j20hn0ehjsl.jpg" alt="Student MDP的最优策略" width="50%" height="50%"></p><p>图中红色弧线表示每个状态的最优决策.</p><hr><h3 id="贝尔曼最优方程"><a href="#贝尔曼最优方程" class="headerlink" title="贝尔曼最优方程"></a>贝尔曼最优方程</h3><p>$v_{*}$可以通过贝尔曼最优方程递归得到:</p><p><img src="https://ws1.sinaimg.cn/large/8662e3cegy1g0lfkujh38j20b804uaa2.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">v_{*}(s) = \max \limits_{a} q_{*}(s, a)\tag{5}\label{eq:state-bellman-optimal-equation}</script><p>与公式\eqref{eq:mdp-state-value-function}的贝尔曼期望方程进行比较, 此时不再取均值, 而是取最大值.</p><hr><p>$q_{*}$与公式\eqref{eq:mdp-action-value-function}类似:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m10t6s7vj208003a747.jpg" width="40%" height="40%"></p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)\tag{6}\label{eq:action-bellman-optimal-equation}</script><hr><p><strong>状态值函数的贝尔曼最优方程</strong></p><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0m14a2fenj208m04xq2x.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:action-bellman-optimal-equation}代入公式\eqref{eq:state-bellman-optimal-equation}可得 $v_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">v _ { * } ( s ) = \max _ { a } \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } v _ { * } \left( s ^ { \prime } \right)</script><hr><p><strong>动作值函数的贝尔曼最优方程</strong></p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0m18irqg7j208804bgll.jpg" width="40%" height="40%"></p><p>将公式\eqref{eq:state-bellman-optimal-equation}代入公式\eqref{eq:action-bellman-optimal-equation}可得 $q_{*}$ 的贝尔曼最优方程:</p><script type="math/tex; mode=display">q _ { * } ( s , a ) = \mathcal { R } _ { s } ^ { a } + \gamma \sum _ { s ^ { \prime } \in \mathcal { S } } \mathcal { P } _ { s s ^ { \prime } } ^ { a } \max _ { a ^ { \prime } } q _ { * } \left( s ^ { \prime } , a ^ { \prime } \right)</script><hr><p>例子:</p><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0m1ato6q2j20d70atjs3.jpg" alt="Student MDP贝尔曼最优方程" width="50%" height="50%"></p><hr><h3 id="贝尔曼最优方程的求解"><a href="#贝尔曼最优方程的求解" class="headerlink" title="贝尔曼最优方程的求解"></a>贝尔曼最优方程的求解</h3><p>贝尔曼最优方程<strong>不是线性的</strong>(因为有取$max$操作), 因此没有封闭解(Closed-form solution).</p><p>通常采用迭代求解方法:</p><ul><li>值迭代(Value Iteration)</li><li>策略迭代(Policy Iteration)</li><li>Q-Learning</li><li>Sarsa</li></ul><h2 id="MDP的扩展"><a href="#MDP的扩展" class="headerlink" title="MDP的扩展"></a>MDP的扩展</h2><ul><li>无穷和连续的MDPs</li><li>部分可观测的MDPs</li><li>不折扣, 平均奖励MDPs</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 2: Markov Decision Processes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9833386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第2课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="马尔可夫决策过程" scheme="https://orzyt.cn/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>David Silver强化学习Lecture1：强化学习简介</title>
    <link href="https://orzyt.cn/posts/introduction-to-rl/"/>
    <id>https://orzyt.cn/posts/introduction-to-rl/</id>
    <published>2019-02-25T14:56:13.000Z</published>
    <updated>2019-02-27T11:03:59.961Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>课件</strong>：<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf" target="_blank" rel="noopener">Lecture 1: Introduction to Reinforcement Learning</a></p><p><strong>视频</strong>：<a href="https://www.bilibili.com/video/av9831889" target="_blank" rel="noopener">David Silver深度强化学习第1课 - 简介 (中文字幕)</a></p><hr><a id="more"></a><h2 id="强化学习的特征"><a href="#强化学习的特征" class="headerlink" title="强化学习的特征"></a>强化学习的特征</h2><p>作为机器学习的一个分支，强化学习主要的特征为:</p><ul><li><p>无监督,仅有奖励信号；</p></li><li><p>反馈有延迟,不是瞬时的;</p></li><li><p>时间是重要的(由于是时序数据,不是独立同分布的);</p></li><li><p>Agent的动作会影响后续得到的数据;</p></li></ul><hr><h2 id="强化学习的概念"><a href="#强化学习的概念" class="headerlink" title="强化学习的概念"></a>强化学习的概念</h2><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>奖励(Rewards) $R_t$ 是一个标量的反馈信号,表示Agent在 $t$ 时刻的表现如何.</p><p><strong>Agent的目标</strong>: 最大化累积奖励(maximise cumulative reward).</p><p>强化学习基于<strong>奖励假设(reward hypothesis)</strong>.</p><blockquote><p><strong>奖励假设(Reward Hypothesis)</strong>:<br>所有强化学习任务的目标都可以被描述为最大化期望累积奖励.</p></blockquote><hr><h3 id="序贯决策"><a href="#序贯决策" class="headerlink" title="序贯决策"></a>序贯决策</h3><p><strong>序贯决策(Sequential Decision Making)的目标</strong>: 选择合适的动作最大化将来的累积奖励.</p><ul><li>动作可能会产生长期后果；</li><li>奖励会有延迟性;</li><li>牺牲立即回报可能会获得更多的长期回报.</li></ul><hr><h3 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h3><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k2ozf0lzj20aq0bxtb1.jpg" alt="Agent和环境" width="35%" height="35%"></p><p>智能体(Agent)在每个时刻$t$会:</p><ul><li>执行动作(Action)$A_t$;</li><li>接收观测(Observation)$O_t$;</li><li>接收标量奖励(Reward)$R_t$.</li></ul><p>而环境(Environment)则会:</p><ul><li>接收动作(Action)$A_t$;</li><li>产生观测(Observation)$O_{t+1}$;</li><li>产生标量奖励(Reward)$R_{t+1}$.</li></ul><hr><h3 id="历史与状态"><a href="#历史与状态" class="headerlink" title="历史与状态"></a>历史与状态</h3><blockquote><p><strong>历史(History):</strong>由一系列观测,动作和奖励构成.</p></blockquote><script type="math/tex; mode=display">H_t = O_1, R_1, A_1, \dots, A_{t-1}, O_t, R_t</script><p>下一步将发生什么取决于历史:</p><ul><li>智能体选择的action;</li><li>环境选择的observations/rewards.</li></ul><blockquote><p><strong>状态(State)</strong>:用来决定接下来会发生什么的信息.</p></blockquote><p><strong>状态是历史的函数:</strong></p><script type="math/tex; mode=display">S_t = f(H_t)</script><hr><h4 id="环境状态"><a href="#环境状态" class="headerlink" title="环境状态"></a>环境状态</h4><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3akygqpj20b20cptb5.jpg" alt="环境状态" width="35%" height="35%"></p><p>环境状态 $S_{t}^{e}$ 是环境的私有表示,通常对于智能体来说该状态不可见.</p><p>即使$S_{t}^{e}$可见,也可能包含不相关信息.</p><hr><h4 id="智能体状态"><a href="#智能体状态" class="headerlink" title="智能体状态"></a>智能体状态</h4><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k3e8bw4aj20b00cx419.jpg" alt="智能体状态" width="35%" height="35%"></p><p>智能体状态 $S_{t}^{a}$ 是智能体的内部表示,包含其用来决定下一步动作的信息,也是强化学习算法使用的信息.</p><p>可以写成历史的函数: $S_{t}^{a} = f(H_t)$</p><hr><h4 id="信息状态"><a href="#信息状态" class="headerlink" title="信息状态"></a>信息状态</h4><p><strong>信息状态(也称为马尔科夫状态)</strong>: 包含历史中所有有用的信息.</p><p><img src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k3nzaa8yj20mn0593ym.jpg" alt="马尔科夫状态定义" width="60%" height="60%"></p><p>马尔科夫状态表明: <strong>未来只与现在有关,而与过去无关.</strong></p><p>其中,<strong>环境状态$S_t^e$</strong>和<strong>历史$H_t$</strong>具有马尔科夫性质.</p><hr><h4 id="Rat-Example"><a href="#Rat-Example" class="headerlink" title="Rat Example"></a>Rat Example</h4><p><img src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k3trc5qxj20ny0doq88.jpg" alt="Rat Example" width="60%" height="60%"></p><ul><li><p>假如个体状态=序列中的后三个事件(不包括电击、获得奶酪，下同),事件序列3的结果会是什么? (答案是：电击)</p></li><li><p>假如个体状态=亮灯、响铃和拉电闸各自事件发生的次数,那么事件序列3的结果又是什么? (答案是：奶酪)</p></li><li><p>假如个体状态=完整的事件序列,那结果又是什么? (答案是：未知)</p></li></ul><hr><h4 id="完全可观测环境"><a href="#完全可观测环境" class="headerlink" title="完全可观测环境"></a>完全可观测环境</h4><p><strong>完全可观测性(Full observability):</strong> 智能体可以直接观测到环境状态,即</p><script type="math/tex; mode=display">O_t = S_t^a = S_t^e</script><ul><li>智能体状态 = 环境状态 = 信息状态</li><li>实际上是马尔科夫决策过程(Markov Decision Process, MDP)</li></ul><hr><h4 id="部分可观测环境"><a href="#部分可观测环境" class="headerlink" title="部分可观测环境"></a>部分可观测环境</h4><p><strong>部分可观测性(Partial observability):</strong> 智能体不能够直接观测到环境.</p><p>如,机器人不能通过摄像头得知自身的绝对位置.</p><ul><li>智能体状态 $\neq$ 环境状态</li><li>部分可观测马尔科夫决策过程(POMDP)</li></ul><p>此时,智能体必须构建其自身的状态表示 $S_t^a$,比如:</p><ul><li>完全的历史: $S_t^a = H_t$;</li><li>环境状态的置信度: $S _ { t } ^ { a } = \left( \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { 1 } \right] , \ldots , \mathbb { P } \left[ S _ { t } ^ { e } = s ^ { n } \right] \right)$;</li><li>循环神经网络: $S_t^a = \sigma \left(S_{t-1}^{a}W_{s} + O_{t}W_{o}\right)$</li></ul><hr><h2 id="智能体的构成"><a href="#智能体的构成" class="headerlink" title="智能体的构成"></a>智能体的构成</h2><p>智能体主要包含以下几种成分:</p><ul><li><strong>策略(Policy)</strong>: 智能体的行为函数;</li><li><strong>值函数(Value Function)</strong>: 每个state或action的好坏;</li><li><strong>模型(Model)</strong>: 智能体对环境的表示.</li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>策略(Policy)是智能体的行为;</li><li>是<strong>状态</strong>到<strong>动作</strong>的映射;</li><li>确定性策略: $a = \pi(s)$;</li><li>随机性策略: $\pi(a|s) = \mathbb{P} \left[ A_{t} = a | S_{t} = s\right]$</li></ul><hr><h3 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h3><p>值函数(Value Function)是对于未来奖励的预测.</p><ul><li>用于评价状态的好坏;</li><li>因此可以用来选择动作.</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_{\pi} \left[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \dots | S_{t} = s \right]</script><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型(Model)用来预测环境接下来会做什么.</p><ul><li>$\mathcal{P}$: 预测下一个状态.<script type="math/tex; mode=display">\mathcal{P}_{ss'}^{a} = \mathbb{P} \left[ S_{t+1} = s' | S_{t} = s, A_{t} = a\right]</script></li><li>$\mathcal{R}$: 预测下一个(立即)奖励.<script type="math/tex; mode=display">\mathcal{R}_{s}^{a} = \mathbb{E} \left[ R_{t+1} | S_{t} = s, A_{t} = a\right]</script></li></ul><hr><h3 id="Maze-Example"><a href="#Maze-Example" class="headerlink" title="Maze Example"></a>Maze Example</h3><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k4norup9j20mj092dg5.jpg" alt="Maze Example" width="60%" height="60%"></p><hr><p><strong>策略表示:</strong></p><p>箭头表示每个状态的策略 $\pi(s)$.</p><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k4u9pdcdj20f10c5q38.jpg" alt="Maze Example: Policy" width="40%" height="40%"></p><hr><p><strong>值函数表示:</strong></p><p>数值表示每个状态的值 $v_{\pi}(s)$.</p><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k4w9vn7wj20f60cct8y.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><p><strong>模型表示:</strong></p><p>智能体可能对环境建立内部模型</p><ul><li>网格布局表示转移模型 $\mathcal{P}_{ss’}^{a}$;</li><li>数值表示每个状态的立即奖励 $\mathcal{R}_{s}^{a}$.</li></ul><p><img src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k51h023dj20c109kt8o.jpg" alt="Maze Example: Value Function" width="40%" height="40%"></p><hr><h3 id="智能体的分类"><a href="#智能体的分类" class="headerlink" title="智能体的分类"></a>智能体的分类</h3><p>按智能体的成分分类:</p><ul><li>基于值函数(Value Based)</li><li>基于策略(Policy Based)</li><li>演员-评论家(Actor Critic)</li></ul><p>或者按有无模型分类:</p><ul><li>无模型(Model Free)</li><li>基于模型(Model Based)</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k55tidg0j20f30eaab9.jpg" alt="智能体分类" width="40%" height="40%"></p><hr><h2 id="强化学习的问题"><a href="#强化学习的问题" class="headerlink" title="强化学习的问题"></a>强化学习的问题</h2><h3 id="学习与规划"><a href="#学习与规划" class="headerlink" title="学习与规划"></a>学习与规划</h3><p><strong>强化学习</strong></p><ul><li>环境的初始状态未知;</li><li>智能体与环境进行交互;</li><li>智能体提升其策略.</li></ul><p><img src="https://ws4.sinaimg.cn/large/8662e3cegy1g0k5dprnn4j20p80ejn0q.jpg" alt="学习" width="60%" height="60%"></p><p><strong>规划</strong></p><ul><li>环境的模型已知;</li><li>智能体通过模型进行计算,无须与外部进行交互;</li><li>智能体提升其策略</li></ul><p><img src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k5eleerwj20ok0df0u3.jpg" alt="规划" width="60%" height="60%"></p><hr><h3 id="探索和利用"><a href="#探索和利用" class="headerlink" title="探索和利用"></a>探索和利用</h3><p>强化学习是一种试错(trial-and-error)学习.</p><p>智能体需要从与环境的交互中找到一种好的策略,同时不损失过多的奖励.</p><ul><li><strong>探索(Exploration):</strong> 从环境中寻找更多信息;</li><li><strong>利用(Exploitation):</strong> 利用已知信息使奖励最大化.</li></ul><p>探索和利用同等重要,即使根据已有信息选择出的最优动作可以得到不错的奖励,不妨尝试全新的动作对环境进行探索,也许可以得到更好的结果.</p><hr><h3 id="预测和控制"><a href="#预测和控制" class="headerlink" title="预测和控制"></a>预测和控制</h3><ul><li><strong>预测(Prediction):</strong> 对未来进行评估.</li></ul><p><img src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k5ryo676j20nz0ds0tn.jpg" alt="Gridworld Example: Prediction" width="60%" height="60%"></p><hr><ul><li><strong>控制(Control):</strong> 最优化未来的结果.</li></ul><p><img src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k5r6vdmgj20nv0eot9w.jpg" alt="Gridworld Example: Control" width="60%" height="60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;课件&lt;/strong&gt;：&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/intro_RL.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture 1: Introduction to Reinforcement Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av9831889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Silver深度强化学习第1课 - 简介 (中文字幕)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="强化学习" scheme="https://orzyt.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://orzyt.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode637 Average of Levels in Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode637-average-of-levels-in-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">LeetCode637 Average of Levels in Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次遍历,使用空指针作为每层的分界.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root); que.push(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* u = que.front(); que.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ret.push_back(sum / cnt);</span><br><span class="line">                sum = cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!que.empty()) que.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += u-&gt;val; cnt++;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left) que.push(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right) que.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/average-of-levels-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode654 Maximum Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode654-maximum-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode654-maximum-binary-tree/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">LeetCode654 Maximum Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归构造二叉搜索树,树的左右儿子都比父结点小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = nums[l], id = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; nums[i]) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = num;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= id - <span class="number">1</span>) node-&gt;left = helper(nums, l, id - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (id + <span class="number">1</span> &lt;= r) node-&gt;right = helper(nums, id + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode657 Robot Return to Origin</title>
    <link href="https://orzyt.cn/posts/leetcode657-robot-return-to-origin/"/>
    <id>https://orzyt.cn/posts/leetcode657-robot-return-to-origin/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">LeetCode657 Robot Return to Origin</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断上和下,左和右的次数是否相同即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c: moves) f[c]++;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="string">'U'</span>] == f[<span class="string">'D'</span>] &amp;&amp; f[<span class="string">'L'</span>] == f[<span class="string">'R'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-return-to-or
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode661 Image Smoother</title>
    <link href="https://orzyt.cn/posts/leetcode661-image-smoother/"/>
    <id>https://orzyt.cn/posts/leetcode661-image-smoother/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode661 Image Smoother</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按题意模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size(), m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    sum += M[x][y];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i].push_back(sum / cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/image-smoother/&quot; t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665 Non-decreasing Array</title>
    <link href="https://orzyt.cn/posts/leetcode665-non-decreasing-array/"/>
    <id>https://orzyt.cn/posts/leetcode665-non-decreasing-array/</id>
    <published>2019-02-08T09:23:30.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">LeetCode665 Non-decreasing Array</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断只修改一个数能否使得数组非递减.</p><p>首先计算数组从左往右能延伸的距离$l$,从右往左能延伸的距离$r$.</p><p>可行的情况有:</p><ul><li>$ r \leq l $</li><li>$r == l + 1$ 且 满足下列情况之一<ul><li>r 为最后一位</li><li>l位置的值 $ \leq $ r + 1位置的值</li><li>l为首位 </li><li>l-1位置的值 $ \leq $ r 位置的值</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> siz = nums.size(), l = <span class="number">0</span>, r = siz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; siz &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r - <span class="number">1</span>] &lt;= nums[r]) r--;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l || (r == l + <span class="number">1</span> &amp;&amp; ((nums[l] &lt;= nums[r + <span class="number">1</span>] || r == siz - <span class="number">1</span>) || (l == <span class="number">0</span> || nums[l - <span class="number">1</span>] &lt;= nums[r])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/non-decreasing-arr
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617 Merge Two Binary Trees</title>
    <link href="https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/"/>
    <id>https://orzyt.cn/posts/leetcode617-merge-two-binary-trees/</id>
    <published>2019-02-08T09:02:05.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode617 Merge Two Binary Trees</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的合并.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t1 ? t1 : t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode606 Construct String from Binary Tree</title>
    <link href="https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/"/>
    <id>https://orzyt.cn/posts/leetcode606-construct-string-from-binary-tree/</id>
    <published>2019-02-08T09:01:50.000Z</published>
    <updated>2019-02-08T10:25:59.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode606 Construct String from Binary Tree</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的简单遍历.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> to_string(t-&gt;val);</span><br><span class="line">        <span class="built_in">string</span> ret = to_string(t-&gt;val) + <span class="string">"("</span> + dfs(t-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) ret += <span class="string">"("</span> + dfs(t-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-string-f
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode599 Minimum Index Sum of Two Lists</title>
    <link href="https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/"/>
    <id>https://orzyt.cn/posts/leetcode599-minimum-index-sum-of-two-lists/</id>
    <published>2019-02-08T09:01:34.000Z</published>
    <updated>2019-02-08T10:25:59.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode599 Minimum Index Sum of Two Lists</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出交集中下标和最小值.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size(), m = list2.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) hs[list1[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hs.count(list2[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = hs[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; minSum) &#123;</span><br><span class="line">                    minSum = i + j;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == minSum) &#123;</span><br><span class="line">                    ans.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-index-sum-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode38 Count and Say</title>
    <link href="https://orzyt.cn/posts/leetcode38-count-and-say/"/>
    <id>https://orzyt.cn/posts/leetcode38-count-and-say/</id>
    <published>2019-02-08T09:00:37.000Z</published>
    <updated>2019-02-08T10:25:59.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode38 Count and Say</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照规则模拟即可.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"1"</span>, ans = s;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">int</span> len = s.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] == s[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += to_string(count) + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/&quot; ta
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】深度人脸识别综述</title>
    <link href="https://orzyt.cn/posts/deep-face-recognition/"/>
    <id>https://orzyt.cn/posts/deep-face-recognition/</id>
    <published>2019-01-22T06:04:24.000Z</published>
    <updated>2019-02-26T11:20:51.367Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>论文题目</strong>：《Deep Face Recognition: A Survey》</p><p><strong>论文作者</strong>：Mei Wang, Weihong Deng</p><p><strong>论文链接</strong>：<a href="http://cn.arxiv.org/pdf/1804.06655.pdf" target="_blank" rel="noopener">http://cn.arxiv.org/pdf/1804.06655.pdf</a></p><hr><a id="more"></a><p>随着2012年AlexNet赢得了ImageNet挑战赛的冠军后，深度学习技术在各个领域都发挥着重要的作用，极大地提升了许多任务的SOTA。2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次在著名的非受限环境人脸数据集——LFW上取得了与人类相媲美的准确率（DeepFace: 97.35% vs. Human: 97.53%）。因此，本文主要关注深度学习技术在人脸识别领域的应用与发展。</p><h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>人脸系统一般包括三个部分：</p><ul><li><p><strong>人脸检测（face detection）</strong>：对于一幅图像，检测其中人脸的位置；</p></li><li><p><strong>人脸对齐（face alignment）</strong>：根据人脸关键点，将人脸对齐到一个典型的角度；</p></li><li><p><strong>人脸识别（face recognition</strong>）：包括人脸处理、人脸表示和人脸匹配部分。</p></li></ul><p><img alt="人脸系统示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1j4up5oj21cb0ik489.jpg" width="100%" height="100%"></p><ul><li><p><strong>训练集（training set）</strong>：用于训练系统的人脸集；</p></li><li><p><strong>注册集（gallery set）</strong>：提前注册在系统中用于比对的标准人脸集；</p></li><li><p><strong>测试集（probe set）</strong>：用于测试的人脸集。</p></li></ul><p>人脸识别任务主要包括：</p><ul><li><p><strong>人脸认证（face identification）</strong>：为<strong>1:N</strong>的问题。通过计算测试个体与注册集个体的相似度，判断出当前测试个体的身份。根据测试集中的个体是否出现在注册集中，可分为<strong>闭集（closed-set）</strong>和<strong>开集（open-set）</strong>问题。</p></li><li><p><strong>人脸验证（face verification）</strong>：为<strong>1:1</strong>的问题。对测试集和验证集中的个体进行两两比对，判断是否是同一个体。</p></li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="主流结构"><a href="#主流结构" class="headerlink" title="主流结构"></a>主流结构</h3><p>在人脸识别问题中，主流的网络结构基本上都借鉴于物体分类问题，一直从AlexNet到SENet。</p><p>在2014年，DeepFace<sup><a href="#fn_1" id="reffn_1">1</a></sup>首次使用九层的卷积神经网络，经过3D人脸对齐处理，在LFW上达到了97.35%的准确率。在2015年，FaceNet<sup><a href="#fn_9" id="reffn_9">9</a></sup>在一个很大的私人数据集上训练GoogLeNet，采用triplet loss，得到99.63%的准确率。同年，VGGface<sup><a href="#fn_10" id="reffn_10">10</a></sup>从互联网中收集了一个大的数据集，并在其上训练VGGNet，得到了98.95%的准确率。在2017年，SphereFace<sup><a href="#fn_11" id="reffn_11">11</a></sup>使用64层的ResNet结构，采用angular softmax（A-softmax）loss，得到99.42%的准确率。在2017年末，VGGFace2<sup><a href="#fn_12" id="reffn_12">12</a></sup>作为一个新人脸的数据集被引入，同时使用SENet进行训练，在IJB-A和IJB-B上都取得SOTA。</p><p><img alt="主流网络结构的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jnv2szj210109oacr.jpg" width="90%" height="90%"></p><ul><li><p><code>AlexNet</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>：AlexNet包括五个卷积层和三个全连接层，并且集成了如ReLU、dropout、数据增强等技术；</p></li><li><p><code>VGGNet</code><sup><a href="#fn_3" id="reffn_3">3</a></sup>：使用3×3卷积核，且每经过2×2的池化后特征图数量加倍，网络深度为16-19层；</p></li><li><p><code>GoogLeNet</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>：提出了inception module，对不同尺度的特征图进行混合；</p></li><li><p><code>ResNet</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>：通过学习残差表示，使得训练更深网络成为可能；</p></li><li><p><code>SENet</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>：提出了Squeeze-and-Excitation操作，通过显式建模channel之间的相互依赖性，自适应地重新校准channel间的特征响应。</p></li></ul><p><img alt="主流网络结构示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1jytblsj20of0kgwhp.jpg" width="60%" height="60%"></p><h3 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h3><ul><li><p><code>Light CNN</code><sup><a href="#fn_7" id="reffn_7">7</a></sup></p></li><li><p><code>bilinear CNN</code><sup><a href="#fn_8" id="reffn_8">8</a></sup></p></li><li><p>…</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在一开始，人们使用和物体分类同样的基于交叉熵的softmax loss，后来发现其不适用于人脸特征的学习，于是开始探索更具有判别性的loss。</p><p><img alt="人脸损失函数的演变" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1kfbt7kj217u0e8dlk.jpg" width="90%" height="90%"></p><p><img alt="不同方法在LFW数据集上的准确率" src="https://wx2.sinaimg.cn/large/8662e3cegy1g0k1kr4sx8j215r0k9wlm.jpg" width="90%" height="90%"></p><h3 id="基于欧几里德距离"><a href="#基于欧几里德距离" class="headerlink" title="基于欧几里德距离"></a>基于欧几里德距离</h3><hr><h4 id="contrastive-loss"><a href="#contrastive-loss" class="headerlink" title="contrastive loss"></a>contrastive loss</h4><p>相关文献：</p><ul><li><strong>《Deep learning face representation by joint identification-verification》</strong></li><li><strong>《Deepid3: Face recognition with very deep neural networks》</strong></li></ul><p>DeepID系列使用的loss。</p><script type="math/tex; mode=display">\operatorname { Verif } \left( f _ { i } , f _ { j } , y _ { i j } , \theta _ { v e } \right) = \left\{ \begin{array} { l l } { \frac { 1 } { 2 } \left\| f _ { i } - f _ { j } \right\| _ { 2 } ^ { 2 } } & { \text { if } y _ { i j } = 1 } \\ { \frac { 1 } { 2 } \max \left( 0 , m - \left\| f _ { i } - f _ { j } \right\| _ { 2 } \right) ^ { 2 } } & { \text { if } y _ { i j } = - 1 } \end{array} \right.</script><hr><h4 id="triplet-loss"><a href="#triplet-loss" class="headerlink" title="triplet loss"></a>triplet loss</h4><p>相关文献：</p><ul><li><strong>《Facenet: A unified embedding for face recognition and clustering》</strong></li></ul><script type="math/tex; mode=display">\mathcal{L} = \sum _ { i } ^ { N } \left[ \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { p } \right) \right\| _ { 2 } ^ { 2 } - \left\| f \left( x _ { i } ^ { a } \right) - f \left( x _ { i } ^ { n } \right) \right\| _ { 2 } ^ { 2 } + \alpha \right] _ { + }</script><p><img alt="triplet loss示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1l9pm84j20x007ht9n.jpg" width="70%" height="70%"></p><hr><h4 id="center-loss"><a href="#center-loss" class="headerlink" title="center loss"></a>center loss</h4><p>相关文献：</p><ul><li><strong>《A Discriminative Feature Learning Approach for Deep Face Recognition》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } & = \mathcal { L } _ { S } + \lambda \mathcal { L } _ { C } \\ & = - \sum _ { i = 1 } ^ { m } \log \frac { e ^ { W _ { y _ { i } } ^ { T } \boldsymbol { x } _ { i } + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } \boldsymbol { x } _ { i } + b _ { j } } } + \frac { \lambda } { 2 } \sum _ { i = 1 } ^ { m } \left\| \boldsymbol { x } _ { i } - \boldsymbol { c } _ { y _ { i } } \right\| _ { 2 } ^ { 2 } \end{aligned}</script><p><img alt="center loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lnsllgj20tr0m1qdq.jpg" width="60%" height="60%"></p><hr><h4 id="range-loss"><a href="#range-loss" class="headerlink" title="range loss"></a>range loss</h4><p>相关文献：</p><ul><li><strong>《Range loss for deep face recognition with long-tail》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { R } = \alpha \mathcal { L } _ { R _ { i n t r a } } + \beta \mathcal { L } _ { R _ { i n t e r } }</script><script type="math/tex; mode=display">\mathcal { L } _ { R _ { i n t r a } } = \sum _ { i \subseteq I } \mathcal { L } _ { R _ { i n t r a }}^ { i } = \sum _ { i \subseteq I } \frac { k } { \sum _ { j = 1 } ^ { k } \frac { 1 } { \mathcal { D } _ { j } } }</script><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { R _ { \text {inter} } } & = \max \left( m - \mathcal { D } _ { C e n t e r } , 0 \right) \\ & = \max \left( m - \left\| \overline { x } _ { \mathcal { Q } } - \overline { x } _ { \mathcal { R } } \right\| _ { 2 } ^ { 2 } , 0 \right) \end{aligned}</script><script type="math/tex; mode=display">\mathcal { L } = \mathcal { L } _ { M } + \lambda \mathcal { L } _ { R } = - \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } x _ { i } + b _ { v _ { i } } } } { \sum _ { j = 1 } ^ { n } e ^ { W _ { j } ^ { T } x _ { i } + b _ { j } } } + \lambda \mathcal { L } _ { R }</script><hr><h4 id="center-invariant-loss"><a href="#center-invariant-loss" class="headerlink" title="center-invariant loss"></a>center-invariant loss</h4><p>相关文献：</p><ul><li><strong>《Deep face recognition with center invariant loss》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} L = & L _ { s } + \gamma L _ { I } + \lambda L _ { c } \\ = & - \log \left( \frac { e ^ { \mathbf { w } _ { y } ^ { T } \mathbf { x } _ { i } + b _ { y } } } { \sum _ { j = 1 } ^ { m } e ^ { \mathbf { w } _ { j } ^ { T } \mathbf { x } _ { i } + b _ { j } } } \right) + \frac { \gamma } { 4 } \left( \left\| \mathbf { c } _ { y } \right\| _ { 2 } ^ { 2 } - \frac { 1 } { m } \sum _ { k = 1 } ^ { m } \left\| \mathbf { c } _ { k } \right\| _ { 2 } ^ { 2 } \right) ^ { 2 } \\ & + \frac { \lambda } { 2 } \left\| \mathbf { x } _ { i } - \mathbf { c } _ { y } \right\| ^ { 2 } \end{aligned}</script><p><img alt="center invariant loss示意图" src="https://ws3.sinaimg.cn/large/8662e3cegy1g0k1lvxp55j20zt0i4n3g.jpg" width="60%" height="60%"></p><hr><h3 id="基于角度-余弦间隔"><a href="#基于角度-余弦间隔" class="headerlink" title="基于角度/余弦间隔"></a>基于角度/余弦间隔</h3><hr><h4 id="L-Softmax-loss"><a href="#L-Softmax-loss" class="headerlink" title="L-Softmax loss"></a>L-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Large-margin softmax loss for convolutional neural networks》</strong></li></ul><script type="math/tex; mode=display">L _ { i } = - \log \left( \frac { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } \right) } } { e ^ { \left\| \boldsymbol { W } _ { y _ { i } } \right\| \boldsymbol { w } \left( \theta _ { \boldsymbol { y } _ { i } } \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { W } _ { j } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j } \right) } } \right)</script><script type="math/tex; mode=display">\psi ( \theta ) = ( - 1 ) ^ { k } \cos ( m \theta ) - 2 k , \quad \theta \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right]</script><script type="math/tex; mode=display">f _ { y _ { i } } = \frac { \lambda \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { y _ { i } } \right) + \left\| \boldsymbol { W } _ { y _ { i } } \right\| \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { \boldsymbol { y } _ { i } } \right) } { 1 + \lambda }</script><p><img alt="L-Softmax loss二分类示意图" src="https://ws2.sinaimg.cn/large/8662e3cegy1g0k1m4b63ij20fv0ib40x.jpg" width="50%" height="50%"></p><hr><h4 id="A-Softmax-loss"><a href="#A-Softmax-loss" class="headerlink" title="A-Softmax loss"></a>A-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Sphereface: Deep hypersphere embedding for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { \mathrm { ang } } = \frac { 1 } { N } \sum _ { i } - \log \left( \frac { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } , i } \right) } } { e ^ { \left\| \boldsymbol { x } _ { i } \right\| \psi \left( \theta _ { y _ { i } } , i \right) } + \sum _ { j \neq y _ { i } } e ^ { \left\| \boldsymbol { x } _ { i } \right\| \cos \left( \theta _ { j , i } \right) } } \right)</script><script type="math/tex; mode=display">\psi \left( \theta _ { y _ { i } , i } \right) = ( - 1 ) ^ { k } \cos \left( m \theta _ { y _ { i } , i } \right) - 2 k</script><script type="math/tex; mode=display">\theta _ { y _ { i } , i } \in \left[ \frac { k \pi } { m } , \frac { ( k + 1 ) \pi } { m } \right] \text { and } k \in [ 0 , m - 1 ]</script><p><img alt="A-Softmax loss示意图" src="https://wx4.sinaimg.cn/large/8662e3cegy1g0k1mg2yrlj20hk0ca0v4.jpg" width="50%" height="50%"></p><hr><h4 id="AM-Softmax-loss"><a href="#AM-Softmax-loss" class="headerlink" title="AM-Softmax loss"></a>AM-Softmax loss</h4><p>相关文献：</p><ul><li><strong>《Additive margin softmax for face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{aligned} \mathcal { L } _ { A M S } & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } } { e ^ { s \cdot \left( \cos \theta _ { y _ { i } } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { s \cdot c o s \theta _ { j } } } \\ & = - \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \log \frac { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } f _ { i } - m \right) } } { e ^ { s \cdot \left( W _ { y _ { i } } ^ { T } \boldsymbol { f } _ { i } - m \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { c } e ^ { S W _ { j } ^ { T } \boldsymbol { f } _ { i } } } \end{aligned}</script><p><img alt="AM-Softmax loss示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mmsrz1j20n808dwfx.jpg" width="60%" height="60%"></p><hr><h4 id="CosFace"><a href="#CosFace" class="headerlink" title="CosFace"></a>CosFace</h4><p>相关文献：</p><ul><li><strong>《Cosface: Large margin cosine loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { l m c } = \frac { 1 } { N } \sum _ { i } - \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } , i } \right) - m \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } , i \right) - m \right) } + \sum _ { j \neq y _ { i } } e ^ { s \cos \left( \theta _ { j , i } \right) } }</script><script type="math/tex; mode=display">\begin{aligned} \text { subject to } \\  W & = \frac { W ^ { * } } { \left\| W ^ { * } \right\| } \\  x & = \frac { x ^ { * } } { \left\| x ^ { * } \right\| } \\ \cos \left( \theta _ { j } , i \right) & = W _ { j } ^ { T } x _ { i } \end{aligned}</script><p><img alt="CosFace示意图" src="https://wx1.sinaimg.cn/large/8662e3cegy1g0k1mtlmpmj20ck04sq3j.jpg" width="60%" height="60%"></p><hr><h4 id="ArcFace"><a href="#ArcFace" class="headerlink" title="ArcFace"></a>ArcFace</h4><p>相关文献：</p><ul><li><strong>《Arcface: Additive angular margin loss for deep face recognition》</strong></li></ul><script type="math/tex; mode=display">L  = - \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \log \frac { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } } { e ^ { s \left( \cos \left( \theta _ { y _ { i } } + m \right) \right) } + \sum _ { j = 1 , j \neq y _ { i } } ^ { n } e ^ { s \cos \theta _ { j } } }</script><p><img alt="ArcFace示意图" src="https://wx3.sinaimg.cn/large/8662e3cegy1g0k1mz40h8j21640ad0wf.jpg" width="100%" height="100%"></p><hr><h3 id="Softmax及其变种"><a href="#Softmax及其变种" class="headerlink" title="Softmax及其变种"></a>Softmax及其变种</h3><hr><h4 id="L2-Softmax"><a href="#L2-Softmax" class="headerlink" title="L2-Softmax"></a>L2-Softmax</h4><p>相关文献：</p><ul><li><strong>《L2-constrained softmax loss for discriminative face verification》</strong></li></ul><script type="math/tex; mode=display">\begin{array} { l l } { \text { minimize } } & { - \frac { 1 } { M } \sum _ { i = 1 } ^ { M } \log \frac { e ^ { W _ { y _ { i } } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { y _ { i } } } } { \sum _ { j = 1 } ^ { C } e ^ { W _ { j } ^ { T } f \left( \mathbf { x } _ { i } \right) + b _ { j } } } } \\ { \text { subject to } } & { \left\| f \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } = \alpha , \forall i = 1,2 , \ldots M } \end{array}</script><hr><h4 id="Normface"><a href="#Normface" class="headerlink" title="Normface"></a>Normface</h4><p>相关文献：</p><ul><li><strong>《NormFace: L2 Hypersphere Embedding for Face Verification》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } _ { S' }  = - \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \log \frac { e ^ { s \tilde { W } _ { y _ { i } } ^ { T } \tilde { \mathbf { f } } _ { i } } } { \sum _ { j = 1 } ^ { n } e ^ { s \tilde { W } _ { j } ^ { T } \mathbf { f } _ { i } } }</script><script type="math/tex; mode=display">\tilde { \mathbf { x } } = \frac { \mathbf { x } } { \| \mathbf { x } \| _ { 2 } } = \frac { \mathbf { x } } { \sqrt { \sum _ { i } \mathbf { x } _ { i } ^ { 2 } + \epsilon } }</script><hr><h4 id="CoCo-loss"><a href="#CoCo-loss" class="headerlink" title="CoCo loss"></a>CoCo loss</h4><p>相关文献：</p><ul><li><strong>《Rethinking feature discrimination and polymerization for large-scale recognition》</strong></li></ul><script type="math/tex; mode=display">\mathcal { L } ^ { C O C O } \left( \boldsymbol { f } ^ { ( i ) } , \boldsymbol { c } _ { k } \right) = - \sum _ { i \in \mathcal { B } , k } t _ { k } ^ { ( i ) } \log p _ { k } ^ { ( i ) } = - \sum _ { i \in \mathcal { B } } \log p _ { l _ { i } } ^ { ( i ) }</script><script type="math/tex; mode=display">\hat { \boldsymbol { c } } _ { k } = \frac { \boldsymbol { c } _ { k } } { \left\| \boldsymbol { c } _ { k } \right\| } , \hat { \boldsymbol { f } } ^ { ( i ) } = \frac { \alpha \boldsymbol { f } ^ { ( i ) } } { \left\| \boldsymbol { f } ^ { ( i ) } \right\| } , p _ { k } ^ { ( i ) } = \frac { \exp \left( \hat { \boldsymbol { c } } _ { k } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) } { \sum _ { m } \exp \left( \hat { \boldsymbol { c } } _ { m } ^ { T } \cdot \hat { \boldsymbol { f } } ^ { ( i ) } \right) }</script><hr><h4 id="Ring-loss"><a href="#Ring-loss" class="headerlink" title="Ring loss"></a>Ring loss</h4><p>相关文献：</p><ul><li><strong>《Ring loss: Convex feature normalization for face recognition》</strong></li></ul><script type="math/tex; mode=display">L _ { R } = \frac { \lambda } { 2 m } \sum _ { i = 1 } ^ { m } \left( \left\| \mathcal { F } \left( \mathbf { x } _ { i } \right) \right\| _ { 2 } - R \right) ^ { 2 }</script><p><img alt="Ring loss示意图" src="https://ws1.sinaimg.cn/large/8662e3cegy1g0k1n6hmq9j20lo09g0wz.jpg" width="60%" height="60%"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. <strong>Deepface: Closing the gap to human-level performance in face verification</strong>. In CVPR, pages 1701–1708, 2014.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton. <strong>Imagenet classification with deep convolutional neural networks</strong>. In NIPS, pages 1097–1105, 2012.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. K. Simonyan and A. Zisserman. <strong>Very deep convolutional networks for large-scale image recognition</strong>. arXiv preprint arXiv:1409.1556, 2014.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V. Vanhoucke, A. Rabinovich, et al. <strong>Going deeper with convolutions</strong>. In CVPR, 2015.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. K. He, X. Zhang, S. Ren, and J. Sun. <strong>Deep residual learning for image recognition</strong>. In CVPR, pages 770–778, 2016.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. J. Hu, L. Shen, and G. Sun. <strong>Squeeze-and-excitation networks</strong>. arXiv preprint arXiv:1709.01507, 2017.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. X. Wu, R. He, Z. Sun, and T. Tan. <strong>A light cnn for deep face representation with noisy labels</strong>. arXiv preprint arXiv:1511.02683, 2015.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. A. R. Chowdhury, T.-Y. Lin, S. Maji, and E. Learned-Miller. <strong>One-to-many face recognition with bilinear cnns</strong>. In WACV, pages 1–9. IEEE, 2016.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. F. Schroff, D. Kalenichenko, and J. Philbin. <strong>Facenet: A unified embedding for face recognition and clustering</strong>. In CVPR, pages 815–823, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. O. M. Parkhi, A. Vedaldi, A. Zisserman, et al. <strong>Deep face recognition</strong>. In BMVC, volume 1, page 6, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote><blockquote id="fn_11"><sup>11</sup>. W. Liu, Y. Wen, Z. Yu, M. Li, B. Raj, and L. Song. <strong>Sphereface: Deep hypersphere embedding for face recognition</strong>. In CVPR, volume 1, 2017.<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a></blockquote><blockquote id="fn_12"><sup>12</sup>. Q. Cao, L. Shen, W. Xie, O. M. Parkhi, and A. Zisserman. <strong>Vggface2: A dataset for recognising faces across pose and age</strong>. arXiv preprint arXiv:1710.08092, 2017.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;论文题目&lt;/strong&gt;：《Deep Face Recognition: A Survey》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文作者&lt;/strong&gt;：Mei Wang, Weihong Deng&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文链接&lt;/strong&gt;：&lt;a href=&quot;http://cn.arxiv.org/pdf/1804.06655.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn.arxiv.org/pdf/1804.06655.pdf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="论文笔记" scheme="https://orzyt.cn/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="深度学习" scheme="https://orzyt.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人脸识别" scheme="https://orzyt.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019学年研一上学期总结</title>
    <link href="https://orzyt.cn/posts/2018-2019-fall-semester-summary/"/>
    <id>https://orzyt.cn/posts/2018-2019-fall-semester-summary/</id>
    <published>2019-01-21T05:43:42.000Z</published>
    <updated>2019-01-22T06:49:10.651Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文暂未公开，请输入密码访问" />    <label for="pass">本文暂未公开，请输入密码访问</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">∑(っ°Д°;)っ 密码错误！</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;本文暂未公开，请输入密码访问
    
    </summary>
    
      <category term="随笔" scheme="https://orzyt.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="研究生学习" scheme="https://orzyt.cn/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈支持向量机的推导</title>
    <link href="https://orzyt.cn/posts/svm/"/>
    <id>https://orzyt.cn/posts/svm/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-02-28T11:38:06.625Z</updated>
    
    <content type="html"><![CDATA[<hr><iframe src="/svm.html" scrolling="no" width="100%" height="11100px"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;iframe src=&quot;/svm.html&quot; scrolling=&quot;no&quot; width=&quot;100%&quot; height=&quot;11100px&quot;&gt;&lt;/iframe&gt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://orzyt.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="支持向量机" scheme="https://orzyt.cn/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
      <category term="SVM" scheme="https://orzyt.cn/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode575 Distribute Candies</title>
    <link href="https://orzyt.cn/posts/leetcode575-distribute-candies/"/>
    <id>https://orzyt.cn/posts/leetcode575-distribute-candies/</id>
    <published>2018-01-14T05:21:28.000Z</published>
    <updated>2019-02-08T10:26:00.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有偶数个不同种类的糖果，将其平均分给两个人，问某人能够得到最多的种类数是多少</p><p>首先，用哈希表记录种类数，这是答案的上限，而一个人只能获得一半的糖果，所以这又是一个上限。</p><p>最终的答案为二者取最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: candies) count[x]++;</span><br><span class="line">        <span class="keyword">return</span> min(count.size(), candies.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an integer array with &lt;strong&gt;even&lt;/strong&gt; length, where differ
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://orzyt.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode566 Reshape the Matrix</title>
    <link href="https://orzyt.cn/posts/leetcode566-reshape-the-matrix/"/>
    <id>https://orzyt.cn/posts/leetcode566-reshape-the-matrix/</id>
    <published>2018-01-14T05:03:19.000Z</published>
    <updated>2019-02-08T10:26:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p><p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p><p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p><p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p><p><strong>Note:</strong></p><ol><li>The height and width of the given matrix is in range [1, 100].</li><li>The given r and c are all positive.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二维数组，模拟 MATLAB 中 <code>reshape</code> 函数的操作，若无法完成，则输出原数组</p><p>题中要求元素以<code>row-traversing</code>顺序访问，则$r$行$n$列的二维数组第$i$个访问到的元素所在的位置为($i / c$, $i \% c$)</p><p>利用这一关系，可以得到从原数组$nums$（$n$行$m$列）<code>reshape</code>成 新数组$vec$（$r$行$c$列）后的位置关系，$vec[i / c][i \% c] = nums[i / m][i \% m]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), m = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 元素数量不匹配，reshape失败</span></span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="comment">// 初始化二维vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; ++i) vec[i / c][i % c] = nums[i / m][i % m];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://orzyt.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode563 Binary Tree Tilt</title>
    <link href="https://orzyt.cn/posts/leetcode563-binary-tree-tilt/"/>
    <id>https://orzyt.cn/posts/leetcode563-binary-tree-tilt/</id>
    <published>2018-01-14T04:51:07.000Z</published>
    <updated>2019-02-08T10:26:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><a id="more"></a><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求二叉树的倾斜度。</p><p>一个节点的倾斜度是指：该节点 <strong>左子树所有节点值之和</strong> 与 <strong>右子树所有节点值之和</strong> 的 <code>绝对差值</code></p><p>一棵树的倾斜度是指：该棵树所有节点的倾斜度之和</p><p>对二叉树dfs一遍即可求出答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以root为根的子树所有节点值之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lsum = dfs(root-&gt;left), rsum = dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 添加节点root的倾斜度</span></span><br><span class="line">        ans += <span class="built_in">abs</span>(lsum - rsum);</span><br><span class="line">        <span class="keyword">return</span> lsum + rsum + root-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the tilt of the &lt;strong&gt;whole tree&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The tilt of a &lt;strong&gt;tree node&lt;/strong&gt; is defined as the &lt;strong&gt;absolute difference&lt;/strong&gt; between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.&lt;/p&gt;
&lt;p&gt;The tilt of the &lt;strong&gt;whole tree&lt;/strong&gt; is defined as the sum of all nodes’ tilt.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://orzyt.cn/tags/DFS/"/>
    
      <category term="二叉树" scheme="https://orzyt.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode561 Array Partition I</title>
    <link href="https://orzyt.cn/posts/leetcode561-array-partition-i/"/>
    <id>https://orzyt.cn/posts/leetcode561-array-partition-i/</id>
    <published>2018-01-14T04:31:32.000Z</published>
    <updated>2019-02-08T10:26:00.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p><strong>Note:</strong></p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将$2n$个元素两两分组($a_1$, $b_1$), ($a_2$, $b_2$), …, ($a_n$, $b_n$) ，使得这$n$个分组中最小值之和最大。</p><p>贪心题，将数组元素从小到大排序，然后相邻的两个元素分为一组。</p><p>可以这样考虑，假设元素$a_1$是数组中最小的元素，那么和$a_1$同一组的元素对答案是没有贡献的，因此，应该找到剩下的元素中值最小的和$a_1$匹配。以此类推，可以得出贪心的策略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) ans += nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; is a positive integer, which is in the range of [1, 10000].&lt;/li&gt;
&lt;li&gt;All the integers in the array will be in the range of [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://orzyt.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="greedy" scheme="https://orzyt.cn/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode557 Reverse Words in a String III</title>
    <link href="https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/"/>
    <id>https://orzyt.cn/posts/leetcode557-reverse-words-in-a-string-iii/</id>
    <published>2018-01-14T04:17:22.000Z</published>
    <updated>2019-02-08T10:26:00.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">&quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">Output: </span><br><span class="line">&quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将句子中的单词翻转（单词之间以空格隔开）</p><p>模拟一下，记录每个单词的起始位置和长度，然后翻转即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串翻转函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) swap(s[l++], s[r--]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="comment">// 变量p记录单词起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                str += rev(s.substr(p, i - p)) + <span class="string">' '</span>;</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判字符串末尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.size() - <span class="number">1</span>) str += rev(s.substr(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In the string, each word is separated by single space and there will not be any extra space in the string.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://orzyt.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://orzyt.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://orzyt.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ssh本地端口转发的应用</title>
    <link href="https://orzyt.cn/posts/ssh-port-forwarding/"/>
    <id>https://orzyt.cn/posts/ssh-port-forwarding/</id>
    <published>2018-01-13T07:34:17.000Z</published>
    <updated>2019-02-28T11:11:15.375Z</updated>
    
    <content type="html"><![CDATA[<hr><p>SSH有三种端口转发模式，<strong>本地端口转发(Local Port Forwarding)</strong>，<strong>远程端口转发(Remote Port Forwarding)</strong>以及<strong>动态端口转发(Dynamic Port Forwarding)</strong>。本文只简单介绍<strong>本地端口转发</strong>，用于实现本机访问远程服务器上的<code>jupyter notebook</code>、<code>TensorBoard</code>等服务。</p><a id="more"></a><h2 id="什么是本地端口转发？"><a href="#什么是本地端口转发？" class="headerlink" title="什么是本地端口转发？"></a>什么是本地端口转发？</h2><p>所谓本地端口转发，就是<strong>将发送到本地端口的请求，转发到目标端口</strong>。这样，就可以通过访问本地端口，来访问目标端口的服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -h</span><br><span class="line">unknown option -- h</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>需要用到的命令是<code>ssh -L address user@hostname</code> </p><p>其中，address的具体语法为 <code>[bind_address:]port:host:hostport</code> ，即 <strong>[本地主机地址:]本地端口:目标地址:目标端口</strong></p><h2 id="应用场景-—-以-jupyter-notebook-为例"><a href="#应用场景-—-以-jupyter-notebook-为例" class="headerlink" title="应用场景 — 以 jupyter notebook 为例"></a>应用场景 — 以 jupyter notebook 为例</h2><p>由于服务器上一般是没有安装桌面的，所以像<code>jupyter notebook</code>、<code>TensorBoard</code>等服务是无法直接通过服务器上的浏览器来访问。因此，我们需要采取ssh的本地端口转发方式，从而通过访问本地端口，来访问服务器上目标端口的服务。</p><hr><p>首先，在服务器上运行<code>jupyter notebook</code></p><p>会发现有一个黄色的 <strong>warning</strong>: <em>No web browser found: could not locate runnable browser.</em> (说明服务器上是无法打开的)</p><p>然后，我们记下<strong>端口号</strong>（8008）以及 <strong>token</strong>（链接中?token=后面一长串的字符，用于登录认证）</p><p>接着，执行以下命令进行本地端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f: 后台执行命令</span></span><br><span class="line"><span class="comment"># N: 不进行实际连接，而仅做端口转发</span></span><br><span class="line"><span class="comment"># 本地主机地址可省略，本地端口号随意填，远程端口号为上述的8008</span></span><br><span class="line">ssh -fNL 本地端口号:localhost:远程端口号 username@serverAddress</span><br></pre></td></tr></table></figure><p>最后，在本机打开地址<code>localhost:本地端口号</code> 输入token后即可访问服务器上的 <code>jupyter notebook</code> </p><p><img src="https://tuchuang001.com/images/2018/01/13/jupyter.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;SSH有三种端口转发模式，&lt;strong&gt;本地端口转发(Local Port Forwarding)&lt;/strong&gt;，&lt;strong&gt;远程端口转发(Remote Port Forwarding)&lt;/strong&gt;以及&lt;strong&gt;动态端口转发(Dynamic Port Forwarding)&lt;/strong&gt;。本文只简单介绍&lt;strong&gt;本地端口转发&lt;/strong&gt;，用于实现本机访问远程服务器上的&lt;code&gt;jupyter notebook&lt;/code&gt;、&lt;code&gt;TensorBoard&lt;/code&gt;等服务。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://orzyt.cn/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ssh" scheme="https://orzyt.cn/tags/ssh/"/>
    
      <category term="端口转发" scheme="https://orzyt.cn/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="jupyter notebook" scheme="https://orzyt.cn/tags/jupyter-notebook/"/>
    
      <category term="tensorboard" scheme="https://orzyt.cn/tags/tensorboard/"/>
    
  </entry>
  
</feed>
